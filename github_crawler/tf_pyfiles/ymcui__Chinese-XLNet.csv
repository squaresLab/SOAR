file_path,api_count,code
src/__init__.py,0,b''
src/classifier_utils.py,6,"b'from absl import flags\n\nimport re\nimport numpy as np\n\nimport tensorflow as tf\nfrom data_utils import SEP_ID, CLS_ID\n\nFLAGS = flags.FLAGS\n\nSEG_ID_A   = 0\nSEG_ID_B   = 1\nSEG_ID_CLS = 2\nSEG_ID_SEP = 3\nSEG_ID_PAD = 4\n\nclass PaddingInputExample(object):\n  """"""Fake example so the num input examples is a multiple of the batch size.\n  When running eval/predict on the TPU, we need to pad the number of examples\n  to be a multiple of the batch size, because the TPU requires a fixed batch\n  size. The alternative is to drop the last batch, which is bad because it means\n  the entire output data won\'t be generated.\n  We use this class instead of `None` because treating `None` as padding\n  battches could cause silent errors.\n  """"""\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               input_ids,\n               input_mask,\n               segment_ids,\n               label_id,\n               is_real_example=True):\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.segment_ids = segment_ids\n    self.label_id = label_id\n    self.is_real_example = is_real_example\n\n\ndef _truncate_seq_pair(tokens_a, tokens_b, max_length):\n  """"""Truncates a sequence pair in place to the maximum length.""""""\n\n  # This is a simple heuristic which will always truncate the longer sequence\n  # one token at a time. This makes more sense than truncating an equal percent\n  # of tokens from each, since if one sequence is very short then each token\n  # that\'s truncated likely contains more information than a longer sequence.\n  while True:\n    total_length = len(tokens_a) + len(tokens_b)\n    if total_length <= max_length:\n      break\n    if len(tokens_a) > len(tokens_b):\n      tokens_a.pop()\n    else:\n      tokens_b.pop()\n\n\ndef convert_single_example(ex_index, example, label_list, max_seq_length,\n                              tokenize_fn):\n  """"""Converts a single `InputExample` into a single `InputFeatures`.""""""\n\n  if isinstance(example, PaddingInputExample):\n    return InputFeatures(\n        input_ids=[0] * max_seq_length,\n        input_mask=[1] * max_seq_length,\n        segment_ids=[0] * max_seq_length,\n        label_id=0,\n        is_real_example=False)\n\n  if label_list is not None:\n    label_map = {}\n    for (i, label) in enumerate(label_list):\n      label_map[label] = i\n\n  tokens_a = tokenize_fn(example.text_a)\n  tokens_b = None\n  if example.text_b:\n    tokens_b = tokenize_fn(example.text_b)\n\n  if tokens_b:\n    # Modifies `tokens_a` and `tokens_b` in place so that the total\n    # length is less than the specified length.\n    # Account for two [SEP] & one [CLS] with ""- 3""\n    _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n  else:\n    # Account for one [SEP] & one [CLS] with ""- 2""\n    if len(tokens_a) > max_seq_length - 2:\n      tokens_a = tokens_a[:max_seq_length - 2]\n\n  tokens = []\n  segment_ids = []\n  for token in tokens_a:\n    tokens.append(token)\n    segment_ids.append(SEG_ID_A)\n  tokens.append(SEP_ID)\n  segment_ids.append(SEG_ID_A)\n\n  if tokens_b:\n    for token in tokens_b:\n      tokens.append(token)\n      segment_ids.append(SEG_ID_B)\n    tokens.append(SEP_ID)\n    segment_ids.append(SEG_ID_B)\n\n  tokens.append(CLS_ID)\n  segment_ids.append(SEG_ID_CLS)\n\n  input_ids = tokens\n\n  # The mask has 0 for real tokens and 1 for padding tokens. Only real\n  # tokens are attended to.\n  input_mask = [0] * len(input_ids)\n\n  # Zero-pad up to the sequence length.\n  if len(input_ids) < max_seq_length:\n    delta_len = max_seq_length - len(input_ids)\n    input_ids = [0] * delta_len + input_ids\n    input_mask = [1] * delta_len + input_mask\n    segment_ids = [SEG_ID_PAD] * delta_len + segment_ids\n\n  assert len(input_ids) == max_seq_length\n  assert len(input_mask) == max_seq_length\n  assert len(segment_ids) == max_seq_length\n\n  if label_list is not None:\n    label_id = label_map[example.label]\n  else:\n    label_id = example.label\n  if ex_index < 5:\n    tf.logging.info(""*** Example ***"")\n    tf.logging.info(""guid: %s"" % (example.guid))\n    tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n    tf.logging.info(""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n    tf.logging.info(""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n    tf.logging.info(""label: {} (id = {})"".format(example.label, label_id))\n\n  feature = InputFeatures(\n      input_ids=input_ids,\n      input_mask=input_mask,\n      segment_ids=segment_ids,\n      label_id=label_id)\n  return feature\n\n\n\n'"
src/cmrc2018_evaluate_drcd.py,0,"b'# -*- coding: utf-8 -*-\n\'\'\'\nEvaluation script for CMRC 2018\nversion: v5\nNote: \nv5 formatted output, add usage description\nv4 fixed segmentation issues\n\'\'\'\nfrom __future__ import print_function\nfrom collections import Counter, OrderedDict\nimport string\nimport re\nimport argparse\nimport json\nimport sys\nreload(sys)\nsys.setdefaultencoding(\'utf8\')\nimport nltk\nimport pdb\n\n# split Chinese with English\ndef mixed_segmentation(in_str, rm_punc=False):\n\tin_str = str(in_str).decode(\'utf-8\').lower().strip()\n\tsegs_out = []\n\ttemp_str = """"\n\tsp_char = [\'-\',\':\',\'_\',\'*\',\'^\',\'/\',\'\\\\\',\'~\',\'`\',\'+\',\'=\',\n\t\t\t   \'\xef\xbc\x8c\',\'\xe3\x80\x82\',\'\xef\xbc\x9a\',\'\xef\xbc\x9f\',\'\xef\xbc\x81\',\'\xe2\x80\x9c\',\'\xe2\x80\x9d\',\'\xef\xbc\x9b\',\'\xe2\x80\x99\',\'\xe3\x80\x8a\',\'\xe3\x80\x8b\',\'\xe2\x80\xa6\xe2\x80\xa6\',\'\xc2\xb7\',\'\xe3\x80\x81\',\n\t\t\t   \'\xe3\x80\x8c\',\'\xe3\x80\x8d\',\'\xef\xbc\x88\',\'\xef\xbc\x89\',\'\xef\xbc\x8d\',\'\xef\xbd\x9e\',\'\xe3\x80\x8e\',\'\xe3\x80\x8f\']\n\tfor char in in_str:\n\t\tif rm_punc and char in sp_char:\n\t\t\tcontinue\n\t\tif re.search(ur\'[\\u4e00-\\u9fa5]\', char) or char in sp_char:\n\t\t\tif temp_str != """":\n\t\t\t\tss = nltk.word_tokenize(temp_str)\n\t\t\t\tsegs_out.extend(ss)\n\t\t\t\ttemp_str = """"\n\t\t\tsegs_out.append(char)\n\t\telse:\n\t\t\ttemp_str += char\n\n\t#handling last part\n\tif temp_str != """":\n\t\tss = nltk.word_tokenize(temp_str)\n\t\tsegs_out.extend(ss)\n\n\treturn segs_out\n\n\n# remove punctuation\ndef remove_punctuation(in_str):\n\tin_str = str(in_str).decode(\'utf-8\').lower().strip()\n\tsp_char = [\'-\',\':\',\'_\',\'*\',\'^\',\'/\',\'\\\\\',\'~\',\'`\',\'+\',\'=\',\n\t\t\t   \'\xef\xbc\x8c\',\'\xe3\x80\x82\',\'\xef\xbc\x9a\',\'\xef\xbc\x9f\',\'\xef\xbc\x81\',\'\xe2\x80\x9c\',\'\xe2\x80\x9d\',\'\xef\xbc\x9b\',\'\xe2\x80\x99\',\'\xe3\x80\x8a\',\'\xe3\x80\x8b\',\'\xe2\x80\xa6\xe2\x80\xa6\',\'\xc2\xb7\',\'\xe3\x80\x81\',\n\t\t\t   \'\xe3\x80\x8c\',\'\xe3\x80\x8d\',\'\xef\xbc\x88\',\'\xef\xbc\x89\',\'\xef\xbc\x8d\',\'\xef\xbd\x9e\',\'\xe3\x80\x8e\',\'\xe3\x80\x8f\']\n\tout_segs = []\n\tfor char in in_str:\n\t\tif char in sp_char:\n\t\t\tcontinue\n\t\telse:\n\t\t\tout_segs.append(char)\n\treturn \'\'.join(out_segs)\n\n\n# find longest common string\ndef find_lcs(s1, s2):\n\tm = [[0 for i in range(len(s2)+1)] for j in range(len(s1)+1)]\n\tmmax = 0\n\tp = 0\n\tfor i in range(len(s1)):\n\t\tfor j in range(len(s2)):\n\t\t\tif s1[i] == s2[j]:\n\t\t\t\tm[i+1][j+1] = m[i][j]+1\n\t\t\t\tif m[i+1][j+1] > mmax:\n\t\t\t\t\tmmax=m[i+1][j+1]\n\t\t\t\t\tp=i+1\n\treturn s1[p-mmax:p], mmax\n\n#\ndef evaluate(ground_truth_file, prediction_file):\n\tf1 = 0\n\tem = 0\n\ttotal_count = 0\n\tskip_count = 0\n\tfor instance in ground_truth_file[""data""]:\n\t\t#context_id   = instance[\'context_id\'].strip()\n\t\t#context_text = instance[\'context_text\'].strip()\n\t\tfor para in instance[""paragraphs""]:\n\t\t\tfor qas in para[\'qas\']:\n\t\t\t\ttotal_count += 1\n\t\t\t\tquery_id    = qas[\'id\'].strip()\n\t\t\t\tquery_text  = qas[\'question\'].strip()\n\t\t\t\tanswers \t= [x[""text""] for x in qas[\'answers\']]\n\n\t\t\t\tif query_id not in prediction_file:\n\t\t\t\t\tsys.stderr.write(\'Unanswered question: {}\\n\'.format(query_id))\n\t\t\t\t\tskip_count += 1\n\t\t\t\t\tcontinue\n\n\t\t\t\tprediction \t= str(prediction_file[query_id]).decode(\'utf-8\')\n\t\t\t\tf1 += calc_f1_score(answers, prediction)\n\t\t\t\tem += calc_em_score(answers, prediction)\n\n\tf1_score = 100.0 * f1 / total_count\n\tem_score = 100.0 * em / total_count\n\treturn f1_score, em_score, total_count, skip_count\n\n\ndef calc_f1_score(answers, prediction):\n\tf1_scores = []\n\tfor ans in answers:\n\t\tans_segs = mixed_segmentation(ans, rm_punc=True)\n\t\tprediction_segs = mixed_segmentation(prediction, rm_punc=True)\n\t\tlcs, lcs_len = find_lcs(ans_segs, prediction_segs)\n\t\tif lcs_len == 0:\n\t\t\tf1_scores.append(0)\n\t\t\tcontinue\n\t\tprecision \t= 1.0*lcs_len/len(prediction_segs)\n\t\trecall \t\t= 1.0*lcs_len/len(ans_segs)\n\t\tf1 \t\t\t= (2*precision*recall)/(precision+recall)\n\t\tf1_scores.append(f1)\n\treturn max(f1_scores)\n\n\ndef calc_em_score(answers, prediction):\n\tem = 0\n\tfor ans in answers:\n\t\tans_ = remove_punctuation(ans)\n\t\tprediction_ = remove_punctuation(prediction)\n\t\tif ans_ == prediction_:\n\t\t\tem = 1\n\t\t\tbreak\n\treturn em\n\nif __name__ == \'__main__\':\n\tparser = argparse.ArgumentParser(description=\'Evaluation Script for CMRC 2018\')\n\tparser.add_argument(\'dataset_file\', help=\'Official dataset file\')\n\tparser.add_argument(\'prediction_file\', help=\'Your prediction File\')\n\targs = parser.parse_args()\n\tground_truth_file   = json.load(open(args.dataset_file, \'rb\'))\n\tprediction_file     = json.load(open(args.prediction_file, \'rb\'))\n\tF1, EM, TOTAL, SKIP = evaluate(ground_truth_file, prediction_file)\n\tAVG = (EM+F1)*0.5\n\toutput_result = OrderedDict()\n\toutput_result[\'AVERAGE\'] = \'%.3f\' % AVG\n\toutput_result[\'F1\'] = \'%.3f\' % F1\n\toutput_result[\'EM\'] = \'%.3f\' % EM\n\toutput_result[\'TOTAL\'] = TOTAL\n\toutput_result[\'SKIP\'] = SKIP\n\toutput_result[\'FILE\'] = args.prediction_file\n\tprint(json.dumps(output_result))\n\n'"
src/data_utils.py,104,"b'# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport json\nimport os\nimport random\n\nfrom absl import flags\nimport absl.logging as _logging  # pylint: disable=unused-import\n\nimport numpy as np\n\n\nimport tensorflow as tf\n\nfrom prepro_utils import preprocess_text, encode_ids\nimport sentencepiece as spm\n\n\nspecial_symbols = {\n    ""<unk>""  : 0,\n    ""<s>""    : 1,\n    ""</s>""   : 2,\n    ""<cls>""  : 3,\n    ""<sep>""  : 4,\n    ""<pad>""  : 5,\n    ""<mask>"" : 6,\n    ""<eod>""  : 7,\n    ""<eop>""  : 8,\n}\n\nVOCAB_SIZE = 32000\nUNK_ID = special_symbols[""<unk>""]\nCLS_ID = special_symbols[""<cls>""]\nSEP_ID = special_symbols[""<sep>""]\nMASK_ID = special_symbols[""<mask>""]\nEOD_ID = special_symbols[""<eod>""]\n\n\ndef _int64_feature(values):\n  return tf.train.Feature(int64_list=tf.train.Int64List(value=values))\n\n\ndef _float_feature(values):\n  return tf.train.Feature(float_list=tf.train.FloatList(value=values))\n\n\ndef format_filename(prefix, bsz_per_host, seq_len, bi_data, suffix,\n                    mask_alpha=5, mask_beta=1, reuse_len=None, uncased=False,\n                    fixed_num_predict=None):\n  """"""docs.""""""\n  if reuse_len is None:\n    reuse_len_str = """"\n  else:\n    reuse_len_str = ""reuse-{}."".format(reuse_len)\n  if not uncased:\n    uncased_str = """"\n  else:\n    uncased_str = ""uncased.""\n  if bi_data:\n    bi_data_str = ""bi""\n  else:\n    bi_data_str = ""uni""\n  if fixed_num_predict is not None:\n    fnp_str = ""fnp-{}."".format(fixed_num_predict)\n  else:\n    fnp_str = """"\n\n  file_name = ""{}.bsz-{}.seqlen-{}.{}{}{}.alpha-{}.beta-{}.{}{}"".format(\n      prefix, bsz_per_host, seq_len, reuse_len_str, uncased_str, bi_data_str,\n      mask_alpha, mask_beta, fnp_str, suffix)\n\n  return file_name\n\n\ndef _create_data(idx, input_paths):\n  # Load sentence-piece model\n  sp = spm.SentencePieceProcessor()\n  sp.Load(FLAGS.sp_path)\n\n  input_shards = []\n  total_line_cnt = 0\n  for input_path in input_paths:\n    input_data, sent_ids = [], []\n    sent_id, line_cnt = True, 0\n    tf.logging.info(""Processing %s"", input_path)\n    for line in tf.gfile.Open(input_path):\n      if line_cnt % 100000 == 0:\n        tf.logging.info(""Loading line %d"", line_cnt)\n      line_cnt += 1\n\n      if not line.strip():\n        if FLAGS.use_eod:\n          sent_id = not sent_id\n          cur_sent = [EOD_ID]\n        else:\n          continue\n      else:\n        if FLAGS.from_raw_text:\n          cur_sent = preprocess_text(line.strip(), lower=FLAGS.uncased)\n          cur_sent = encode_ids(sp, cur_sent)\n        else:\n          cur_sent = list(map(int, line.strip().split()))\n\n      input_data.extend(cur_sent)\n      sent_ids.extend([sent_id] * len(cur_sent))\n      sent_id = not sent_id\n\n    tf.logging.info(""Finish with line %d"", line_cnt)\n    if line_cnt == 0:\n      continue\n\n    input_data = np.array(input_data, dtype=np.int64)\n    sent_ids = np.array(sent_ids, dtype=np.bool)\n\n    total_line_cnt += line_cnt\n    input_shards.append((input_data, sent_ids))\n\n  tf.logging.info(""[Task %d] Total number line: %d"", idx, total_line_cnt)\n\n  tfrecord_dir = os.path.join(FLAGS.save_dir, ""tfrecords"")\n\n  filenames, num_batch = [], 0\n\n  # Randomly shuffle input shards (with a fixed but distinct random seed)\n  np.random.seed(100 * FLAGS.task + FLAGS.pass_id)\n\n  perm_indices = np.random.permutation(len(input_shards))\n  tf.logging.info(""Using perm indices %s for pass %d"",\n                  perm_indices.tolist(), FLAGS.pass_id)\n\n  input_data_list, sent_ids_list = [], []\n  prev_sent_id = None\n  for perm_idx in perm_indices:\n    input_data, sent_ids = input_shards[perm_idx]\n    # make sure the `send_ids[0] == not prev_sent_id`\n    if prev_sent_id is not None and sent_ids[0] == prev_sent_id:\n      sent_ids = np.logical_not(sent_ids)\n\n    # append to temporary list\n    input_data_list.append(input_data)\n    sent_ids_list.append(sent_ids)\n\n    # update `prev_sent_id`\n    prev_sent_id = sent_ids[-1]\n\n  input_data = np.concatenate(input_data_list)\n  sent_ids = np.concatenate(sent_ids_list)\n\n  file_name, cur_num_batch = create_tfrecords(\n      save_dir=tfrecord_dir,\n      basename=""{}-{}-{}"".format(FLAGS.split, idx, FLAGS.pass_id),\n      data=[input_data, sent_ids],\n      bsz_per_host=FLAGS.bsz_per_host,\n      seq_len=FLAGS.seq_len,\n      bi_data=FLAGS.bi_data,\n      sp=sp,\n  )\n\n  filenames.append(file_name)\n  num_batch += cur_num_batch\n\n  record_info = {\n      ""filenames"": filenames,\n      ""num_batch"": num_batch\n  }\n\n  return record_info\n\n\ndef create_data(_):\n  # Validate FLAGS\n  assert FLAGS.bsz_per_host % FLAGS.num_core_per_host == 0\n  if not FLAGS.use_tpu:\n    FLAGS.num_core_per_host = 1  # forced to be one\n\n  # Make workdirs\n  if not tf.gfile.Exists(FLAGS.save_dir):\n    tf.gfile.MakeDirs(FLAGS.save_dir)\n\n  tfrecord_dir = os.path.join(FLAGS.save_dir, ""tfrecords"")\n  if not tf.gfile.Exists(tfrecord_dir):\n    tf.gfile.MakeDirs(tfrecord_dir)\n\n  # Create and dump corpus_info from task 0\n  if FLAGS.task == 0:\n    corpus_info = {\n        ""vocab_size"": VOCAB_SIZE,\n        ""bsz_per_host"": FLAGS.bsz_per_host,\n        ""num_core_per_host"": FLAGS.num_core_per_host,\n        ""seq_len"": FLAGS.seq_len,\n        ""reuse_len"": FLAGS.reuse_len,\n        ""uncased"": FLAGS.uncased,\n        ""bi_data"": FLAGS.bi_data,\n        ""mask_alpha"": FLAGS.mask_alpha,\n        ""mask_beta"": FLAGS.mask_beta,\n        ""num_predict"": FLAGS.num_predict,\n        ""use_eod"": FLAGS.use_eod,\n        ""sp_path"": FLAGS.sp_path,\n        ""input_glob"": FLAGS.input_glob,\n    }\n    corpus_info_path = os.path.join(FLAGS.save_dir, ""corpus_info.json"")\n    with tf.gfile.Open(corpus_info_path, ""w"") as fp:\n      json.dump(corpus_info, fp)\n\n  # Interleavely split the work into FLAGS.num_task splits\n  file_paths = sorted(tf.gfile.Glob(FLAGS.input_glob))\n  tf.logging.info(""Use glob: %s"", FLAGS.input_glob)\n  tf.logging.info(""Find %d files: %s"", len(file_paths), file_paths)\n\n  task_file_paths = file_paths[FLAGS.task::FLAGS.num_task]\n  if not task_file_paths:\n    tf.logging.info(""Exit: task %d has no file to process."", FLAGS.task)\n    return\n\n  tf.logging.info(""Task %d process %d files: %s"",\n                  FLAGS.task, len(task_file_paths), task_file_paths)\n  record_info = _create_data(FLAGS.task, task_file_paths)\n\n  record_prefix = ""record_info-{}-{}-{}"".format(\n      FLAGS.split, FLAGS.task, FLAGS.pass_id)\n  record_name = format_filename(\n      prefix=record_prefix,\n      bsz_per_host=FLAGS.bsz_per_host,\n      seq_len=FLAGS.seq_len,\n      mask_alpha=FLAGS.mask_alpha,\n      mask_beta=FLAGS.mask_beta,\n      reuse_len=FLAGS.reuse_len,\n      bi_data=FLAGS.bi_data,\n      suffix=""json"",\n      uncased=FLAGS.uncased,\n      fixed_num_predict=FLAGS.num_predict)\n  record_info_path = os.path.join(tfrecord_dir, record_name)\n\n  with tf.gfile.Open(record_info_path, ""w"") as fp:\n    json.dump(record_info, fp)\n\n\ndef batchify(data, bsz_per_host, sent_ids=None):\n  num_step = len(data) // bsz_per_host\n  data = data[:bsz_per_host * num_step]\n  data = data.reshape(bsz_per_host, num_step)\n  if sent_ids is not None:\n    sent_ids = sent_ids[:bsz_per_host * num_step]\n    sent_ids = sent_ids.reshape(bsz_per_host, num_step)\n\n  if sent_ids is not None:\n    return data, sent_ids\n  return data\n\n\ndef _split_a_and_b(data, sent_ids, begin_idx, tot_len, extend_target=False):\n  """"""Split two segments from `data` starting from the index `begin_idx`.""""""\n\n  data_len = data.shape[0]\n  if begin_idx + tot_len >= data_len:\n    tf.logging.info(""[_split_a_and_b] returns None: ""\n                    ""begin_idx %d + tot_len %d >= data_len %d"",\n                    begin_idx, tot_len, data_len)\n    return None\n\n  end_idx = begin_idx + 1\n  cut_points = []\n  while end_idx < data_len:\n    if sent_ids[end_idx] != sent_ids[end_idx - 1]:\n      if end_idx - begin_idx >= tot_len: break\n      cut_points.append(end_idx)\n    end_idx += 1\n\n  a_begin = begin_idx\n  if len(cut_points) == 0 or random.random() < 0.5:\n    label = 0\n    if len(cut_points) == 0:\n      a_end = end_idx\n    else:\n      a_end = random.choice(cut_points)\n\n    b_len = max(1, tot_len - (a_end - a_begin))\n    # (zihang): `data_len - 1` to account for extend_target\n    b_begin = random.randint(0, data_len - 1 - b_len)\n    b_end = b_begin + b_len\n    while b_begin > 0 and sent_ids[b_begin - 1] == sent_ids[b_begin]:\n      b_begin -= 1\n    # (zihang): `data_len - 1` to account for extend_target\n    while b_end < data_len - 1 and sent_ids[b_end - 1] == sent_ids[b_end]:\n      b_end += 1\n\n    new_begin = a_end\n  else:\n    label = 1\n    a_end = random.choice(cut_points)\n    b_begin = a_end\n    b_end = end_idx\n\n    new_begin = b_end\n\n  while a_end - a_begin + b_end - b_begin > tot_len:\n    if a_end - a_begin > b_end - b_begin:\n      # delete the right side only for the LM objective\n      a_end -= 1\n    else:\n      b_end -= 1\n\n  ret = [data[a_begin: a_end], data[b_begin: b_end], label, new_begin]\n\n  if extend_target:\n    if a_end >= data_len or b_end >= data_len:\n      tf.logging.info(""[_split_a_and_b] returns None: ""\n                      ""a_end %d or b_end %d >= data_len %d"",\n                      a_end, b_end, data_len)\n      return None\n    a_target = data[a_begin + 1: a_end + 1]\n    b_target = data[b_begin: b_end + 1]\n    ret.extend([a_target, b_target])\n\n  return ret\n\n\ndef _is_start_piece(piece):\n  special_pieces = set(list(\'!""#$%&\\""()*+,-./:;?@[\\\\]^_`{|}~\'))\n  if (piece.startswith(""\xe2\x96\x81"") or piece.startswith(""<"")\n      or piece in special_pieces):\n    return True\n  else:\n    return False\n\n\ndef _sample_mask(sp, seg, reverse=False, max_gram=5, goal_num_predict=None):\n  """"""Sample `goal_num_predict` tokens for partial prediction.\n  About `mask_beta` tokens are chosen in a context of `mask_alpha` tokens.""""""\n\n  seg_len = len(seg)\n  mask = np.array([False] * seg_len, dtype=np.bool)\n\n  num_predict = 0\n\n  ngrams = np.arange(1, max_gram + 1, dtype=np.int64)\n  pvals = 1. / np.arange(1, max_gram + 1)\n  pvals /= pvals.sum(keepdims=True)\n\n  if reverse:\n    seg = np.flip(seg, 0)\n\n  cur_len = 0\n  while cur_len < seg_len:\n    if goal_num_predict is not None and num_predict >= goal_num_predict: break\n\n    n = np.random.choice(ngrams, p=pvals)\n    if goal_num_predict is not None:\n      n = min(n, goal_num_predict - num_predict)\n    ctx_size = (n * FLAGS.mask_alpha) // FLAGS.mask_beta\n    l_ctx = np.random.choice(ctx_size)\n    r_ctx = ctx_size - l_ctx\n\n    # Find the start position of a complete token\n    beg = cur_len + l_ctx\n    while beg < seg_len and not _is_start_piece(sp.IdToPiece(seg[beg].item())):\n      beg += 1\n    if beg >= seg_len:\n      break\n\n    # Find the end position of the n-gram (start pos of the n+1-th gram)\n    end = beg + 1\n    cnt_ngram = 1\n    while end < seg_len:\n      if _is_start_piece(sp.IdToPiece(seg[beg].item())):\n        cnt_ngram += 1\n        if cnt_ngram > n:\n          break\n      end += 1\n    if end >= seg_len:\n      break\n\n    # Update\n    mask[beg:end] = True\n    num_predict += end - beg\n\n    cur_len = end + r_ctx\n\n  while goal_num_predict is not None and num_predict < goal_num_predict:\n    i = np.random.randint(seg_len)\n    if not mask[i]:\n      mask[i] = True\n      num_predict += 1\n\n  if reverse:\n    mask = np.flip(mask, 0)\n\n  return mask\n\n\ndef create_tfrecords(save_dir, basename, data, bsz_per_host, seq_len,\n                     bi_data, sp):\n  data, sent_ids = data[0], data[1]\n\n  num_core = FLAGS.num_core_per_host\n  bsz_per_core = bsz_per_host // num_core\n\n  if bi_data:\n    assert bsz_per_host % (2 * FLAGS.num_core_per_host) == 0\n    fwd_data, fwd_sent_ids = batchify(data, bsz_per_host // 2, sent_ids)\n\n    fwd_data = fwd_data.reshape(num_core, 1, bsz_per_core // 2, -1)\n    fwd_sent_ids = fwd_sent_ids.reshape(num_core, 1, bsz_per_core // 2, -1)\n\n    bwd_data = fwd_data[:, :, :, ::-1]\n    bwd_sent_ids = fwd_sent_ids[:, :, :, ::-1]\n\n    data = np.concatenate(\n        [fwd_data, bwd_data], 1).reshape(bsz_per_host, -1)\n    sent_ids = np.concatenate(\n        [fwd_sent_ids, bwd_sent_ids], 1).reshape(bsz_per_host, -1)\n  else:\n    data, sent_ids = batchify(data, bsz_per_host, sent_ids)\n\n  tf.logging.info(""Raw data shape %s."", data.shape)\n\n  file_name = format_filename(\n      prefix=basename,\n      bsz_per_host=bsz_per_host,\n      seq_len=seq_len,\n      bi_data=bi_data,\n      suffix=""tfrecords"",\n      mask_alpha=FLAGS.mask_alpha,\n      mask_beta=FLAGS.mask_beta,\n      reuse_len=FLAGS.reuse_len,\n      uncased=FLAGS.uncased,\n      fixed_num_predict=FLAGS.num_predict\n  )\n  save_path = os.path.join(save_dir, file_name)\n  record_writer = tf.python_io.TFRecordWriter(save_path)\n  tf.logging.info(""Start writing %s."", save_path)\n\n  num_batch = 0\n  reuse_len = FLAGS.reuse_len\n\n  # [sep] x 2 + [cls]\n  assert reuse_len < seq_len - 3\n\n  data_len = data.shape[1]\n  sep_array = np.array([SEP_ID], dtype=np.int64)\n  cls_array = np.array([CLS_ID], dtype=np.int64)\n\n  i = 0\n  while i + seq_len <= data_len:\n    if num_batch % 500 == 0:\n      tf.logging.info(""Processing batch %d"", num_batch)\n\n    all_ok = True\n    features = []\n    for idx in range(bsz_per_host):\n      inp = data[idx, i: i + reuse_len]\n      tgt = data[idx, i + 1: i + reuse_len + 1]\n\n      results = _split_a_and_b(\n          data[idx],\n          sent_ids[idx],\n          begin_idx=i + reuse_len,\n          tot_len=seq_len - reuse_len - 3,\n          extend_target=True)\n      if results is None:\n        tf.logging.info(""Break out with seq idx %d"", i)\n        all_ok = False\n        break\n\n      # unpack the results\n      (a_data, b_data, label, _, a_target, b_target) = tuple(results)\n\n      # sample ngram spans to predict\n      reverse = bi_data and (idx // (bsz_per_core // 2)) % 2 == 1\n      if FLAGS.num_predict is None:\n        num_predict_0 = num_predict_1 = None\n      else:\n        num_predict_1 = FLAGS.num_predict // 2\n        num_predict_0 = FLAGS.num_predict - num_predict_1\n      mask_0 = _sample_mask(sp, inp, reverse=reverse,\n                            goal_num_predict=num_predict_0)\n      mask_1 = _sample_mask(sp, np.concatenate([a_data, sep_array, b_data,\n                                                sep_array, cls_array]),\n                            reverse=reverse, goal_num_predict=num_predict_1)\n\n      # concatenate data\n      cat_data = np.concatenate([inp, a_data, sep_array, b_data,\n                                 sep_array, cls_array])\n      seg_id = ([0] * (reuse_len + a_data.shape[0]) + [0] +\n                [1] * b_data.shape[0] + [1] + [2])\n      assert cat_data.shape[0] == seq_len\n      assert mask_0.shape[0] == seq_len // 2\n      assert mask_1.shape[0] == seq_len // 2\n\n      # the last two CLS\'s are not used, just for padding purposes\n      tgt = np.concatenate([tgt, a_target, b_target, cls_array, cls_array])\n      assert tgt.shape[0] == seq_len\n\n      is_masked = np.concatenate([mask_0, mask_1], 0)\n      if FLAGS.num_predict is not None:\n        assert np.sum(is_masked) == FLAGS.num_predict\n\n      feature = {\n          ""input"": _int64_feature(cat_data),\n          ""is_masked"": _int64_feature(is_masked),\n          ""target"": _int64_feature(tgt),\n          ""seg_id"": _int64_feature(seg_id),\n          ""label"": _int64_feature([label]),\n      }\n      features.append(feature)\n\n    if all_ok:\n      assert len(features) == bsz_per_host\n      for feature in features:\n        example = tf.train.Example(features=tf.train.Features(feature=feature))\n        record_writer.write(example.SerializeToString())\n      num_batch += 1\n    else:\n      break\n\n    i += reuse_len\n\n  record_writer.close()\n  tf.logging.info(""Done writing %s. Num of batches: %d"", save_path, num_batch)\n\n  return save_path, num_batch\n\n\n################\n# get_input_fn #\n################\ndef _convert_example(example, use_bfloat16):\n  """"""Cast int64 into int32 and float32 to bfloat16 if use_bfloat16.""""""\n  for key in list(example.keys()):\n    val = example[key]\n    if tf.keras.backend.is_sparse(val):\n      val = tf.sparse.to_dense(val)\n    if val.dtype == tf.int64:\n      val = tf.cast(val, tf.int32)\n    if use_bfloat16 and val.dtype == tf.float32:\n      val = tf.cast(val, tf.bfloat16)\n\n    example[key] = val\n\n\ndef parse_files_to_dataset(parser, file_names, split, num_batch, num_hosts,\n                           host_id, num_core_per_host, bsz_per_core):\n  # list of file pathes\n  num_files = len(file_names)\n  num_files_per_host = num_files // num_hosts\n  my_start_file_id = host_id * num_files_per_host\n  my_end_file_id = (host_id + 1) * num_files_per_host\n  if host_id == num_hosts - 1:\n    my_end_file_id = num_files\n  file_paths = file_names[my_start_file_id: my_end_file_id]\n  tf.logging.info(""Host %d handles %d files"", host_id, len(file_paths))\n\n  assert split == ""train""\n  dataset = tf.data.Dataset.from_tensor_slices(file_paths)\n\n  # file-level shuffle\n  if len(file_paths) > 1:\n    dataset = dataset.shuffle(len(file_paths))\n\n  # Note: we cannot perform sample-level shuffle here because this will violate\n  # the consecutive requirement of data stream.\n  dataset = tf.data.TFRecordDataset(dataset)\n\n  # (zihang): since we are doing online preprocessing, the parsed result of\n  # the same input at each time will be different. Thus, cache processed data\n  # is not helpful. It will use a lot of memory and lead to contrainer OOM.\n  # So, change to cache non-parsed raw data instead.\n  dataset = dataset.cache().map(parser).repeat()\n  dataset = dataset.batch(bsz_per_core, drop_remainder=True)\n  dataset = dataset.prefetch(num_core_per_host * bsz_per_core)\n\n  return dataset\n\n\ndef _local_perm(inputs, targets, is_masked, perm_size, seq_len):\n  """"""\n  Sample a permutation of the factorization order, and create an\n  attention mask accordingly.\n\n  Args:\n    inputs: int64 Tensor in shape [seq_len], input ids.\n    targets: int64 Tensor in shape [seq_len], target ids.\n    is_masked: bool Tensor in shape [seq_len]. True means being selected\n      for partial prediction.\n    perm_size: the length of longest permutation. Could be set to be reuse_len.\n      Should not be larger than reuse_len or there will be data leaks.\n    seq_len: int, sequence length.\n  """"""\n\n  # Generate permutation indices\n  index = tf.range(seq_len, dtype=tf.int64)\n  index = tf.transpose(tf.reshape(index, [-1, perm_size]))\n  index = tf.random_shuffle(index)\n  index = tf.reshape(tf.transpose(index), [-1])\n\n  # `perm_mask` and `target_mask`\n  # non-functional tokens\n  non_func_tokens = tf.logical_not(tf.logical_or(\n      tf.equal(inputs, SEP_ID),\n      tf.equal(inputs, CLS_ID)))\n\n  non_mask_tokens = tf.logical_and(tf.logical_not(is_masked), non_func_tokens)\n  masked_or_func_tokens = tf.logical_not(non_mask_tokens)\n\n  # Set the permutation indices of non-masked (& non-funcional) tokens to the\n  # smallest index (-1):\n  # (1) they can be seen by all other positions\n  # (2) they cannot see masked positions, so there won""t be information leak\n  smallest_index = -tf.ones([seq_len], dtype=tf.int64)\n  rev_index = tf.where(non_mask_tokens, smallest_index, index)\n\n  # Create `target_mask`: non-funcional and maksed tokens\n  # 1: use mask as input and have loss\n  # 0: use token (or [SEP], [CLS]) as input and do not have loss\n  target_tokens = tf.logical_and(masked_or_func_tokens, non_func_tokens)\n  target_mask = tf.cast(target_tokens, tf.float32)\n\n  # Create `perm_mask`\n  # `target_tokens` cannot see themselves\n  self_rev_index = tf.where(target_tokens, rev_index, rev_index + 1)\n\n  # 1: cannot attend if i <= j and j is not non-masked (masked_or_func_tokens)\n  # 0: can attend if i > j or j is non-masked\n  perm_mask = tf.logical_and(\n      self_rev_index[:, None] <= rev_index[None, :],\n      masked_or_func_tokens)\n  perm_mask = tf.cast(perm_mask, tf.float32)\n\n  # new target: [next token] for LM and [curr token] (self) for PLM\n  new_targets = tf.concat([inputs[0: 1], targets[: -1]],\n                          axis=0)\n\n  # construct inputs_k\n  inputs_k = inputs\n\n  # construct inputs_q\n  inputs_q = target_mask\n\n  return perm_mask, new_targets, target_mask, inputs_k, inputs_q\n\n\ndef get_dataset(params, num_hosts, num_core_per_host, split, file_names,\n                num_batch, seq_len, reuse_len, perm_size, mask_alpha,\n                mask_beta, use_bfloat16=False, num_predict=None):\n\n  bsz_per_core = params[""batch_size""]\n  if num_hosts > 1:\n    host_id = params[""context""].current_host\n  else:\n    host_id = 0\n\n    #### Function used to parse tfrecord\n  def parser(record):\n    """"""function used to parse tfrecord.""""""\n\n    record_spec = {\n        ""input"": tf.FixedLenFeature([seq_len], tf.int64),\n        ""target"": tf.FixedLenFeature([seq_len], tf.int64),\n        ""seg_id"": tf.FixedLenFeature([seq_len], tf.int64),\n        ""label"": tf.FixedLenFeature([1], tf.int64),\n        ""is_masked"": tf.FixedLenFeature([seq_len], tf.int64),\n    }\n\n    # retrieve serialized example\n    example = tf.parse_single_example(\n        serialized=record,\n        features=record_spec)\n\n    inputs = example.pop(""input"")\n    target = example.pop(""target"")\n    is_masked = tf.cast(example.pop(""is_masked""), tf.bool)\n\n    non_reuse_len = seq_len - reuse_len\n    assert perm_size <= reuse_len and perm_size <= non_reuse_len\n\n    perm_mask_0, target_0, target_mask_0, input_k_0, input_q_0 = _local_perm(\n        inputs[:reuse_len],\n        target[:reuse_len],\n        is_masked[:reuse_len],\n        perm_size,\n        reuse_len)\n\n    perm_mask_1, target_1, target_mask_1, input_k_1, input_q_1 = _local_perm(\n        inputs[reuse_len:],\n        target[reuse_len:],\n        is_masked[reuse_len:],\n        perm_size,\n        non_reuse_len)\n\n    perm_mask_0 = tf.concat([perm_mask_0, tf.ones([reuse_len, non_reuse_len])],\n                            axis=1)\n    perm_mask_1 = tf.concat([tf.zeros([non_reuse_len, reuse_len]), perm_mask_1],\n                            axis=1)\n    perm_mask = tf.concat([perm_mask_0, perm_mask_1], axis=0)\n    target = tf.concat([target_0, target_1], axis=0)\n    target_mask = tf.concat([target_mask_0, target_mask_1], axis=0)\n    input_k = tf.concat([input_k_0, input_k_1], axis=0)\n    input_q = tf.concat([input_q_0, input_q_1], axis=0)\n\n    if num_predict is not None:\n      indices = tf.range(seq_len, dtype=tf.int64)\n      bool_target_mask = tf.cast(target_mask, tf.bool)\n      indices = tf.boolean_mask(indices, bool_target_mask)\n\n      ##### extra padding due to CLS/SEP introduced after prepro\n      actual_num_predict = tf.shape(indices)[0]\n      pad_len = num_predict - actual_num_predict\n\n      ##### target_mapping\n      target_mapping = tf.one_hot(indices, seq_len, dtype=tf.float32)\n      paddings = tf.zeros([pad_len, seq_len], dtype=target_mapping.dtype)\n      target_mapping = tf.concat([target_mapping, paddings], axis=0)\n      example[""target_mapping""] = tf.reshape(target_mapping,\n                                             [num_predict, seq_len])\n\n      ##### target\n      target = tf.boolean_mask(target, bool_target_mask)\n      paddings = tf.zeros([pad_len], dtype=target.dtype)\n      target = tf.concat([target, paddings], axis=0)\n      example[""target""] = tf.reshape(target, [num_predict])\n\n      ##### target mask\n      target_mask = tf.concat(\n          [tf.ones([actual_num_predict], dtype=tf.float32),\n           tf.zeros([pad_len], dtype=tf.float32)],\n          axis=0)\n      example[""target_mask""] = tf.reshape(target_mask, [num_predict])\n    else:\n      example[""target""] = tf.reshape(target, [seq_len])\n      example[""target_mask""] = tf.reshape(target_mask, [seq_len])\n\n    # reshape back to fixed shape\n    example[""perm_mask""] = tf.reshape(perm_mask, [seq_len, seq_len])\n    example[""input_k""] = tf.reshape(input_k, [seq_len])\n    example[""input_q""] = tf.reshape(input_q, [seq_len])\n\n    _convert_example(example, use_bfloat16)\n\n    for k, v in example.items():\n      tf.logging.info(""%s: %s"", k, v)\n\n    return example\n\n  # Get dataset\n  dataset = parse_files_to_dataset(\n      parser=parser,\n      file_names=file_names,\n      split=split,\n      num_batch=num_batch,\n      num_hosts=num_hosts,\n      host_id=host_id,\n      num_core_per_host=num_core_per_host,\n      bsz_per_core=bsz_per_core)\n\n  return dataset\n\n\ndef get_input_fn(\n    tfrecord_dir,\n    split,\n    bsz_per_host,\n    seq_len,\n    reuse_len,\n    bi_data,\n    num_hosts=1,\n    num_core_per_host=1,\n    perm_size=None,\n    mask_alpha=None,\n    mask_beta=None,\n    uncased=False,\n    num_passes=None,\n    use_bfloat16=False,\n    num_predict=None):\n\n  # Merge all record infos into a single one\n  record_glob_base = format_filename(\n      prefix=""record_info-{}-*"".format(split),\n      bsz_per_host=bsz_per_host,\n      seq_len=seq_len,\n      bi_data=bi_data,\n      suffix=""json"",\n      mask_alpha=mask_alpha,\n      mask_beta=mask_beta,\n      reuse_len=reuse_len,\n      uncased=uncased,\n      fixed_num_predict=num_predict)\n\n  record_info = {""num_batch"": 0, ""filenames"": []}\n\n  tfrecord_dirs = tfrecord_dir.split("","")\n  tf.logging.info(""Use the following tfrecord dirs: %s"", tfrecord_dirs)\n\n  for idx, record_dir in enumerate(tfrecord_dirs):\n    record_glob = os.path.join(record_dir, record_glob_base)\n    tf.logging.info(""[%d] Record glob: %s"", idx, record_glob)\n\n    record_paths = sorted(tf.gfile.Glob(record_glob))\n    tf.logging.info(""[%d] Num of record info path: %d"",\n                    idx, len(record_paths))\n\n    cur_record_info = {""num_batch"": 0, ""filenames"": []}\n\n    for record_info_path in record_paths:\n      if num_passes is not None:\n        record_info_name = os.path.basename(record_info_path)\n        fields = record_info_name.split(""."")[0].split(""-"")\n        pass_id = int(fields[-1])\n        if len(fields) == 5 and pass_id >= num_passes:\n          tf.logging.info(""Skip pass %d: %s"", pass_id, record_info_name)\n          continue\n\n      with tf.gfile.Open(record_info_path, ""r"") as fp:\n        info = json.load(fp)\n        if num_passes is not None:\n          eff_num_passes = min(num_passes, len(info[""filenames""]))\n          ratio = eff_num_passes / len(info[""filenames""])\n          cur_record_info[""num_batch""] += int(info[""num_batch""] * ratio)\n          cur_record_info[""filenames""] += info[""filenames""][:eff_num_passes]\n        else:\n          cur_record_info[""num_batch""] += info[""num_batch""]\n          cur_record_info[""filenames""] += info[""filenames""]\n\n    # overwrite directory for `cur_record_info`\n    new_filenames = []\n    for filename in cur_record_info[""filenames""]:\n      basename = os.path.basename(filename)\n      new_filename = os.path.join(record_dir, basename)\n      new_filenames.append(new_filename)\n    cur_record_info[""filenames""] = new_filenames\n\n    tf.logging.info(""[Dir %d] Number of chosen batches: %s"",\n                    idx, cur_record_info[""num_batch""])\n    tf.logging.info(""[Dir %d] Number of chosen files: %s"",\n                    idx, len(cur_record_info[""filenames""]))\n    tf.logging.info(cur_record_info[""filenames""])\n\n    # add `cur_record_info` to global `record_info`\n    record_info[""num_batch""] += cur_record_info[""num_batch""]\n    record_info[""filenames""] += cur_record_info[""filenames""]\n\n  tf.logging.info(""Total number of batches: %d"",\n                  record_info[""num_batch""])\n  tf.logging.info(""Total number of files: %d"",\n                  len(record_info[""filenames""]))\n  tf.logging.info(record_info[""filenames""])\n\n  def input_fn(params):\n    """"""docs.""""""\n    assert params[""batch_size""] * num_core_per_host == bsz_per_host\n\n    dataset = get_dataset(\n        params=params,\n        num_hosts=num_hosts,\n        num_core_per_host=num_core_per_host,\n        split=split,\n        file_names=record_info[""filenames""],\n        num_batch=record_info[""num_batch""],\n        seq_len=seq_len,\n        reuse_len=reuse_len,\n        perm_size=perm_size,\n        mask_alpha=mask_alpha,\n        mask_beta=mask_beta,\n        use_bfloat16=use_bfloat16,\n        num_predict=num_predict)\n\n    return dataset\n\n  return input_fn, record_info\n\n\nif __name__ == ""__main__"":\n  FLAGS = flags.FLAGS\n  flags.DEFINE_bool(""use_tpu"", True, help=""whether to use TPUs"")\n  flags.DEFINE_integer(""bsz_per_host"", 32, help=""batch size per host."")\n  flags.DEFINE_integer(""num_core_per_host"", 8, help=""num TPU cores per host."")\n\n  flags.DEFINE_integer(""seq_len"", 512,\n                       help=""Sequence length."")\n  flags.DEFINE_integer(""reuse_len"", 256,\n                       help=""Number of token that can be reused as memory. ""\n                       ""Could be half of `seq_len`."")\n  flags.DEFINE_bool(""uncased"", True, help=""Use uncased inputs or not."")\n  flags.DEFINE_bool(""bi_data"", True,\n                    help=""whether to create bidirectional data"")\n  flags.DEFINE_integer(""mask_alpha"", default=6,\n                       help=""How many tokens to form a group."")\n  flags.DEFINE_integer(""mask_beta"", default=1,\n                       help=""How many tokens to mask within each group."")\n  flags.DEFINE_bool(""use_eod"", True,\n                    help=""whether to append EOD at the end of a doc."")\n  flags.DEFINE_bool(""from_raw_text"", True,\n                    help=""Whether the input is raw text or encoded ids."")\n  flags.DEFINE_integer(""num_predict"", default=85,\n                       help=""Num of tokens to predict."")\n\n  flags.DEFINE_string(""input_glob"", ""data/example/*.txt"",\n                      help=""Input file glob."")\n  flags.DEFINE_string(""sp_path"", """", help=""Path to the sentence piece model."")\n  flags.DEFINE_string(""save_dir"", ""proc_data/example"",\n                      help=""Directory for saving the processed data."")\n  flags.DEFINE_enum(""split"", ""train"", [""train"", ""dev"", ""test""],\n                    help=""Save the data as which split."")\n\n  flags.DEFINE_integer(""pass_id"", 0, help=""ID of the current pass.""\n                       ""Different passes sample different negative segment."")\n  flags.DEFINE_integer(""num_task"", 1, help=""Number of total tasks."")\n  flags.DEFINE_integer(""task"", 0, help=""The Task ID. This value is used when ""\n                       ""using multiple workers to identify each worker."")\n\n  tf.logging.set_verbosity(tf.logging.INFO)\n  tf.app.run(create_data)\n'"
src/function_builder.py,83,"b'""""""doc.""""""\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport functools\nimport os\nimport tensorflow as tf\nimport modeling\nimport xlnet\n\n\ndef construct_scalar_host_call(\n    monitor_dict,\n    model_dir,\n    prefix="""",\n    reduce_fn=None):\n  """"""\n  Construct host calls to monitor training progress on TPUs.\n  """"""\n\n  metric_names = list(monitor_dict.keys())\n\n  def host_call_fn(global_step, *args):\n    """"""actual host call function.""""""\n    step = global_step[0]\n    with tf.contrib.summary.create_file_writer(\n        logdir=model_dir, filename_suffix="".host_call"").as_default():\n      with tf.contrib.summary.always_record_summaries():\n        for i, name in enumerate(metric_names):\n          if reduce_fn is None:\n            scalar = args[i][0]\n          else:\n            scalar = reduce_fn(args[i])\n          with tf.contrib.summary.record_summaries_every_n_global_steps(\n              100, global_step=step):\n            tf.contrib.summary.scalar(prefix + name, scalar, step=step)\n\n        return tf.contrib.summary.all_summary_ops()\n\n  global_step_tensor = tf.reshape(tf.train.get_or_create_global_step(), [1])\n  other_tensors = [tf.reshape(monitor_dict[key], [1]) for key in metric_names]\n\n  return host_call_fn, [global_step_tensor] + other_tensors\n\n\ndef two_stream_loss(FLAGS, features, labels, mems, is_training):\n  """"""Pretraining loss with two-stream attention Transformer-XL.""""""\n\n  #### Unpack input\n  mem_name = ""mems""\n  mems = mems.get(mem_name, None)\n\n  inp_k = tf.transpose(features[""input_k""], [1, 0])\n  inp_q = tf.transpose(features[""input_q""], [1, 0])\n\n  seg_id = tf.transpose(features[""seg_id""], [1, 0])\n\n  inp_mask = None\n  perm_mask = tf.transpose(features[""perm_mask""], [1, 2, 0])\n\n  if FLAGS.num_predict is not None:\n    # [num_predict x tgt_len x bsz]\n    target_mapping = tf.transpose(features[""target_mapping""], [1, 2, 0])\n  else:\n    target_mapping = None\n\n  # target for LM loss\n  tgt = tf.transpose(features[""target""], [1, 0])\n\n  # target mask for LM loss\n  tgt_mask = tf.transpose(features[""target_mask""], [1, 0])\n\n  # construct xlnet config and save to model_dir\n  xlnet_config = xlnet.XLNetConfig(FLAGS=FLAGS)\n  xlnet_config.to_json(os.path.join(FLAGS.model_dir, ""config.json""))\n\n  # construct run config from FLAGS\n  run_config = xlnet.create_run_config(is_training, False, FLAGS)\n\n  xlnet_model = xlnet.XLNetModel(\n      xlnet_config=xlnet_config,\n      run_config=run_config,\n      input_ids=inp_k,\n      seg_ids=seg_id,\n      input_mask=inp_mask,\n      mems=mems,\n      perm_mask=perm_mask,\n      target_mapping=target_mapping,\n      inp_q=inp_q)\n\n  output = xlnet_model.get_sequence_output()\n  new_mems = {mem_name: xlnet_model.get_new_memory()}\n  lookup_table = xlnet_model.get_embedding_table()\n\n  initializer = xlnet_model.get_initializer()\n\n  with tf.variable_scope(""model"", reuse=tf.AUTO_REUSE):\n    # LM loss\n    lm_loss = modeling.lm_loss(\n        hidden=output,\n        target=tgt,\n        n_token=xlnet_config.n_token,\n        d_model=xlnet_config.d_model,\n        initializer=initializer,\n        lookup_table=lookup_table,\n        tie_weight=True,\n        bi_data=run_config.bi_data,\n        use_tpu=run_config.use_tpu)\n\n  #### Quantity to monitor\n  monitor_dict = {}\n\n  if FLAGS.use_bfloat16:\n    tgt_mask = tf.cast(tgt_mask, tf.float32)\n    lm_loss = tf.cast(lm_loss, tf.float32)\n\n  total_loss = tf.reduce_sum(lm_loss * tgt_mask) / tf.reduce_sum(tgt_mask)\n  monitor_dict[""total_loss""] = total_loss\n\n  return total_loss, new_mems, monitor_dict\n\n\ndef get_loss(FLAGS, features, labels, mems, is_training):\n  """"""Pretraining loss with two-stream attention Transformer-XL.""""""\n  if FLAGS.use_bfloat16:\n    with tf.tpu.bfloat16_scope():\n      return two_stream_loss(FLAGS, features, labels, mems, is_training)\n  else:\n    return two_stream_loss(FLAGS, features, labels, mems, is_training)\n\n\ndef get_classification_loss(\n    FLAGS, features, n_class, is_training):\n  """"""Loss for downstream classification tasks.""""""\n\n  bsz_per_core = tf.shape(features[""input_ids""])[0]\n\n  inp = tf.transpose(features[""input_ids""], [1, 0])\n  seg_id = tf.transpose(features[""segment_ids""], [1, 0])\n  inp_mask = tf.transpose(features[""input_mask""], [1, 0])\n  label = tf.reshape(features[""label_ids""], [bsz_per_core])\n\n  xlnet_config = xlnet.XLNetConfig(json_path=FLAGS.model_config_path)\n  run_config = xlnet.create_run_config(is_training, True, FLAGS)\n\n  xlnet_model = xlnet.XLNetModel(\n      xlnet_config=xlnet_config,\n      run_config=run_config,\n      input_ids=inp,\n      seg_ids=seg_id,\n      input_mask=inp_mask)\n\n  summary = xlnet_model.get_pooled_out(FLAGS.summary_type, FLAGS.use_summ_proj)\n\n  with tf.variable_scope(""model"", reuse=tf.AUTO_REUSE):\n\n    if FLAGS.cls_scope is not None and FLAGS.cls_scope:\n      cls_scope = ""classification_{}"".format(FLAGS.cls_scope)\n    else:\n      cls_scope = ""classification_{}"".format(FLAGS.task_name.lower())\n\n    per_example_loss, logits = modeling.classification_loss(\n        hidden=summary,\n        labels=label,\n        n_class=n_class,\n        initializer=xlnet_model.get_initializer(),\n        scope=cls_scope,\n        return_logits=True)\n\n    total_loss = tf.reduce_mean(per_example_loss)\n\n    return total_loss, per_example_loss, logits\n\n\ndef get_regression_loss(\n    FLAGS, features, is_training):\n  """"""Loss for downstream regression tasks.""""""\n\n  bsz_per_core = tf.shape(features[""input_ids""])[0]\n\n  inp = tf.transpose(features[""input_ids""], [1, 0])\n  seg_id = tf.transpose(features[""segment_ids""], [1, 0])\n  inp_mask = tf.transpose(features[""input_mask""], [1, 0])\n  label = tf.reshape(features[""label_ids""], [bsz_per_core])\n\n  xlnet_config = xlnet.XLNetConfig(json_path=FLAGS.model_config_path)\n  run_config = xlnet.create_run_config(is_training, True, FLAGS)\n\n  xlnet_model = xlnet.XLNetModel(\n      xlnet_config=xlnet_config,\n      run_config=run_config,\n      input_ids=inp,\n      seg_ids=seg_id,\n      input_mask=inp_mask)\n\n  summary = xlnet_model.get_pooled_out(FLAGS.summary_type, FLAGS.use_summ_proj)\n\n  with tf.variable_scope(""model"", reuse=tf.AUTO_REUSE):\n    per_example_loss, logits = modeling.regression_loss(\n        hidden=summary,\n        labels=label,\n        initializer=xlnet_model.get_initializer(),\n        scope=""regression_{}"".format(FLAGS.task_name.lower()),\n        return_logits=True)\n\n    total_loss = tf.reduce_mean(per_example_loss)\n\n    return total_loss, per_example_loss, logits\n\n\ndef get_qa_outputs(FLAGS, features, is_training):\n  """"""Loss for downstream span-extraction QA tasks such as SQuAD.""""""\n\n  inp = tf.transpose(features[""input_ids""], [1, 0])\n  seg_id = tf.transpose(features[""segment_ids""], [1, 0])\n  inp_mask = tf.transpose(features[""input_mask""], [1, 0])\n\n  seq_len = tf.shape(inp)[0]\n\n  xlnet_config = xlnet.XLNetConfig(json_path=FLAGS.model_config_path)\n  run_config = xlnet.create_run_config(is_training, True, FLAGS)\n\n  xlnet_model = xlnet.XLNetModel(\n      xlnet_config=xlnet_config,\n      run_config=run_config,\n      input_ids=inp,\n      seg_ids=seg_id,\n      input_mask=inp_mask)\n  output = xlnet_model.get_sequence_output()\n  initializer = xlnet_model.get_initializer()\n\n  return_dict = {}\n\n  # invalid position mask such as query and special symbols (PAD, SEP, CLS)\n  p_mask = features[""p_mask""]\n\n  # logit of the start position\n  with tf.variable_scope(""start_logits""):\n    start_logits = tf.layers.dense(\n        output,\n        1,\n        kernel_initializer=initializer)\n    start_logits = tf.transpose(tf.squeeze(start_logits, -1), [1, 0])\n    start_logits_masked = start_logits * (1 - p_mask) - 1e30 * p_mask\n    start_log_probs = tf.nn.log_softmax(start_logits_masked, -1)\n\n  # logit of the end position\n  with tf.variable_scope(""end_logits""):\n    if is_training:\n      # during training, compute the end logits based on the\n      # ground truth of the start position\n\n      start_positions = tf.reshape(features[""start_positions""], [-1])\n      start_index = tf.one_hot(start_positions, depth=seq_len, axis=-1,\n                               dtype=tf.float32)\n      start_features = tf.einsum(""lbh,bl->bh"", output, start_index)\n      start_features = tf.tile(start_features[None], [seq_len, 1, 1])\n      end_logits = tf.layers.dense(\n          tf.concat([output, start_features], axis=-1), xlnet_config.d_model,\n          kernel_initializer=initializer, activation=tf.tanh, name=""dense_0"")\n      end_logits = tf.contrib.layers.layer_norm(\n          end_logits, begin_norm_axis=-1)\n\n      end_logits = tf.layers.dense(\n          end_logits, 1,\n          kernel_initializer=initializer,\n          name=""dense_1"")\n      end_logits = tf.transpose(tf.squeeze(end_logits, -1), [1, 0])\n      end_logits_masked = end_logits * (1 - p_mask) - 1e30 * p_mask\n      end_log_probs = tf.nn.log_softmax(end_logits_masked, -1)\n    else:\n      # during inference, compute the end logits based on beam search\n\n      start_top_log_probs, start_top_index = tf.nn.top_k(\n          start_log_probs, k=FLAGS.start_n_top)\n      start_index = tf.one_hot(start_top_index,\n                               depth=seq_len, axis=-1, dtype=tf.float32)\n      start_features = tf.einsum(""lbh,bkl->bkh"", output, start_index)\n      end_input = tf.tile(output[:, :, None],\n                          [1, 1, FLAGS.start_n_top, 1])\n      start_features = tf.tile(start_features[None],\n                               [seq_len, 1, 1, 1])\n      end_input = tf.concat([end_input, start_features], axis=-1)\n      end_logits = tf.layers.dense(\n          end_input,\n          xlnet_config.d_model,\n          kernel_initializer=initializer,\n          activation=tf.tanh,\n          name=""dense_0"")\n      end_logits = tf.contrib.layers.layer_norm(end_logits,\n                                                begin_norm_axis=-1)\n      end_logits = tf.layers.dense(\n          end_logits,\n          1,\n          kernel_initializer=initializer,\n          name=""dense_1"")\n      end_logits = tf.reshape(end_logits, [seq_len, -1, FLAGS.start_n_top])\n      end_logits = tf.transpose(end_logits, [1, 2, 0])\n      end_logits_masked = end_logits * (\n          1 - p_mask[:, None]) - 1e30 * p_mask[:, None]\n      end_log_probs = tf.nn.log_softmax(end_logits_masked, -1)\n      end_top_log_probs, end_top_index = tf.nn.top_k(\n          end_log_probs, k=FLAGS.end_n_top)\n      end_top_log_probs = tf.reshape(\n          end_top_log_probs,\n          [-1, FLAGS.start_n_top * FLAGS.end_n_top])\n      end_top_index = tf.reshape(\n          end_top_index,\n          [-1, FLAGS.start_n_top * FLAGS.end_n_top])\n\n  if is_training:\n    return_dict[""start_log_probs""] = start_log_probs\n    return_dict[""end_log_probs""] = end_log_probs\n  else:\n    return_dict[""start_top_log_probs""] = start_top_log_probs\n    return_dict[""start_top_index""] = start_top_index\n    return_dict[""end_top_log_probs""] = end_top_log_probs\n    return_dict[""end_top_index""] = end_top_index\n\n  return return_dict\n\n\ndef get_race_loss(FLAGS, features, is_training):\n  """"""Loss for downstream multi-choice QA tasks such as RACE.""""""\n\n  bsz_per_core = tf.shape(features[""input_ids""])[0]\n\n  def _transform_features(feature):\n    out = tf.reshape(feature, [bsz_per_core, 4, -1])\n    out = tf.transpose(out, [2, 0, 1])\n    out = tf.reshape(out, [-1, bsz_per_core * 4])\n    return out\n\n  inp = _transform_features(features[""input_ids""])\n  seg_id = _transform_features(features[""segment_ids""])\n  inp_mask = _transform_features(features[""input_mask""])\n  label = tf.reshape(features[""label_ids""], [bsz_per_core])\n\n  xlnet_config = xlnet.XLNetConfig(json_path=FLAGS.model_config_path)\n  run_config = xlnet.create_run_config(is_training, True, FLAGS)\n\n  xlnet_model = xlnet.XLNetModel(\n      xlnet_config=xlnet_config,\n      run_config=run_config,\n      input_ids=inp,\n      seg_ids=seg_id,\n      input_mask=inp_mask)\n  summary = xlnet_model.get_pooled_out(FLAGS.summary_type, FLAGS.use_summ_proj)\n\n  with tf.variable_scope(""logits""):\n    logits = tf.layers.dense(summary, 1,\n        kernel_initializer=xlnet_model.get_initializer())\n    logits = tf.reshape(logits, [bsz_per_core, 4])\n\n    one_hot_target = tf.one_hot(label, 4)\n    per_example_loss = -tf.reduce_sum(\n        tf.nn.log_softmax(logits) * one_hot_target, -1)\n    total_loss = tf.reduce_mean(per_example_loss)\n\n  return total_loss, per_example_loss, logits\n\n'"
src/gpu_utils.py,7,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport tensorflow as tf\n\ndef assign_to_gpu(gpu=0, ps_dev=""/device:CPU:0""):\n    def _assign(op):\n        node_def = op if isinstance(op, tf.NodeDef) else op.node_def\n        if node_def.op == ""Variable"":\n            return ps_dev\n        else:\n            return ""/gpu:%d"" % gpu\n    return _assign\n\n\ndef average_grads_and_vars(tower_grads_and_vars):\n    def average_dense(grad_and_vars):\n        if len(grad_and_vars) == 1:\n            return grad_and_vars[0][0]\n\n        grad = grad_and_vars[0][0]\n        for g, _ in grad_and_vars[1:]:\n            grad += g\n        return grad / len(grad_and_vars)\n\n    def average_sparse(grad_and_vars):\n        if len(grad_and_vars) == 1:\n            return grad_and_vars[0][0]\n\n        indices = []\n        values = []\n        for g, _ in grad_and_vars:\n            indices += [g.indices]\n            values += [g.values]\n        indices = tf.concat(indices, 0)\n        values = tf.concat(values, 0) / len(grad_and_vars)\n        return tf.IndexedSlices(values, indices, grad_and_vars[0][0].dense_shape)\n\n    average_grads_and_vars = []\n    for grad_and_vars in zip(*tower_grads_and_vars):\n        if grad_and_vars[0][0] is None:\n            grad = None\n        elif isinstance(grad_and_vars[0][0], tf.IndexedSlices):\n            grad = average_sparse(grad_and_vars)\n        else:\n            grad = average_dense(grad_and_vars)\n        # Keep in mind that the Variables are redundant because they are shared\n        # across towers. So .. we will just return the first tower\'s pointer to\n        # the Variable.\n        v = grad_and_vars[0][1]\n        grad_and_var = (grad, v)\n        average_grads_and_vars.append(grad_and_var)\n    return average_grads_and_vars\n\n\ndef load_from_checkpoint(saver, logdir):\n    sess = tf.get_default_session()\n    ckpt = tf.train.get_checkpoint_state(logdir)\n    if ckpt and ckpt.model_checkpoint_path:\n        if os.path.isabs(ckpt.model_checkpoint_path):\n            # Restores from checkpoint with absolute path.\n            saver.restore(sess, ckpt.model_checkpoint_path)\n        else:\n            # Restores from checkpoint with relative path.\n            saver.restore(sess, os.path.join(logdir, ckpt.model_checkpoint_path))\n        return True\n    return False\n'"
src/model_utils.py,75,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport os\nimport re\nimport numpy as np\nimport six\nfrom os.path import join\nfrom six.moves import zip\n\nfrom absl import flags\n\nimport tensorflow as tf\n\n\ndef configure_tpu(FLAGS):\n  if FLAGS.use_tpu:\n    tpu_cluster = tf.contrib.cluster_resolver.TPUClusterResolver(\n        FLAGS.tpu, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)\n    master = tpu_cluster.get_master()\n  else:\n    tpu_cluster = None\n    master = FLAGS.master\n\n  session_config = tf.ConfigProto(allow_soft_placement=True)\n  # Uncomment the following line if you hope to monitor GPU RAM growth\n  # session_config.gpu_options.allow_growth = True\n\n  if FLAGS.use_tpu:\n    strategy = None\n    tf.logging.info(\'Use TPU without distribute strategy.\')\n  elif FLAGS.num_core_per_host == 1:\n    strategy = None\n    tf.logging.info(\'Single device mode.\')\n  else:\n    strategy = tf.contrib.distribute.MirroredStrategy(\n        num_gpus=FLAGS.num_core_per_host)\n    tf.logging.info(\'Use MirroredStrategy with %d devices.\',\n                    strategy.num_replicas_in_sync)\n\n  per_host_input = tf.contrib.tpu.InputPipelineConfig.PER_HOST_V2\n  run_config = tf.contrib.tpu.RunConfig(\n      master=master,\n      model_dir=FLAGS.model_dir,\n      session_config=session_config,\n      tpu_config=tf.contrib.tpu.TPUConfig(\n          iterations_per_loop=FLAGS.iterations,\n          num_shards=FLAGS.num_hosts * FLAGS.num_core_per_host,\n          per_host_input_for_training=per_host_input),\n      keep_checkpoint_max=FLAGS.max_save,\n      save_checkpoints_secs=None,\n      save_checkpoints_steps=FLAGS.save_steps,\n      train_distribute=strategy\n  )\n  return run_config\n\n\ndef init_from_checkpoint(FLAGS, global_vars=False):\n  tvars = tf.global_variables() if global_vars else tf.trainable_variables()\n  initialized_variable_names = {}\n  scaffold_fn = None\n  if FLAGS.init_checkpoint is not None:\n    if FLAGS.init_checkpoint.endswith(""latest""):\n      ckpt_dir = os.path.dirname(FLAGS.init_checkpoint)\n      init_checkpoint = tf.train.latest_checkpoint(ckpt_dir)\n    else:\n      init_checkpoint = FLAGS.init_checkpoint\n\n    tf.logging.info(""Initialize from the ckpt {}"".format(init_checkpoint))\n\n    (assignment_map, initialized_variable_names\n    ) = get_assignment_map_from_checkpoint(tvars, init_checkpoint)\n    if FLAGS.use_tpu:\n      def tpu_scaffold():\n        tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n        return tf.train.Scaffold()\n\n      scaffold_fn = tpu_scaffold\n    else:\n      tf.train.init_from_checkpoint(init_checkpoint, assignment_map)\n\n    # Log customized initialization\n    tf.logging.info(""**** Global Variables ****"")\n    for var in tvars:\n      init_string = """"\n      if var.name in initialized_variable_names:\n        init_string = "", *INIT_FROM_CKPT*""\n      tf.logging.info(""  name = %s, shape = %s%s"", var.name, var.shape,\n                      init_string)\n  return scaffold_fn\n\n\ndef get_train_op(FLAGS, total_loss, grads_and_vars=None):\n  global_step = tf.train.get_or_create_global_step()\n\n  # increase the learning rate linearly\n  if FLAGS.warmup_steps > 0:\n    warmup_lr = (tf.cast(global_step, tf.float32)\n                 / tf.cast(FLAGS.warmup_steps, tf.float32)\n                 * FLAGS.learning_rate)\n  else:\n    warmup_lr = 0.0\n\n  # decay the learning rate\n  if FLAGS.decay_method == ""poly"":\n    decay_lr = tf.train.polynomial_decay(\n        FLAGS.learning_rate,\n        global_step=global_step - FLAGS.warmup_steps,\n        decay_steps=FLAGS.train_steps - FLAGS.warmup_steps,\n        end_learning_rate=FLAGS.learning_rate * FLAGS.min_lr_ratio)\n  elif FLAGS.decay_method == ""cos"":\n    decay_lr = tf.train.cosine_decay(\n        FLAGS.learning_rate,\n        global_step=global_step - FLAGS.warmup_steps,\n        decay_steps=FLAGS.train_steps - FLAGS.warmup_steps,\n        alpha=FLAGS.min_lr_ratio)\n  else:\n    raise ValueError(FLAGS.decay_method)\n\n  learning_rate = tf.where(global_step < FLAGS.warmup_steps,\n                           warmup_lr, decay_lr)\n\n  if (FLAGS.weight_decay > 0 and not FLAGS.use_tpu and\n      FLAGS.num_core_per_host > 1):\n    raise ValueError(""Do not support `weight_decay > 0` with multi-gpu ""\n                     ""training so far."")\n\n  if FLAGS.weight_decay == 0:\n    optimizer = tf.train.AdamOptimizer(\n        learning_rate=learning_rate,\n        epsilon=FLAGS.adam_epsilon)\n  else:\n    optimizer = AdamWeightDecayOptimizer(\n        learning_rate=learning_rate,\n        epsilon=FLAGS.adam_epsilon,\n        exclude_from_weight_decay=[""LayerNorm"", ""layer_norm"", ""bias""],\n        weight_decay_rate=FLAGS.weight_decay)\n\n  if FLAGS.use_tpu:\n    optimizer = tf.contrib.tpu.CrossShardOptimizer(optimizer)\n\n  if grads_and_vars is None:\n    grads_and_vars = optimizer.compute_gradients(total_loss)\n  gradients, variables = zip(*grads_and_vars)\n  clipped, gnorm = tf.clip_by_global_norm(gradients, FLAGS.clip)\n\n  if getattr(FLAGS, ""lr_layer_decay_rate"", 1.0) != 1.0:\n    n_layer = 0\n    for i in range(len(clipped)):\n      m = re.search(r""model/transformer/layer_(\\d+?)/"", variables[i].name)\n      if not m: continue\n      n_layer = max(n_layer, int(m.group(1)) + 1)\n\n    for i in range(len(clipped)):\n      for l in range(n_layer):\n        if ""model/transformer/layer_{}/"".format(l) in variables[i].name:\n          abs_rate = FLAGS.lr_layer_decay_rate ** (n_layer - 1 - l)\n          clipped[i] *= abs_rate\n          tf.logging.info(""Apply mult {:.4f} to layer-{} grad of {}"".format(\n              abs_rate, l, variables[i].name))\n          break\n\n  train_op = optimizer.apply_gradients(\n      zip(clipped, variables), global_step=global_step)\n\n  # Manually increment `global_step` for AdamWeightDecayOptimizer\n  if FLAGS.weight_decay > 0:\n    new_global_step = global_step + 1\n    train_op = tf.group(train_op, [global_step.assign(new_global_step)])\n\n  return train_op, learning_rate, gnorm\n\n\ndef clean_ckpt(_):\n  input_ckpt = FLAGS.clean_input_ckpt\n  output_model_dir = FLAGS.clean_output_model_dir\n\n  tf.reset_default_graph()\n\n  var_list = tf.contrib.framework.list_variables(input_ckpt)\n  var_values, var_dtypes = {}, {}\n  for (name, shape) in var_list:\n    if not name.startswith(""global_step"") and ""adam"" not in name.lower():\n      var_values[name] = None\n      tf.logging.info(""Include {}"".format(name))\n    else:\n      tf.logging.info(""Exclude {}"".format(name))\n\n  tf.logging.info(""Loading from {}"".format(input_ckpt))\n  reader = tf.contrib.framework.load_checkpoint(input_ckpt)\n  for name in var_values:\n    tensor = reader.get_tensor(name)\n    var_dtypes[name] = tensor.dtype\n    var_values[name] = tensor\n\n  with tf.variable_scope(tf.get_variable_scope(), reuse=tf.AUTO_REUSE):\n    tf_vars = [\n        tf.get_variable(v, shape=var_values[v].shape, dtype=var_dtypes[v])\n        for v in var_values\n    ]\n  placeholders = [tf.placeholder(v.dtype, shape=v.shape) for v in tf_vars]\n  assign_ops = [tf.assign(v, p) for (v, p) in zip(tf_vars, placeholders)]\n  global_step = tf.Variable(\n      0, name=""global_step"", trainable=False, dtype=tf.int64)\n  saver = tf.train.Saver(tf.all_variables())\n\n  if not tf.gfile.Exists(output_model_dir):\n    tf.gfile.MakeDirs(output_model_dir)\n\n  # Build a model consisting only of variables, set them to the average values.\n  with tf.Session() as sess:\n    sess.run(tf.initialize_all_variables())\n    for p, assign_op, (name, value) in zip(placeholders, assign_ops,\n                                           six.iteritems(var_values)):\n      sess.run(assign_op, {p: value})\n\n    # Use the built saver to save the averaged checkpoint.\n    saver.save(sess, join(output_model_dir, ""model.ckpt""),\n               global_step=global_step)\n\n\ndef avg_checkpoints(model_dir, output_model_dir, last_k):\n  tf.reset_default_graph()\n\n  checkpoint_state = tf.train.get_checkpoint_state(model_dir)\n  checkpoints = checkpoint_state.all_model_checkpoint_paths[- last_k:]\n  var_list = tf.contrib.framework.list_variables(checkpoints[0])\n  var_values, var_dtypes = {}, {}\n  for (name, shape) in var_list:\n    if not name.startswith(""global_step""):\n      var_values[name] = np.zeros(shape)\n  for checkpoint in checkpoints:\n    reader = tf.contrib.framework.load_checkpoint(checkpoint)\n    for name in var_values:\n      tensor = reader.get_tensor(name)\n      var_dtypes[name] = tensor.dtype\n      var_values[name] += tensor\n    tf.logging.info(""Read from checkpoint %s"", checkpoint)\n  for name in var_values:  # Average.\n    var_values[name] /= len(checkpoints)\n\n  with tf.variable_scope(tf.get_variable_scope(), reuse=tf.AUTO_REUSE):\n    tf_vars = [\n        tf.get_variable(v, shape=var_values[v].shape, dtype=var_dtypes[v])\n        for v in var_values\n    ]\n  placeholders = [tf.placeholder(v.dtype, shape=v.shape) for v in tf_vars]\n  assign_ops = [tf.assign(v, p) for (v, p) in zip(tf_vars, placeholders)]\n  global_step = tf.Variable(\n      0, name=""global_step"", trainable=False, dtype=tf.int64)\n  saver = tf.train.Saver(tf.all_variables())\n\n  # Build a model consisting only of variables, set them to the average values.\n  with tf.Session() as sess:\n    sess.run(tf.initialize_all_variables())\n    for p, assign_op, (name, value) in zip(placeholders, assign_ops,\n                                           six.iteritems(var_values)):\n      sess.run(assign_op, {p: value})\n    # Use the built saver to save the averaged checkpoint.\n    saver.save(sess, join(output_model_dir, ""model.ckpt""),\n        global_step=global_step)\n\n\ndef get_assignment_map_from_checkpoint(tvars, init_checkpoint):\n  """"""Compute the union of the current variables and checkpoint variables.""""""\n  assignment_map = {}\n  initialized_variable_names = {}\n\n  name_to_variable = collections.OrderedDict()\n  for var in tvars:\n    name = var.name\n    m = re.match(""^(.*):\\\\d+$"", name)\n    if m is not None:\n      name = m.group(1)\n    name_to_variable[name] = var\n\n  init_vars = tf.train.list_variables(init_checkpoint)\n\n  assignment_map = collections.OrderedDict()\n  for x in init_vars:\n    (name, var) = (x[0], x[1])\n    # tf.logging.info(\'original name: %s\', name)\n    if name not in name_to_variable:\n      continue\n    # assignment_map[name] = name\n    assignment_map[name] = name_to_variable[name]\n    initialized_variable_names[name] = 1\n    initialized_variable_names[name + "":0""] = 1\n\n  return (assignment_map, initialized_variable_names)\n\n\nclass AdamWeightDecayOptimizer(tf.train.Optimizer):\n  """"""A basic Adam optimizer that includes ""correct"" L2 weight decay.""""""\n\n  def __init__(self,\n               learning_rate,\n               weight_decay_rate=0.0,\n               beta_1=0.9,\n               beta_2=0.999,\n               epsilon=1e-6,\n               exclude_from_weight_decay=None,\n               include_in_weight_decay=[""r_s_bias"", ""r_r_bias"", ""r_w_bias""],\n               name=""AdamWeightDecayOptimizer""):\n    """"""Constructs a AdamWeightDecayOptimizer.""""""\n    super(AdamWeightDecayOptimizer, self).__init__(False, name)\n\n    self.learning_rate = learning_rate\n    self.weight_decay_rate = weight_decay_rate\n    self.beta_1 = beta_1\n    self.beta_2 = beta_2\n    self.epsilon = epsilon\n    self.exclude_from_weight_decay = exclude_from_weight_decay\n    self.include_in_weight_decay = include_in_weight_decay\n\n  def apply_gradients(self, grads_and_vars, global_step=None, name=None):\n    """"""See base class.""""""\n    assignments = []\n    for (grad, param) in grads_and_vars:\n      if grad is None or param is None:\n        continue\n\n      param_name = self._get_variable_name(param.name)\n\n      m = tf.get_variable(\n          name=param_name + ""/adam_m"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n      v = tf.get_variable(\n          name=param_name + ""/adam_v"",\n          shape=param.shape.as_list(),\n          dtype=tf.float32,\n          trainable=False,\n          initializer=tf.zeros_initializer())\n\n      # Standard Adam update.\n      next_m = (\n          tf.multiply(self.beta_1, m) + tf.multiply(1.0 - self.beta_1, grad))\n      next_v = (\n          tf.multiply(self.beta_2, v) + tf.multiply(1.0 - self.beta_2,\n                                                    tf.square(grad)))\n\n      update = next_m / (tf.sqrt(next_v) + self.epsilon)\n\n      # Just adding the square of the weights to the loss function is *not*\n      # the correct way of using L2 regularization/weight decay with Adam,\n      # since that will interact with the m and v parameters in strange ways.\n      #\n      # Instead we want ot decay the weights in a manner that doesn\'t interact\n      # with the m/v parameters. This is equivalent to adding the square\n      # of the weights to the loss with plain (non-momentum) SGD.\n      if self._do_use_weight_decay(param_name):\n        update += self.weight_decay_rate * param\n\n      update_with_lr = self.learning_rate * update\n\n      next_param = param - update_with_lr\n\n      assignments.extend(\n          [param.assign(next_param),\n           m.assign(next_m),\n           v.assign(next_v)])\n\n    return tf.group(*assignments, name=name)\n\n  def _do_use_weight_decay(self, param_name):\n    """"""Whether to use L2 weight decay for `param_name`.""""""\n    if not self.weight_decay_rate:\n      return False\n    for r in self.include_in_weight_decay:\n      if re.search(r, param_name) is not None:\n        return True\n\n    if self.exclude_from_weight_decay:\n      for r in self.exclude_from_weight_decay:\n        if re.search(r, param_name) is not None:\n          tf.logging.info(\'Adam WD excludes {}\'.format(param_name))\n          return False\n    return True\n\n  def _get_variable_name(self, param_name):\n    """"""Get the variable name from the tensor name.""""""\n    m = re.match(""^(.*):\\\\d+$"", param_name)\n    if m is not None:\n      param_name = m.group(1)\n    return param_name\n\n\nif __name__ == ""__main__"":\n  flags.DEFINE_string(""clean_input_ckpt"", """", ""input ckpt for cleaning"")\n  flags.DEFINE_string(""clean_output_model_dir"", """", ""output dir for cleaned ckpt"")\n\n  FLAGS = flags.FLAGS\n\n  tf.app.run(clean_ckpt)\n'"
src/modeling.py,135,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\nimport tensorflow as tf\n\n\ndef gelu(x):\n  """"""Gaussian Error Linear Unit.\n\n  This is a smoother version of the RELU.\n  Original paper: https://arxiv.org/abs/1606.08415\n  Args:\n    x: float Tensor to perform activation.\n\n  Returns:\n    `x` with the GELU activation applied.\n  """"""\n  cdf = 0.5 * (1.0 + tf.tanh(\n      (np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3)))))\n  return x * cdf\n\n\ndef embedding_lookup(x, n_token, d_embed, initializer, use_tpu=True,\n                     scope=\'embedding\', reuse=None, dtype=tf.float32):\n  """"""TPU and GPU embedding_lookup function.""""""\n  with tf.variable_scope(scope, reuse=reuse):\n    lookup_table = tf.get_variable(\'lookup_table\', [n_token, d_embed],\n                                   dtype=dtype, initializer=initializer)\n    if use_tpu:\n      one_hot_idx = tf.one_hot(x, n_token, dtype=dtype)\n      if one_hot_idx.shape.ndims == 2:\n        return tf.einsum(\'in,nd->id\', one_hot_idx, lookup_table), lookup_table\n      else:\n        return tf.einsum(\'ibn,nd->ibd\', one_hot_idx, lookup_table), lookup_table\n    else:\n      return tf.nn.embedding_lookup(lookup_table, x), lookup_table\n\n\ndef positional_embedding(pos_seq, inv_freq, bsz=None):\n  sinusoid_inp = tf.einsum(\'i,d->id\', pos_seq, inv_freq)\n  pos_emb = tf.concat([tf.sin(sinusoid_inp), tf.cos(sinusoid_inp)], -1)\n  pos_emb = pos_emb[:, None, :]\n\n  if bsz is not None:\n    pos_emb = tf.tile(pos_emb, [1, bsz, 1])\n\n  return pos_emb\n\n\ndef positionwise_ffn(inp, d_model, d_inner, dropout, kernel_initializer,\n                     activation_type=\'relu\', scope=\'ff\', is_training=True,\n                     reuse=None):\n  """"""Position-wise Feed-forward Network.""""""\n  if activation_type == \'relu\':\n    activation = tf.nn.relu\n  elif activation_type == \'gelu\':\n    activation = gelu\n  else:\n    raise ValueError(\'Unsupported activation type {}\'.format(activation_type))\n\n  output = inp\n  with tf.variable_scope(scope, reuse=reuse):\n    output = tf.layers.dense(output, d_inner, activation=activation,\n                             kernel_initializer=kernel_initializer,\n                             name=\'layer_1\')\n    output = tf.layers.dropout(output, dropout, training=is_training,\n                               name=\'drop_1\')\n    output = tf.layers.dense(output, d_model,\n                             kernel_initializer=kernel_initializer,\n                             name=\'layer_2\')\n    output = tf.layers.dropout(output, dropout, training=is_training,\n                               name=\'drop_2\')\n    output = tf.contrib.layers.layer_norm(output + inp, begin_norm_axis=-1,\n                                          scope=\'LayerNorm\')\n  return output\n\n\ndef head_projection(h, d_model, n_head, d_head, kernel_initializer, name):\n  """"""Project hidden states to a specific head with a 4D-shape.""""""\n  proj_weight = tf.get_variable(\'{}/kernel\'.format(name),\n                                [d_model, n_head, d_head], dtype=h.dtype,\n                                initializer=kernel_initializer)\n  head = tf.einsum(\'ibh,hnd->ibnd\', h, proj_weight)\n\n  return head\n\n\ndef post_attention(h, attn_vec, d_model, n_head, d_head, dropout, is_training,\n                   kernel_initializer, residual=True):\n  """"""Post-attention processing.""""""\n  # post-attention projection (back to `d_model`)\n  proj_o = tf.get_variable(\'o/kernel\', [d_model, n_head, d_head],\n                           dtype=h.dtype, initializer=kernel_initializer)\n  attn_out = tf.einsum(\'ibnd,hnd->ibh\', attn_vec, proj_o)\n\n  attn_out = tf.layers.dropout(attn_out, dropout, training=is_training)\n  if residual:\n    output = tf.contrib.layers.layer_norm(attn_out + h, begin_norm_axis=-1,\n                                          scope=\'LayerNorm\')\n  else:\n    output = tf.contrib.layers.layer_norm(attn_out, begin_norm_axis=-1,\n                                          scope=\'LayerNorm\')\n\n  return output\n\n\ndef abs_attn_core(q_head, k_head, v_head, attn_mask, dropatt, is_training,\n                  scale):\n  """"""Core absolute positional attention operations.""""""\n\n  attn_score = tf.einsum(\'ibnd,jbnd->ijbn\', q_head, k_head)\n  attn_score *= scale\n  if attn_mask is not None:\n    attn_score = attn_score - 1e30 * attn_mask\n\n  # attention probability\n  attn_prob = tf.nn.softmax(attn_score, 1)\n  attn_prob = tf.layers.dropout(attn_prob, dropatt, training=is_training)\n\n  # attention output\n  attn_vec = tf.einsum(\'ijbn,jbnd->ibnd\', attn_prob, v_head)\n\n  return attn_vec\n\n\ndef rel_attn_core(q_head, k_head_h, v_head_h, k_head_r, seg_embed, seg_mat,\n                  r_w_bias, r_r_bias, r_s_bias, attn_mask, dropatt, is_training,\n                  scale):\n  """"""Core relative positional attention operations.""""""\n\n  # content based attention score\n  ac = tf.einsum(\'ibnd,jbnd->ijbn\', q_head + r_w_bias, k_head_h)\n\n  # position based attention score\n  bd = tf.einsum(\'ibnd,jbnd->ijbn\', q_head + r_r_bias, k_head_r)\n  bd = rel_shift(bd, klen=tf.shape(ac)[1])\n\n  # segment based attention score\n  if seg_mat is None:\n    ef = 0\n  else:\n    ef = tf.einsum(\'ibnd,snd->ibns\', q_head + r_s_bias, seg_embed)\n    ef = tf.einsum(\'ijbs,ibns->ijbn\', seg_mat, ef)\n\n  # merge attention scores and perform masking\n  attn_score = (ac + bd + ef) * scale\n  if attn_mask is not None:\n    # attn_score = attn_score * (1 - attn_mask) - 1e30 * attn_mask\n    attn_score = attn_score - 1e30 * attn_mask\n\n  # attention probability\n  attn_prob = tf.nn.softmax(attn_score, 1)\n  attn_prob = tf.layers.dropout(attn_prob, dropatt, training=is_training)\n\n  # attention output\n  attn_vec = tf.einsum(\'ijbn,jbnd->ibnd\', attn_prob, v_head_h)\n\n  return attn_vec\n\n\ndef rel_shift(x, klen=-1):\n  """"""perform relative shift to form the relative attention score.""""""\n  x_size = tf.shape(x)\n\n  x = tf.reshape(x, [x_size[1], x_size[0], x_size[2], x_size[3]])\n  x = tf.slice(x, [1, 0, 0, 0], [-1, -1, -1, -1])\n  x = tf.reshape(x, [x_size[0], x_size[1] - 1, x_size[2], x_size[3]])\n  x = tf.slice(x, [0, 0, 0, 0], [-1, klen, -1, -1])\n\n  return x\n\n\ndef _create_mask(qlen, mlen, dtype=tf.float32, same_length=False):\n  """"""create causal attention mask.""""""\n  attn_mask = tf.ones([qlen, qlen], dtype=dtype)\n  mask_u = tf.matrix_band_part(attn_mask, 0, -1)\n  mask_dia = tf.matrix_band_part(attn_mask, 0, 0)\n  attn_mask_pad = tf.zeros([qlen, mlen], dtype=dtype)\n  ret = tf.concat([attn_mask_pad, mask_u - mask_dia], 1)\n  if same_length:\n    mask_l = tf.matrix_band_part(attn_mask, -1, 0)\n    ret = tf.concat([ret[:, :qlen] + mask_l - mask_dia, ret[:, qlen:]], 1)\n\n  return ret\n\n\ndef _cache_mem(curr_out, prev_mem, mem_len, reuse_len=None):\n  """"""cache hidden states into memory.""""""\n  if mem_len is None or mem_len == 0:\n    return None\n  else:\n    if reuse_len is not None and reuse_len > 0:\n      curr_out = curr_out[:reuse_len]\n\n    if prev_mem is None:\n      new_mem = curr_out[-mem_len:]\n    else:\n      new_mem = tf.concat([prev_mem, curr_out], 0)[-mem_len:]\n\n  return tf.stop_gradient(new_mem)\n\n\ndef relative_positional_encoding(qlen, klen, d_model, clamp_len, attn_type,\n                                 bi_data, bsz=None, dtype=None):\n  """"""create relative positional encoding.""""""\n  freq_seq = tf.range(0, d_model, 2.0)\n  if dtype is not None and dtype != tf.float32:\n    freq_seq = tf.cast(freq_seq, dtype=dtype)\n  inv_freq = 1 / (10000 ** (freq_seq / d_model))\n\n  if attn_type == \'bi\':\n    # beg, end = klen - 1, -qlen\n    beg, end = klen, -qlen\n  elif attn_type == \'uni\':\n    # beg, end = klen - 1, -1\n    beg, end = klen, -1\n  else:\n    raise ValueError(\'Unknown `attn_type` {}.\'.format(attn_type))\n\n  if bi_data:\n    fwd_pos_seq = tf.range(beg, end, -1.0)\n    bwd_pos_seq = tf.range(-beg, -end, 1.0)\n\n    if dtype is not None and dtype != tf.float32:\n      fwd_pos_seq = tf.cast(fwd_pos_seq, dtype=dtype)\n      bwd_pos_seq = tf.cast(bwd_pos_seq, dtype=dtype)\n\n    if clamp_len > 0:\n      fwd_pos_seq = tf.clip_by_value(fwd_pos_seq, -clamp_len, clamp_len)\n      bwd_pos_seq = tf.clip_by_value(bwd_pos_seq, -clamp_len, clamp_len)\n\n    if bsz is not None:\n      # With bi_data, the batch size should be divisible by 2.\n      assert bsz%2 == 0\n      fwd_pos_emb = positional_embedding(fwd_pos_seq, inv_freq, bsz//2)\n      bwd_pos_emb = positional_embedding(bwd_pos_seq, inv_freq, bsz//2)\n    else:\n      fwd_pos_emb = positional_embedding(fwd_pos_seq, inv_freq)\n      bwd_pos_emb = positional_embedding(bwd_pos_seq, inv_freq)\n\n    pos_emb = tf.concat([fwd_pos_emb, bwd_pos_emb], axis=1)\n  else:\n    fwd_pos_seq = tf.range(beg, end, -1.0)\n    if dtype is not None and dtype != tf.float32:\n      fwd_pos_seq = tf.cast(fwd_pos_seq, dtype=dtype)\n    if clamp_len > 0:\n      fwd_pos_seq = tf.clip_by_value(fwd_pos_seq, -clamp_len, clamp_len)\n    pos_emb = positional_embedding(fwd_pos_seq, inv_freq, bsz)\n\n  return pos_emb\n\n\ndef multihead_attn(q, k, v, attn_mask, d_model, n_head, d_head, dropout,\n                   dropatt, is_training, kernel_initializer, residual=True,\n                   scope=\'abs_attn\', reuse=None):\n  """"""Standard multi-head attention with absolute positional embedding.""""""\n\n  scale = 1 / (d_head ** 0.5)\n  with tf.variable_scope(scope, reuse=reuse):\n    # attention heads\n    q_head = head_projection(\n        q, d_model, n_head, d_head, kernel_initializer, \'q\')\n    k_head = head_projection(\n        k, d_model, n_head, d_head, kernel_initializer, \'k\')\n    v_head = head_projection(\n        v, d_model, n_head, d_head, kernel_initializer, \'v\')\n\n    # attention vector\n    attn_vec = abs_attn_core(q_head, k_head, v_head, attn_mask, dropatt,\n                             is_training, scale)\n\n    # post processing\n    output = post_attention(v, attn_vec, d_model, n_head, d_head, dropout,\n                            is_training, kernel_initializer, residual)\n\n  return output\n\n\n\ndef rel_multihead_attn(h, r, r_w_bias, r_r_bias, seg_mat, r_s_bias, seg_embed,\n                       attn_mask, mems, d_model, n_head, d_head, dropout,\n                       dropatt, is_training, kernel_initializer,\n                       scope=\'rel_attn\', reuse=None):\n  """"""Multi-head attention with relative positional encoding.""""""\n\n  scale = 1 / (d_head ** 0.5)\n  with tf.variable_scope(scope, reuse=reuse):\n    if mems is not None and mems.shape.ndims > 1:\n      cat = tf.concat([mems, h], 0)\n    else:\n      cat = h\n\n    # content heads\n    q_head_h = head_projection(\n        h, d_model, n_head, d_head, kernel_initializer, \'q\')\n    k_head_h = head_projection(\n        cat, d_model, n_head, d_head, kernel_initializer, \'k\')\n    v_head_h = head_projection(\n        cat, d_model, n_head, d_head, kernel_initializer, \'v\')\n\n    # positional heads\n    k_head_r = head_projection(\n        r, d_model, n_head, d_head, kernel_initializer, \'r\')\n\n    # core attention ops\n    attn_vec = rel_attn_core(\n        q_head_h, k_head_h, v_head_h, k_head_r, seg_embed, seg_mat, r_w_bias,\n        r_r_bias, r_s_bias, attn_mask, dropatt, is_training, scale)\n\n    # post processing\n    output = post_attention(h, attn_vec, d_model, n_head, d_head, dropout,\n                            is_training, kernel_initializer)\n\n  return output\n\n\ndef two_stream_rel_attn(h, g, r, mems, r_w_bias, r_r_bias, seg_mat, r_s_bias,\n                        seg_embed, attn_mask_h, attn_mask_g, target_mapping,\n                        d_model, n_head, d_head, dropout, dropatt, is_training,\n                        kernel_initializer, scope=\'rel_attn\'):\n  """"""Two-stream attention with relative positional encoding.""""""\n\n  scale = 1 / (d_head ** 0.5)\n  with tf.variable_scope(scope, reuse=False):\n\n    # content based attention score\n    if mems is not None and mems.shape.ndims > 1:\n      cat = tf.concat([mems, h], 0)\n    else:\n      cat = h\n\n    # content-based key head\n    k_head_h = head_projection(\n        cat, d_model, n_head, d_head, kernel_initializer, \'k\')\n\n    # content-based value head\n    v_head_h = head_projection(\n        cat, d_model, n_head, d_head, kernel_initializer, \'v\')\n\n    # position-based key head\n    k_head_r = head_projection(\n        r, d_model, n_head, d_head, kernel_initializer, \'r\')\n\n    ##### h-stream\n    # content-stream query head\n    q_head_h = head_projection(\n        h, d_model, n_head, d_head, kernel_initializer, \'q\')\n\n    # core attention ops\n    attn_vec_h = rel_attn_core(\n        q_head_h, k_head_h, v_head_h, k_head_r, seg_embed, seg_mat, r_w_bias,\n        r_r_bias, r_s_bias, attn_mask_h, dropatt, is_training, scale)\n\n    # post processing\n    output_h = post_attention(h, attn_vec_h, d_model, n_head, d_head, dropout,\n                              is_training, kernel_initializer)\n\n  with tf.variable_scope(scope, reuse=True):\n    ##### g-stream\n    # query-stream query head\n    q_head_g = head_projection(\n        g, d_model, n_head, d_head, kernel_initializer, \'q\')\n\n    # core attention ops\n    if target_mapping is not None:\n      q_head_g = tf.einsum(\'mbnd,mlb->lbnd\', q_head_g, target_mapping)\n      attn_vec_g = rel_attn_core(\n          q_head_g, k_head_h, v_head_h, k_head_r, seg_embed, seg_mat, r_w_bias,\n          r_r_bias, r_s_bias, attn_mask_g, dropatt, is_training, scale)\n      attn_vec_g = tf.einsum(\'lbnd,mlb->mbnd\', attn_vec_g, target_mapping)\n    else:\n      attn_vec_g = rel_attn_core(\n          q_head_g, k_head_h, v_head_h, k_head_r, seg_embed, seg_mat, r_w_bias,\n          r_r_bias, r_s_bias, attn_mask_g, dropatt, is_training, scale)\n\n    # post processing\n    output_g = post_attention(g, attn_vec_g, d_model, n_head, d_head, dropout,\n                              is_training, kernel_initializer)\n\n    return output_h, output_g\n\n\ndef transformer_xl(inp_k, n_token, n_layer, d_model, n_head,\n                d_head, d_inner, dropout, dropatt, attn_type,\n                bi_data, initializer, is_training, mem_len=None,\n                inp_q=None, mems=None,\n                same_length=False, clamp_len=-1, untie_r=False,\n                use_tpu=True, input_mask=None,\n                perm_mask=None, seg_id=None, reuse_len=None,\n                ff_activation=\'relu\', target_mapping=None,\n                use_bfloat16=False, scope=\'transformer\', **kwargs):\n  """"""\n    Defines a Transformer-XL computation graph with additional\n    support for XLNet.\n\n    Args:\n\n    inp_k: int32 Tensor in shape [len, bsz], the input token IDs.\n    seg_id: int32 Tensor in shape [len, bsz], the input segment IDs.\n    input_mask: float32 Tensor in shape [len, bsz], the input mask.\n      0 for real tokens and 1 for padding.\n    mems: a list of float32 Tensors in shape [mem_len, bsz, d_model], memory\n      from previous batches. The length of the list equals n_layer.\n      If None, no memory is used.\n    perm_mask: float32 Tensor in shape [len, len, bsz].\n      If perm_mask[i, j, k] = 0, i attend to j in batch k;\n      if perm_mask[i, j, k] = 1, i does not attend to j in batch k.\n      If None, each position attends to all the others.\n    target_mapping: float32 Tensor in shape [num_predict, len, bsz].\n      If target_mapping[i, j, k] = 1, the i-th predict in batch k is\n      on the j-th token.\n      Only used during pretraining for partial prediction.\n      Set to None during finetuning.\n    inp_q: float32 Tensor in shape [len, bsz].\n      1 for tokens with losses and 0 for tokens without losses.\n      Only used during pretraining for two-stream attention.\n      Set to None during finetuning.\n\n    n_layer: int, the number of layers.\n    d_model: int, the hidden size.\n    n_head: int, the number of attention heads.\n    d_head: int, the dimension size of each attention head.\n    d_inner: int, the hidden size in feed-forward layers.\n    ff_activation: str, ""relu"" or ""gelu"".\n    untie_r: bool, whether to untie the biases in attention.\n    n_token: int, the vocab size.\n\n    is_training: bool, whether in training mode.\n    use_tpu: bool, whether TPUs are used.\n    use_bfloat16: bool, use bfloat16 instead of float32.\n    dropout: float, dropout rate.\n    dropatt: float, dropout rate on attention probabilities.\n    init: str, the initialization scheme, either ""normal"" or ""uniform"".\n    init_range: float, initialize the parameters with a uniform distribution\n      in [-init_range, init_range]. Only effective when init=""uniform"".\n    init_std: float, initialize the parameters with a normal distribution\n      with mean 0 and stddev init_std. Only effective when init=""normal"".\n    mem_len: int, the number of tokens to cache.\n    reuse_len: int, the number of tokens in the currect batch to be cached\n      and reused in the future.\n    bi_data: bool, whether to use bidirectional input pipeline.\n      Usually set to True during pretraining and False during finetuning.\n    clamp_len: int, clamp all relative distances larger than clamp_len.\n      -1 means no clamping.\n    same_length: bool, whether to use the same attention length for each token.\n    summary_type: str, ""last"", ""first"", ""mean"", or ""attn"". The method\n      to pool the input to get a vector representation.\n    initializer: A tf initializer.\n    scope: scope name for the computation graph.\n  """"""\n  tf.logging.info(\'memory input {}\'.format(mems))\n  tf_float = tf.bfloat16 if use_bfloat16 else tf.float32\n  tf.logging.info(\'Use float type {}\'.format(tf_float))\n\n  new_mems = []\n  with tf.variable_scope(scope):\n    if untie_r:\n      r_w_bias = tf.get_variable(\'r_w_bias\', [n_layer, n_head, d_head],\n                                 dtype=tf_float, initializer=initializer)\n      r_r_bias = tf.get_variable(\'r_r_bias\', [n_layer, n_head, d_head],\n                                 dtype=tf_float, initializer=initializer)\n    else:\n      r_w_bias = tf.get_variable(\'r_w_bias\', [n_head, d_head],\n                                 dtype=tf_float, initializer=initializer)\n      r_r_bias = tf.get_variable(\'r_r_bias\', [n_head, d_head],\n                                 dtype=tf_float, initializer=initializer)\n\n    bsz = tf.shape(inp_k)[1]\n    qlen = tf.shape(inp_k)[0]\n    mlen = tf.shape(mems[0])[0] if mems is not None else 0\n    klen = mlen + qlen\n\n    ##### Attention mask\n    # causal attention mask\n    if attn_type == \'uni\':\n      attn_mask = _create_mask(qlen, mlen, tf_float, same_length)\n      attn_mask = attn_mask[:, :, None, None]\n    elif attn_type == \'bi\':\n      attn_mask = None\n    else:\n      raise ValueError(\'Unsupported attention type: {}\'.format(attn_type))\n\n    # data mask: input mask & perm mask\n    if input_mask is not None and perm_mask is not None:\n      data_mask = input_mask[None] + perm_mask\n    elif input_mask is not None and perm_mask is None:\n      data_mask = input_mask[None]\n    elif input_mask is None and perm_mask is not None:\n      data_mask = perm_mask\n    else:\n      data_mask = None\n\n    if data_mask is not None:\n      # all mems can be attended to\n      mems_mask = tf.zeros([tf.shape(data_mask)[0], mlen, bsz],\n                           dtype=tf_float)\n      data_mask = tf.concat([mems_mask, data_mask], 1)\n      if attn_mask is None:\n        attn_mask = data_mask[:, :, :, None]\n      else:\n        attn_mask += data_mask[:, :, :, None]\n\n    if attn_mask is not None:\n      attn_mask = tf.cast(attn_mask > 0, dtype=tf_float)\n\n    if attn_mask is not None:\n      non_tgt_mask = -tf.eye(qlen, dtype=tf_float)\n      non_tgt_mask = tf.concat([tf.zeros([qlen, mlen], dtype=tf_float),\n                                non_tgt_mask], axis=-1)\n      non_tgt_mask = tf.cast((attn_mask + non_tgt_mask[:, :, None, None]) > 0,\n                             dtype=tf_float)\n    else:\n      non_tgt_mask = None\n\n    ##### Word embedding\n    word_emb_k, lookup_table = embedding_lookup(\n        x=inp_k,\n        n_token=n_token,\n        d_embed=d_model,\n        initializer=initializer,\n        use_tpu=use_tpu,\n        dtype=tf_float,\n        scope=\'word_embedding\')\n\n    if inp_q is not None:\n      with tf.variable_scope(\'mask_emb\'):\n        mask_emb = tf.get_variable(\'mask_emb\', [1, 1, d_model], dtype=tf_float)\n        if target_mapping is not None:\n          word_emb_q = tf.tile(mask_emb, [tf.shape(target_mapping)[0], bsz, 1])\n        else:\n          inp_q_ext = inp_q[:, :, None]\n          word_emb_q = inp_q_ext * mask_emb + (1 - inp_q_ext) * word_emb_k\n    output_h = tf.layers.dropout(word_emb_k, dropout, training=is_training)\n    if inp_q is not None:\n      output_g = tf.layers.dropout(word_emb_q, dropout, training=is_training)\n\n    ##### Segment embedding\n    if seg_id is not None:\n      if untie_r:\n        r_s_bias = tf.get_variable(\'r_s_bias\', [n_layer, n_head, d_head],\n                                   dtype=tf_float, initializer=initializer)\n      else:\n        # default case (tie)\n        r_s_bias = tf.get_variable(\'r_s_bias\', [n_head, d_head],\n                                   dtype=tf_float, initializer=initializer)\n\n      seg_embed = tf.get_variable(\'seg_embed\', [n_layer, 2, n_head, d_head],\n                                  dtype=tf_float, initializer=initializer)\n\n      # Convert `seg_id` to one-hot `seg_mat`\n      mem_pad = tf.zeros([mlen, bsz], dtype=tf.int32)\n      cat_ids = tf.concat([mem_pad, seg_id], 0)\n\n      # `1` indicates not in the same segment [qlen x klen x bsz]\n      seg_mat = tf.cast(\n          tf.logical_not(tf.equal(seg_id[:, None], cat_ids[None, :])),\n          tf.int32)\n      seg_mat = tf.one_hot(seg_mat, 2, dtype=tf_float)\n    else:\n      seg_mat = None\n\n    ##### Positional encoding\n    pos_emb = relative_positional_encoding(\n        qlen, klen, d_model, clamp_len, attn_type, bi_data,\n        bsz=bsz, dtype=tf_float)\n    pos_emb = tf.layers.dropout(pos_emb, dropout, training=is_training)\n\n    ##### Attention layers\n    if mems is None:\n      mems = [None] * n_layer\n\n    for i in range(n_layer):\n      # cache new mems\n      new_mems.append(_cache_mem(output_h, mems[i], mem_len, reuse_len))\n\n      # segment bias\n      if seg_id is None:\n        r_s_bias_i = None\n        seg_embed_i = None\n      else:\n        r_s_bias_i = r_s_bias if not untie_r else r_s_bias[i]\n        seg_embed_i = seg_embed[i]\n\n      with tf.variable_scope(\'layer_{}\'.format(i)):\n        if inp_q is not None:\n          output_h, output_g = two_stream_rel_attn(\n              h=output_h,\n              g=output_g,\n              r=pos_emb,\n              r_w_bias=r_w_bias if not untie_r else r_w_bias[i],\n              r_r_bias=r_r_bias if not untie_r else r_r_bias[i],\n              seg_mat=seg_mat,\n              r_s_bias=r_s_bias_i,\n              seg_embed=seg_embed_i,\n              attn_mask_h=non_tgt_mask,\n              attn_mask_g=attn_mask,\n              mems=mems[i],\n              target_mapping=target_mapping,\n              d_model=d_model,\n              n_head=n_head,\n              d_head=d_head,\n              dropout=dropout,\n              dropatt=dropatt,\n              is_training=is_training,\n              kernel_initializer=initializer)\n          reuse = True\n        else:\n          reuse = False\n\n          output_h = rel_multihead_attn(\n              h=output_h,\n              r=pos_emb,\n              r_w_bias=r_w_bias if not untie_r else r_w_bias[i],\n              r_r_bias=r_r_bias if not untie_r else r_r_bias[i],\n              seg_mat=seg_mat,\n              r_s_bias=r_s_bias_i,\n              seg_embed=seg_embed_i,\n              attn_mask=non_tgt_mask,\n              mems=mems[i],\n              d_model=d_model,\n              n_head=n_head,\n              d_head=d_head,\n              dropout=dropout,\n              dropatt=dropatt,\n              is_training=is_training,\n              kernel_initializer=initializer,\n              reuse=reuse)\n\n        if inp_q is not None:\n          output_g = positionwise_ffn(\n              inp=output_g,\n              d_model=d_model,\n              d_inner=d_inner,\n              dropout=dropout,\n              kernel_initializer=initializer,\n              activation_type=ff_activation,\n              is_training=is_training)\n\n        output_h = positionwise_ffn(\n            inp=output_h,\n            d_model=d_model,\n            d_inner=d_inner,\n            dropout=dropout,\n            kernel_initializer=initializer,\n            activation_type=ff_activation,\n            is_training=is_training,\n            reuse=reuse)\n\n    if inp_q is not None:\n      output = tf.layers.dropout(output_g, dropout, training=is_training)\n    else:\n      output = tf.layers.dropout(output_h, dropout, training=is_training)\n\n    return output, new_mems, lookup_table\n\n\ndef lm_loss(hidden, target, n_token, d_model, initializer, lookup_table=None,\n            tie_weight=False, bi_data=True, use_tpu=False):\n  """"""doc.""""""\n\n  with tf.variable_scope(\'lm_loss\'):\n    if tie_weight:\n      assert lookup_table is not None, \\\n          \'lookup_table cannot be None for tie_weight\'\n      softmax_w = lookup_table\n    else:\n      softmax_w = tf.get_variable(\'weight\', [n_token, d_model],\n                                  dtype=hidden.dtype, initializer=initializer)\n\n    softmax_b = tf.get_variable(\'bias\', [n_token], dtype=hidden.dtype,\n                                initializer=tf.zeros_initializer())\n\n    logits = tf.einsum(\'ibd,nd->ibn\', hidden, softmax_w) + softmax_b\n\n    if use_tpu:\n      one_hot_target = tf.one_hot(target, n_token, dtype=logits.dtype)\n      loss = -tf.reduce_sum(tf.nn.log_softmax(logits) * one_hot_target, -1)\n    else:\n      loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=target,\n                                                            logits=logits)\n\n    return loss\n\n\ndef summarize_sequence(summary_type, hidden, d_model, n_head, d_head, dropout,\n                       dropatt, input_mask, is_training, initializer,\n                       scope=None, reuse=None, use_proj=True):\n\n  """"""\n      Different classification tasks may not may not share the same parameters\n      to summarize the sequence features.\n\n      If shared, one can keep the `scope` to the default value `None`.\n      Otherwise, one should specify a different `scope` for each task.\n  """"""\n\n  with tf.variable_scope(scope, \'sequnece_summary\', reuse=reuse):\n    if summary_type == \'last\':\n      summary = hidden[-1]\n    elif summary_type == \'first\':\n      summary = hidden[0]\n    elif summary_type == \'mean\':\n      summary = tf.reduce_mean(hidden, axis=0)\n    elif summary_type == \'attn\':\n      bsz = tf.shape(hidden)[1]\n\n      summary_bias = tf.get_variable(\'summary_bias\', [d_model],\n                                     dtype=hidden.dtype,\n                                     initializer=initializer)\n      summary_bias = tf.tile(summary_bias[None, None], [1, bsz, 1])\n\n      if input_mask is not None:\n        input_mask = input_mask[None, :, :, None]\n\n      summary = multihead_attn(summary_bias, hidden, hidden, input_mask,\n                               d_model, n_head, d_head, dropout, dropatt,\n                               is_training, initializer, residual=False)\n      summary = summary[0]\n    else:\n      raise ValueError(\'Unsupported summary type {}\'.format(summary_type))\n\n    # use another projection as in BERT\n    if use_proj:\n      summary = tf.layers.dense(\n          summary,\n          d_model,\n          activation=tf.tanh,\n          kernel_initializer=initializer,\n          name=\'summary\')\n\n    # dropout\n    summary = tf.layers.dropout(\n        summary, dropout, training=is_training,\n        name=\'dropout\')\n\n  return summary\n\n\ndef classification_loss(hidden, labels, n_class, initializer, scope, reuse=None,\n                        return_logits=False):\n  """"""\n      Different classification tasks should use different scope names to ensure\n      different dense layers (parameters) are used to produce the logits.\n\n      An exception will be in transfer learning, where one hopes to transfer\n      the classification weights.\n  """"""\n\n  with tf.variable_scope(scope, reuse=reuse):\n    logits = tf.layers.dense(\n        hidden,\n        n_class,\n        kernel_initializer=initializer,\n        name=\'logit\')\n\n    one_hot_target = tf.one_hot(labels, n_class, dtype=hidden.dtype)\n    loss = -tf.reduce_sum(tf.nn.log_softmax(logits) * one_hot_target, -1)\n\n    if return_logits:\n      return loss, logits\n\n    return loss\n\n\ndef regression_loss(hidden, labels, initializer, scope, reuse=None,\n                    return_logits=False):\n  with tf.variable_scope(scope, reuse=reuse):\n    logits = tf.layers.dense(\n        hidden,\n        1,\n        kernel_initializer=initializer,\n        name=\'logit\')\n\n    logits = tf.squeeze(logits, axis=-1)\n    loss = tf.square(logits - labels)\n\n    if return_logits:\n      return loss, logits\n\n    return loss\n\n'"
src/prepro_utils.py,1,"b'# coding=utf-8\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport unicodedata\nimport six\nfrom functools import partial\n\n\nSPIECE_UNDERLINE = \'\xe2\x96\x81\'\n\n\ndef printable_text(text):\n  """"""Returns text encoded in a way suitable for print or `tf.logging`.""""""\n\n  # These functions want `str` for both Python2 and Python3, but in one case\n  # it\'s a Unicode string and in the other it\'s a byte string.\n  if six.PY3:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, bytes):\n      return text.decode(""utf-8"", ""ignore"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  elif six.PY2:\n    if isinstance(text, str):\n      return text\n    elif isinstance(text, unicode):\n      return text.encode(""utf-8"")\n    else:\n      raise ValueError(""Unsupported string type: %s"" % (type(text)))\n  else:\n    raise ValueError(""Not running on Python2 or Python 3?"")\n\n\ndef print_(*args):\n  new_args = []\n  for arg in args:\n    if isinstance(arg, list):\n      s = [printable_text(i) for i in arg]\n      s = \' \'.join(s)\n      new_args.append(s)\n    else:\n      new_args.append(printable_text(arg))\n  print(*new_args)\n\n\ndef preprocess_text(inputs, lower=False, remove_space=True, keep_accents=False):\n  if remove_space:\n    outputs = \' \'.join(inputs.strip().split())\n  else:\n    outputs = inputs\n  outputs = outputs.replace(""``"", \'""\').replace(""\'\'"", \'""\')\n\n  if six.PY2 and isinstance(outputs, str):\n    outputs = outputs.decode(\'utf-8\')\n\n  if not keep_accents:\n    outputs = unicodedata.normalize(\'NFKD\', outputs)\n    outputs = \'\'.join([c for c in outputs if not unicodedata.combining(c)])\n  if lower:\n    outputs = outputs.lower()\n\n  return outputs\n\n\ndef encode_pieces(sp_model, text, return_unicode=True, sample=False):\n  # return_unicode is used only for py2\n\n  # note(zhiliny): in some systems, sentencepiece only accepts str for py2\n  if six.PY2 and isinstance(text, unicode):\n    text = text.encode(\'utf-8\')\n\n  if not sample:\n    pieces = sp_model.EncodeAsPieces(text)\n  else:\n    pieces = sp_model.SampleEncodeAsPieces(text, 64, 0.1)\n  new_pieces = []\n  for piece in pieces:\n    if len(piece) > 1 and piece[-1] == \',\' and piece[-2].isdigit():\n      cur_pieces = sp_model.EncodeAsPieces(\n          piece[:-1].replace(SPIECE_UNDERLINE, \'\'))\n      if piece[0] != SPIECE_UNDERLINE and cur_pieces[0][0] == SPIECE_UNDERLINE:\n        if len(cur_pieces[0]) == 1:\n          cur_pieces = cur_pieces[1:]\n        else:\n          cur_pieces[0] = cur_pieces[0][1:]\n      cur_pieces.append(piece[-1])\n      new_pieces.extend(cur_pieces)\n    else:\n      new_pieces.append(piece)\n\n  # note(zhiliny): convert back to unicode for py2\n  if six.PY2 and return_unicode:\n    ret_pieces = []\n    for piece in new_pieces:\n      if isinstance(piece, str):\n        piece = piece.decode(\'utf-8\')\n      ret_pieces.append(piece)\n    new_pieces = ret_pieces\n\n  return new_pieces\n\n\ndef encode_ids(sp_model, text, sample=False):\n  pieces = encode_pieces(sp_model, text, return_unicode=False, sample=sample)\n  ids = [sp_model.PieceToId(piece) for piece in pieces]\n  return ids\n\n\nif __name__ == \'__main__\':\n  import sentencepiece as spm\n\n  sp = spm.SentencePieceProcessor()\n  sp.load(\'sp10m.uncased.v3.model\')\n\n  print_(u\'I was born in 2000, and this is fals\xc3\xa9.\')\n  print_(u\'ORIGINAL\', sp.EncodeAsPieces(u\'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print_(u\'OURS\', encode_pieces(sp, u\'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print(encode_ids(sp, u\'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print_(\'\')\n  prepro_func = partial(preprocess_text, lower=True)\n  print_(prepro_func(\'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print_(\'ORIGINAL\', sp.EncodeAsPieces(prepro_func(\'I was born in 2000, and this is fals\xc3\xa9.\')))\n  print_(\'OURS\', encode_pieces(sp, prepro_func(\'I was born in 2000, and this is fals\xc3\xa9.\')))\n  print(encode_ids(sp, prepro_func(\'I was born in 2000, and this is fals\xc3\xa9.\')))\n  print_(\'\')\n  print_(\'I was born in 2000, and this is fals\xc3\xa9.\')\n  print_(\'ORIGINAL\', sp.EncodeAsPieces(\'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print_(\'OURS\', encode_pieces(sp, \'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print(encode_ids(sp, \'I was born in 2000, and this is fals\xc3\xa9.\'))\n  print_(\'\')\n  print_(\'I was born in 92000, and this is fals\xc3\xa9.\')\n  print_(\'ORIGINAL\', sp.EncodeAsPieces(\'I was born in 92000, and this is fals\xc3\xa9.\'))\n  print_(\'OURS\', encode_pieces(sp, \'I was born in 92000, and this is fals\xc3\xa9.\'))\n  print(encode_ids(sp, \'I was born in 92000, and this is fals\xc3\xa9.\'))\n\n'"
src/run_classifier.py,84,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom os.path import join\nfrom absl import flags\nimport os\nimport sys\nimport csv\nimport collections\nimport numpy as np\nimport time\nimport math\nimport json\nimport random\nfrom copy import copy\nfrom collections import defaultdict as dd\n\nimport absl.logging as _logging  # pylint: disable=unused-import\nimport tensorflow as tf\n\nimport sentencepiece as spm\n\nfrom data_utils import SEP_ID, VOCAB_SIZE, CLS_ID\nimport model_utils\nimport function_builder\nfrom classifier_utils import PaddingInputExample\nfrom classifier_utils import convert_single_example\nfrom prepro_utils import preprocess_text, encode_ids\n\n\n# Model\nflags.DEFINE_string(""model_config_path"", default=None,\n      help=""Model config path."")\nflags.DEFINE_float(""dropout"", default=0.1,\n      help=""Dropout rate."")\nflags.DEFINE_float(""dropatt"", default=0.1,\n      help=""Attention dropout rate."")\nflags.DEFINE_integer(""clamp_len"", default=-1,\n      help=""Clamp length"")\nflags.DEFINE_string(""summary_type"", default=""last"",\n      help=""Method used to summarize a sequence into a compact vector."")\nflags.DEFINE_bool(""use_summ_proj"", default=True,\n      help=""Whether to use projection for summarizing sequences."")\nflags.DEFINE_bool(""use_bfloat16"", False,\n      help=""Whether to use bfloat16."")\n\n# Parameter initialization\nflags.DEFINE_enum(""init"", default=""normal"",\n      enum_values=[""normal"", ""uniform""],\n      help=""Initialization method."")\nflags.DEFINE_float(""init_std"", default=0.02,\n      help=""Initialization std when init is normal."")\nflags.DEFINE_float(""init_range"", default=0.1,\n      help=""Initialization std when init is uniform."")\n\n# I/O paths\nflags.DEFINE_bool(""overwrite_data"", default=False,\n      help=""If False, will use cached data if available."")\nflags.DEFINE_string(""init_checkpoint"", default=None,\n      help=""checkpoint path for initializing the model. ""\n      ""Could be a pretrained model or a finetuned model."")\nflags.DEFINE_string(""output_dir"", default="""",\n      help=""Output dir for TF records."")\nflags.DEFINE_string(""spiece_model_file"", default="""",\n      help=""Sentence Piece model path."")\nflags.DEFINE_string(""model_dir"", default="""",\n      help=""Directory for saving the finetuned model."")\nflags.DEFINE_string(""data_dir"", default="""",\n      help=""Directory for input data."")\n\n# TPUs and machines\nflags.DEFINE_bool(""use_tpu"", default=False, help=""whether to use TPU."")\nflags.DEFINE_integer(""num_hosts"", default=1, help=""How many TPU hosts."")\nflags.DEFINE_integer(""num_core_per_host"", default=8,\n      help=""8 for TPU v2 and v3-8, 16 for larger TPU v3 pod. In the context ""\n      ""of GPU training, it refers to the number of GPUs used."")\nflags.DEFINE_string(""tpu_job_name"", default=None, help=""TPU worker job name."")\nflags.DEFINE_string(""tpu"", default=None, help=""TPU name."")\nflags.DEFINE_string(""tpu_zone"", default=None, help=""TPU zone."")\nflags.DEFINE_string(""gcp_project"", default=None, help=""gcp project."")\nflags.DEFINE_string(""master"", default=None, help=""master"")\nflags.DEFINE_integer(""iterations"", default=1000,\n      help=""number of iterations per TPU training loop."")\n\n# training\nflags.DEFINE_bool(""do_train"", default=False, help=""whether to do training"")\nflags.DEFINE_integer(""train_steps"", default=1000,\n      help=""Number of training steps"")\nflags.DEFINE_integer(""num_train_epochs"", default=0,\n      help=""Number of training steps"")\nflags.DEFINE_integer(""warmup_steps"", default=0, help=""number of warmup steps"")\nflags.DEFINE_float(""learning_rate"", default=1e-5, help=""initial learning rate"")\nflags.DEFINE_float(""lr_layer_decay_rate"", 1.0,\n                   ""Top layer: lr[L] = FLAGS.learning_rate.""\n                   ""Low layer: lr[l-1] = lr[l] * lr_layer_decay_rate."")\nflags.DEFINE_float(""min_lr_ratio"", default=0.0,\n      help=""min lr ratio for cos decay."")\nflags.DEFINE_float(""clip"", default=1.0, help=""Gradient clipping"")\nflags.DEFINE_integer(""max_save"", default=0,\n      help=""Max number of checkpoints to save. Use 0 to save all."")\nflags.DEFINE_integer(""save_steps"", default=None,\n      help=""Save the model for every save_steps. ""\n      ""If None, not to save any model."")\nflags.DEFINE_integer(""train_batch_size"", default=8,\n      help=""Batch size for training"")\nflags.DEFINE_float(""weight_decay"", default=0.00, help=""Weight decay rate"")\nflags.DEFINE_float(""adam_epsilon"", default=1e-8, help=""Adam epsilon"")\nflags.DEFINE_string(""decay_method"", default=""poly"", help=""poly or cos"")\n\n# evaluation\nflags.DEFINE_bool(""do_eval"", default=False, help=""whether to do eval"")\nflags.DEFINE_bool(""do_predict"", default=False, help=""whether to do prediction"")\nflags.DEFINE_float(""predict_threshold"", default=0,\n      help=""Threshold for binary prediction."")\nflags.DEFINE_string(""eval_split"", default=""dev"", help=""could be dev or test"")\nflags.DEFINE_integer(""eval_batch_size"", default=128,\n      help=""batch size for evaluation"")\nflags.DEFINE_integer(""predict_batch_size"", default=128,\n      help=""batch size for prediction."")\nflags.DEFINE_string(""predict_dir"", default=None,\n      help=""Dir for saving prediction files."")\nflags.DEFINE_bool(""eval_all_ckpt"", default=False,\n      help=""Eval all ckpts. If False, only evaluate the last one."")\nflags.DEFINE_string(""predict_ckpt"", default=None,\n      help=""Ckpt path for do_predict. If None, use the last one."")\n\n# task specific\nflags.DEFINE_string(""task_name"", default=None, help=""Task name"")\nflags.DEFINE_integer(""max_seq_length"", default=128, help=""Max sequence length"")\nflags.DEFINE_integer(""shuffle_buffer"", default=2048,\n      help=""Buffer size used for shuffle."")\nflags.DEFINE_integer(""num_passes"", default=1,\n      help=""Num passes for processing training data. ""\n      ""This is use to batch data without loss for TPUs."")\nflags.DEFINE_bool(""uncased"", default=False,\n      help=""Use uncased."")\nflags.DEFINE_string(""cls_scope"", default=None,\n      help=""Classifier layer scope."")\nflags.DEFINE_bool(""is_regression"", default=False,\n      help=""Whether it\'s a regression task."")\n\nFLAGS = flags.FLAGS\n\n\nclass InputExample(object):\n  """"""A single training/test example for simple sequence classification.""""""\n\n  def __init__(self, guid, text_a, text_b=None, label=None):\n    """"""Constructs a InputExample.\n    Args:\n      guid: Unique id for the example.\n      text_a: string. The untokenized text of the first sequence. For single\n        sequence tasks, only this sequence must be specified.\n      text_b: (Optional) string. The untokenized text of the second sequence.\n        Only must be specified for sequence pair tasks.\n      label: (Optional) string. The label of the example. This should be\n        specified for train and dev examples, but not for test examples.\n    """"""\n    self.guid = guid\n    self.text_a = text_a\n    self.text_b = text_b\n    self.label = label\n\n\nclass DataProcessor(object):\n  """"""Base class for data converters for sequence classification data sets.""""""\n\n  def get_train_examples(self, data_dir):\n    """"""Gets a collection of `InputExample`s for the train set.""""""\n    raise NotImplementedError()\n\n  def get_dev_examples(self, data_dir):\n    """"""Gets a collection of `InputExample`s for the dev set.""""""\n    raise NotImplementedError()\n\n  def get_test_examples(self, data_dir):\n    """"""Gets a collection of `InputExample`s for prediction.""""""\n    raise NotImplementedError()\n\n  def get_labels(self):\n    """"""Gets the list of labels for this data set.""""""\n    raise NotImplementedError()\n\n  @classmethod\n  def _read_tsv(cls, input_file, quotechar=None):\n    """"""Reads a tab separated value file.""""""\n    with tf.gfile.Open(input_file, ""r"") as f:\n      reader = csv.reader(f, delimiter=""\\t"", quotechar=quotechar)\n      lines = []\n      for line in reader:\n        if len(line) == 0: continue\n        lines.append(line)\n      return lines\n\n\nclass GLUEProcessor(DataProcessor):\n  def __init__(self):\n    self.train_file = ""train.tsv""\n    self.dev_file = ""dev.tsv""\n    self.test_file = ""test.tsv""\n    self.label_column = None\n    self.text_a_column = None\n    self.text_b_column = None\n    self.contains_header = True\n    self.test_text_a_column = None\n    self.test_text_b_column = None\n    self.test_contains_header = True\n\n  def get_train_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_tsv(os.path.join(data_dir, self.train_file)), ""train"")\n\n  def get_dev_examples(self, data_dir):\n    """"""See base class.""""""\n    return self._create_examples(\n        self._read_tsv(os.path.join(data_dir, self.dev_file)), ""dev"")\n\n  def get_test_examples(self, data_dir):\n    """"""See base class.""""""\n    if self.test_text_a_column is None:\n      self.test_text_a_column = self.text_a_column\n    if self.test_text_b_column is None:\n      self.test_text_b_column = self.text_b_column\n\n    return self._create_examples(\n        self._read_tsv(os.path.join(data_dir, self.test_file)), ""test"")\n\n  def get_labels(self):\n    """"""See base class.""""""\n    return [""0"", ""1""]\n\n  def _create_examples(self, lines, set_type):\n    """"""Creates examples for the training and dev sets.""""""\n    examples = []\n    for (i, line) in enumerate(lines):\n      if i == 0 and self.contains_header and set_type != ""test"":\n        continue\n      if i == 0 and self.test_contains_header and set_type == ""test"":\n        continue\n      guid = ""%s-%s"" % (set_type, i)\n\n      a_column = (self.text_a_column if set_type != ""test"" else\n          self.test_text_a_column)\n      b_column = (self.text_b_column if set_type != ""test"" else\n          self.test_text_b_column)\n\n      # there are some incomplete lines in QNLI\n      if len(line) <= a_column:\n        tf.logging.warning(\'Incomplete line, ignored.\')\n        continue\n      text_a = line[a_column]\n\n      if b_column is not None:\n        if len(line) <= b_column:\n          tf.logging.warning(\'Incomplete line, ignored.\')\n          continue\n        text_b = line[b_column]\n      else:\n        text_b = None\n\n      if set_type == ""test"":\n        label = self.get_labels()[0]\n      else:\n        if len(line) <= self.label_column:\n          tf.logging.warning(\'Incomplete line, ignored.\')\n          continue\n        label = line[self.label_column]\n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n    return examples\n\n\nclass Yelp5Processor(DataProcessor):\n  def get_train_examples(self, data_dir):\n    return self._create_examples(os.path.join(data_dir, ""train.csv""))\n\n  def get_dev_examples(self, data_dir):\n    return self._create_examples(os.path.join(data_dir, ""test.csv""))\n\n  def get_labels(self):\n    """"""See base class.""""""\n    return [""1"", ""2"", ""3"", ""4"", ""5""]\n\n  def _create_examples(self, input_file):\n    """"""Creates examples for the training and dev sets.""""""\n    examples = []\n    with tf.gfile.Open(input_file) as f:\n      reader = csv.reader(f)\n      for i, line in enumerate(reader):\n\n        label = line[0]\n        text_a = line[1].replace(\'""""\', \'""\').replace(\'\\\\""\', \'""\')\n        examples.append(\n            InputExample(guid=str(i), text_a=text_a, text_b=None, label=label))\n    return examples\n\n\nclass ImdbProcessor(DataProcessor):\n  def get_labels(self):\n    return [""neg"", ""pos""]\n\n  def get_train_examples(self, data_dir):\n    return self._create_examples(os.path.join(data_dir, ""train""))\n\n  def get_dev_examples(self, data_dir):\n    return self._create_examples(os.path.join(data_dir, ""test""))\n\n  def _create_examples(self, data_dir):\n    examples = []\n    for label in [""neg"", ""pos""]:\n      cur_dir = os.path.join(data_dir, label)\n      for filename in tf.gfile.ListDirectory(cur_dir):\n        if not filename.endswith(""txt""): continue\n\n        path = os.path.join(cur_dir, filename)\n        with tf.gfile.Open(path) as f:\n          text = f.read().strip().replace(""<br />"", "" "")\n        examples.append(InputExample(\n            guid=""unused_id"", text_a=text, text_b=None, label=label))\n    return examples\n\n\nclass MnliMatchedProcessor(GLUEProcessor):\n  def __init__(self):\n    super(MnliMatchedProcessor, self).__init__()\n    self.dev_file = ""dev_matched.tsv""\n    self.test_file = ""test_matched.tsv""\n    self.label_column = -1\n    self.text_a_column = 8\n    self.text_b_column = 9\n\n  def get_labels(self):\n    return [""contradiction"", ""entailment"", ""neutral""]\n\n\nclass XnliProcessor(DataProcessor):\n  def __init__(self):\n    self.language = ""zh""\n\n  def get_train_examples(self, data_dir, set_type=""train""):\n    """"""See base class.""""""\n    train_file = os.path.join(data_dir, ""multinli"",\n                     ""multinli.train.%s.tsv"" % self.language)\n    lines = self._read_tsv(train_file)\n    examples = []\n    for (i, line) in enumerate(lines):\n      if i == 0:\n        continue\n      guid = ""%s-%s"" % (set_type, i)\n      text_a = line[0].replace(\' \',\'\')\n      text_b = line[1].replace(\' \',\'\')\n      label = line[2]\n      if label == ""contradictory"":\n        label = ""contradiction""\n      \n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n    return examples    \n\n  def get_devtest_examples(self, data_dir, set_type=""dev""):\n    """"""See base class.""""""\n    devtest_file = os.path.join(data_dir, ""xnli.""+set_type+"".tsv"")\n    tf.logging.info(""using file %s"" % devtest_file)\n    lines = self._read_tsv(devtest_file)\n    examples = []\n    for (i, line) in enumerate(lines):\n      if i == 0:\n        continue\n      guid = ""%s-%s"" % (set_type, i)\n      language = line[0]\n      if language != self.language:\n        continue\n\n      text_a = line[6].replace(\' \',\'\')\n      text_b = line[7].replace(\' \',\'\')\n      label = line[1]\n      \n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n    return examples\n\n  def get_labels(self):\n    """"""See base class.""""""\n    return [""contradiction"", ""entailment"", ""neutral""]\n\n\n\nclass CSCProcessor(DataProcessor):\n  def get_labels(self):\n    return [""0"", ""1""]\n\n  def get_train_examples(self, data_dir):\n    set_type = ""train""\n    input_file = os.path.join(data_dir, set_type+"".tsv"")\n    tf.logging.info(""using file %s"" % input_file)\n    lines = self._read_tsv(input_file)\n    examples = []\n    for (i, line) in enumerate(lines):\n      if i == 0:\n        continue\n      guid = ""%s-%s"" % (set_type, i)\n\n      text_a = line[1]\n      label = line[0]\n    \n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=None, label=label))\n    return examples\n  \n  def get_devtest_examples(self, data_dir, set_type=""dev""):\n    input_file = os.path.join(data_dir, set_type+"".tsv"")\n    tf.logging.info(""using file %s"" % input_file)\n    lines = self._read_tsv(input_file)\n    examples = []\n    for (i, line) in enumerate(lines):\n      if i == 0:\n        continue\n      guid = ""%s-%s"" % (set_type, i)\n\n      text_a = line[1]\n      label = line[0]\n    \n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=None, label=label))\n    return examples\n\n\nclass CSVProcessor(DataProcessor):\n  def _read_tsv(cls, input_file, quotechar=None):\n    """"""Reads a tab separated value file.""""""\n    with tf.gfile.Open(input_file, ""r"") as f:\n      reader = csv.reader(f)\n      lines = []\n      for line in reader:\n        if len(line) == 0: continue\n        lines.append(line)\n      return lines\n\n  def get_labels(self):\n    return [""0"", ""1""]\n\n  def get_train_examples(self, data_dir):\n    set_type = ""train""\n    input_file = os.path.join(data_dir, set_type + "".csv"")\n    tf.logging.info(""using file %s"" % input_file)\n    lines = self._read_tsv(input_file)\n    examples = []\n    for (i, line) in enumerate(lines):\n      if i == 0:\n        continue\n      guid = ""%s-%s"" % (set_type, i)\n\n      text_a = line[0]\n      label = line[1]\n\n      examples.append(\n        InputExample(guid=guid, text_a=text_a, text_b=None, label=label))\n    return examples\n\n  def get_devtest_examples(self, data_dir, set_type=""dev""):\n    input_file = os.path.join(data_dir, set_type + "".csv"")\n    tf.logging.info(""using file %s"" % input_file)\n    lines = self._read_tsv(input_file)\n    examples = []\n    for (i, line) in enumerate(lines):\n      if i == 0:\n        continue\n      guid = ""%s-%s"" % (set_type, i)\n\n      text_a = line[0]\n      label = line[1]\n\n      examples.append(\n        InputExample(guid=guid, text_a=text_a, text_b=None, label=label))\n    return examples\n\n\nclass MnliMismatchedProcessor(MnliMatchedProcessor):\n  def __init__(self):\n    super(MnliMismatchedProcessor, self).__init__()\n    self.dev_file = ""dev_mismatched.tsv""\n    self.test_file = ""test_mismatched.tsv""\n\n\nclass StsbProcessor(GLUEProcessor):\n  def __init__(self):\n    super(StsbProcessor, self).__init__()\n    self.label_column = 9\n    self.text_a_column = 7\n    self.text_b_column = 8\n\n  def get_labels(self):\n    return [0.0]\n\n  def _create_examples(self, lines, set_type):\n    """"""Creates examples for the training and dev sets.""""""\n    examples = []\n    for (i, line) in enumerate(lines):\n      if i == 0 and self.contains_header and set_type != ""test"":\n        continue\n      if i == 0 and self.test_contains_header and set_type == ""test"":\n        continue\n      guid = ""%s-%s"" % (set_type, i)\n\n      a_column = (self.text_a_column if set_type != ""test"" else\n          self.test_text_a_column)\n      b_column = (self.text_b_column if set_type != ""test"" else\n          self.test_text_b_column)\n\n      # there are some incomplete lines in QNLI\n      if len(line) <= a_column:\n        tf.logging.warning(\'Incomplete line, ignored.\')\n        continue\n      text_a = line[a_column]\n\n      if b_column is not None:\n        if len(line) <= b_column:\n          tf.logging.warning(\'Incomplete line, ignored.\')\n          continue\n        text_b = line[b_column]\n      else:\n        text_b = None\n\n      if set_type == ""test"":\n        label = self.get_labels()[0]\n      else:\n        if len(line) <= self.label_column:\n          tf.logging.warning(\'Incomplete line, ignored.\')\n          continue\n        label = float(line[self.label_column])\n      examples.append(\n          InputExample(guid=guid, text_a=text_a, text_b=text_b, label=label))\n\n    return examples\n\n\ndef file_based_convert_examples_to_features(\n    examples, label_list, max_seq_length, tokenize_fn, output_file,\n    num_passes=1):\n  """"""Convert a set of `InputExample`s to a TFRecord file.""""""\n\n  # do not create duplicated records\n  if tf.gfile.Exists(output_file) and not FLAGS.overwrite_data:\n    tf.logging.info(""Do not overwrite tfrecord {} exists."".format(output_file))\n    return\n\n  tf.logging.info(""Create new tfrecord {}."".format(output_file))\n\n  writer = tf.python_io.TFRecordWriter(output_file)\n\n  if num_passes > 1:\n    examples *= num_passes\n\n  for (ex_index, example) in enumerate(examples):\n    if ex_index % 10000 == 0:\n      tf.logging.info(""Writing example {} of {}"".format(ex_index,\n                                                        len(examples)))\n\n    feature = convert_single_example(ex_index, example, label_list,\n                                     max_seq_length, tokenize_fn)\n\n    def create_int_feature(values):\n      f = tf.train.Feature(int64_list=tf.train.Int64List(value=list(values)))\n      return f\n\n    def create_float_feature(values):\n      f = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_float_feature(feature.input_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n    if label_list is not None:\n      features[""label_ids""] = create_int_feature([feature.label_id])\n    else:\n      features[""label_ids""] = create_float_feature([float(feature.label_id)])\n    features[""is_real_example""] = create_int_feature(\n        [int(feature.is_real_example)])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    writer.write(tf_example.SerializeToString())\n  writer.close()\n\n\ndef file_based_input_fn_builder(input_file, seq_length, is_training,\n                                drop_remainder):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n\n  name_to_features = {\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.float32),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""label_ids"": tf.FixedLenFeature([], tf.int64),\n      ""is_real_example"": tf.FixedLenFeature([], tf.int64),\n  }\n  if FLAGS.is_regression:\n    name_to_features[""label_ids""] = tf.FixedLenFeature([], tf.float32)\n\n  tf.logging.info(""Input tfrecord file {}"".format(input_file))\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.cast(t, tf.int32)\n      example[name] = t\n\n    return example\n\n  def input_fn(params, input_context=None):\n    """"""The actual input function.""""""\n    if FLAGS.use_tpu:\n      batch_size = params[""batch_size""]\n    elif is_training:\n      batch_size = FLAGS.train_batch_size\n    elif FLAGS.do_eval:\n      batch_size = FLAGS.eval_batch_size\n    else:\n      batch_size = FLAGS.predict_batch_size\n\n    d = tf.data.TFRecordDataset(input_file)\n    # Shard the dataset to difference devices\n    if input_context is not None:\n      tf.logging.info(""Input pipeline id %d out of %d"",\n          input_context.input_pipeline_id, input_context.num_replicas_in_sync)\n      d = d.shard(input_context.num_input_pipelines,\n                  input_context.input_pipeline_id)\n\n    # For training, we want a lot of parallel reading and shuffling.\n    # For eval, we want no shuffling and parallel reading doesn\'t matter.\n    if is_training:\n      d = d.shuffle(buffer_size=FLAGS.shuffle_buffer)\n      d = d.repeat()\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            drop_remainder=drop_remainder))\n\n    return d\n\n  return input_fn\n\n\ndef get_model_fn(n_class):\n  def model_fn(features, labels, mode, params):\n    #### Training or Evaluation\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    #### Get loss from inputs\n    if FLAGS.is_regression:\n      (total_loss, per_example_loss, logits\n          ) = function_builder.get_regression_loss(FLAGS, features, is_training)\n    else:\n      (total_loss, per_example_loss, logits\n          ) = function_builder.get_classification_loss(\n          FLAGS, features, n_class, is_training)\n\n    #### Check model parameters\n    num_params = sum([np.prod(v.shape) for v in tf.trainable_variables()])\n    tf.logging.info(\'#params: {}\'.format(num_params))\n\n    #### load pretrained models\n    scaffold_fn = model_utils.init_from_checkpoint(FLAGS)\n\n    #### Evaluation mode\n    if mode == tf.estimator.ModeKeys.EVAL:\n      assert FLAGS.num_hosts == 1\n\n      def metric_fn(per_example_loss, label_ids, logits, is_real_example):\n        predictions = tf.argmax(logits, axis=-1, output_type=tf.int32)\n        eval_input_dict = {\n            \'labels\': label_ids,\n            \'predictions\': predictions,\n            \'weights\': is_real_example\n        }\n        accuracy = tf.metrics.accuracy(**eval_input_dict)\n\n        loss = tf.metrics.mean(values=per_example_loss, weights=is_real_example)\n        return {\n            \'eval_accuracy\': accuracy,\n            \'eval_loss\': loss}\n\n      def regression_metric_fn(\n          per_example_loss, label_ids, logits, is_real_example):\n        loss = tf.metrics.mean(values=per_example_loss, weights=is_real_example)\n        pearsonr = tf.contrib.metrics.streaming_pearson_correlation(\n            logits, label_ids, weights=is_real_example)\n        return {\'eval_loss\': loss, \'eval_pearsonr\': pearsonr}\n\n      is_real_example = tf.cast(features[""is_real_example""], dtype=tf.float32)\n\n      #### Constucting evaluation TPUEstimatorSpec with new cache.\n      label_ids = tf.reshape(features[\'label_ids\'], [-1])\n\n      if FLAGS.is_regression:\n        metric_fn = regression_metric_fn\n      else:\n        metric_fn = metric_fn\n      metric_args = [per_example_loss, label_ids, logits, is_real_example]\n\n      if FLAGS.use_tpu:\n        eval_spec = tf.contrib.tpu.TPUEstimatorSpec(\n            mode=mode,\n            loss=total_loss,\n            eval_metrics=(metric_fn, metric_args),\n            scaffold_fn=scaffold_fn)\n      else:\n        eval_spec = tf.estimator.EstimatorSpec(\n            mode=mode,\n            loss=total_loss,\n            eval_metric_ops=metric_fn(*metric_args))\n\n      return eval_spec\n\n    elif mode == tf.estimator.ModeKeys.PREDICT:\n      label_ids = tf.reshape(features[""label_ids""], [-1])\n\n      predictions = {\n          ""logits"": logits,\n          ""labels"": label_ids,\n          ""is_real"": features[""is_real_example""]\n      }\n\n      if FLAGS.use_tpu:\n        output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n            mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n      else:\n        output_spec = tf.estimator.EstimatorSpec(\n            mode=mode, predictions=predictions)\n      return output_spec\n\n    #### Configuring the optimizer\n    train_op, learning_rate, _ = model_utils.get_train_op(FLAGS, total_loss)\n\n    monitor_dict = {}\n    monitor_dict[""lr""] = learning_rate\n\n    #### Constucting training TPUEstimatorSpec with new cache.\n    if FLAGS.use_tpu:\n      #### Creating host calls\n      if not FLAGS.is_regression:\n        label_ids = tf.reshape(features[\'label_ids\'], [-1])\n        predictions = tf.argmax(logits, axis=-1, output_type=label_ids.dtype)\n        is_correct = tf.equal(predictions, label_ids)\n        accuracy = tf.reduce_mean(tf.cast(is_correct, tf.float32))\n\n        monitor_dict[""accuracy""] = accuracy\n\n        host_call = function_builder.construct_scalar_host_call(\n            monitor_dict=monitor_dict,\n            model_dir=FLAGS.model_dir,\n            prefix=""train/"",\n            reduce_fn=tf.reduce_mean)\n      else:\n        host_call = None\n\n      train_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, loss=total_loss, train_op=train_op, host_call=host_call,\n          scaffold_fn=scaffold_fn)\n    else:\n      train_spec = tf.estimator.EstimatorSpec(\n          mode=mode, loss=total_loss, train_op=train_op)\n\n    return train_spec\n\n  return model_fn\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  #### Validate flags\n  if FLAGS.save_steps is not None:\n    FLAGS.iterations = min(FLAGS.iterations, FLAGS.save_steps)\n\n  if FLAGS.do_predict:\n    predict_dir = FLAGS.predict_dir\n    if not tf.gfile.Exists(predict_dir):\n      tf.gfile.MakeDirs(predict_dir)\n\n  processors = {\n      ""mnli_matched"": MnliMatchedProcessor,\n      ""mnli_mismatched"": MnliMismatchedProcessor,\n      \'sts-b\': StsbProcessor,\n      \'imdb\': ImdbProcessor,\n      ""yelp5"": Yelp5Processor,\n      ""xnli"": XnliProcessor,\n      ""csc"": CSCProcessor,\n      ""csv"": CSVProcessor,\n  }\n\n  if not FLAGS.do_train and not FLAGS.do_eval and not FLAGS.do_predict:\n    raise ValueError(\n        ""At least one of `do_train`, `do_eval, `do_predict` or ""\n        ""`do_submit` must be True."")\n\n  if not tf.gfile.Exists(FLAGS.output_dir):\n    tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  task_name = FLAGS.task_name.lower()\n\n  if task_name not in processors:\n    raise ValueError(""Task not found: %s"" % (task_name))\n\n  processor = processors[task_name]()\n  label_list = processor.get_labels() if not FLAGS.is_regression else None\n\n  sp = spm.SentencePieceProcessor()\n  sp.Load(FLAGS.spiece_model_file)\n  def tokenize_fn(text):\n    text = preprocess_text(text, lower=FLAGS.uncased)\n    return encode_ids(sp, text)\n\n  run_config = model_utils.configure_tpu(FLAGS)\n\n  model_fn = get_model_fn(len(label_list) if label_list is not None else None)\n\n  spm_basename = os.path.basename(FLAGS.spiece_model_file)\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  if FLAGS.use_tpu:\n    estimator = tf.contrib.tpu.TPUEstimator(\n        use_tpu=FLAGS.use_tpu,\n        model_fn=model_fn,\n        config=run_config,\n        train_batch_size=FLAGS.train_batch_size,\n        predict_batch_size=FLAGS.predict_batch_size,\n        eval_batch_size=FLAGS.eval_batch_size)\n  else:\n    estimator = tf.estimator.Estimator(\n        model_fn=model_fn,\n        config=run_config)\n\n  if FLAGS.do_train:\n    train_file_base = ""{}.len-{}.train.tf_record"".format(\n        spm_basename, FLAGS.max_seq_length)\n    train_file = os.path.join(FLAGS.output_dir, train_file_base)\n    tf.logging.info(""Use tfrecord file {}"".format(train_file))\n\n    train_examples = processor.get_train_examples(FLAGS.data_dir)\n    np.random.shuffle(train_examples)\n    tf.logging.info(""Num of train samples: {}"".format(len(train_examples)))\n\n    file_based_convert_examples_to_features(\n        train_examples, label_list, FLAGS.max_seq_length, tokenize_fn,\n        train_file, FLAGS.num_passes)\n\n    # here we use epoch number to calculate total train_steps\n    FLAGS.train_steps = int(len(train_examples) * FLAGS.num_train_epochs / FLAGS.train_batch_size)\n    FLAGS.warmup_steps = int(0.1 * FLAGS.train_steps)\n\n    train_input_fn = file_based_input_fn_builder(\n        input_file=train_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True)\n\n    estimator.train(input_fn=train_input_fn, max_steps=FLAGS.train_steps)\n\n  if FLAGS.do_eval or FLAGS.do_predict:\n    eval_examples = processor.get_devtest_examples(FLAGS.data_dir, FLAGS.eval_split)\n    tf.logging.info(""Num of eval samples: {}"".format(len(eval_examples)))\n\n  if FLAGS.do_eval:\n    # TPU requires a fixed batch size for all batches, therefore the number\n    # of examples must be a multiple of the batch size, or else examples\n    # will get dropped. So we pad with fake examples which are ignored\n    # later on. These do NOT count towards the metric (all tf.metrics\n    # support a per-instance weight, and these get a weight of 0.0).\n    #\n    # Modified in XL: We also adopt the same mechanism for GPUs.\n    while len(eval_examples) % FLAGS.eval_batch_size != 0:\n      eval_examples.append(PaddingInputExample())\n\n    eval_file_base = ""{}.len-{}.{}.eval.tf_record"".format(\n        spm_basename, FLAGS.max_seq_length, FLAGS.eval_split)\n    eval_file = os.path.join(FLAGS.output_dir, eval_file_base)\n\n    file_based_convert_examples_to_features(\n        eval_examples, label_list, FLAGS.max_seq_length, tokenize_fn,\n        eval_file)\n\n    assert len(eval_examples) % FLAGS.eval_batch_size == 0\n    eval_steps = int(len(eval_examples) // FLAGS.eval_batch_size)\n\n    eval_input_fn = file_based_input_fn_builder(\n        input_file=eval_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=True)\n\n    # Filter out all checkpoints in the directory\n    steps_and_files = []\n    filenames = tf.gfile.ListDirectory(FLAGS.model_dir)\n\n    for filename in filenames:\n      if filename.endswith("".index""):\n        ckpt_name = filename[:-6]\n        tf.logging.info(f""ckpt_name: {ckpt_name}"")\n        cur_filename = join(FLAGS.model_dir, ckpt_name)\n        step = cur_filename.split(""-"")[-1]\n        if step.isdigit():\n          global_step = int(step)\n          tf.logging.info(""Add {} to eval list."".format(cur_filename))\n          steps_and_files.append([global_step, cur_filename])\n    steps_and_files = sorted(steps_and_files, key=lambda x: x[0])\n\n    # Decide whether to evaluate all ckpts\n    if not FLAGS.eval_all_ckpt:\n      steps_and_files = steps_and_files[-1:]\n\n    eval_results = []\n    for global_step, filename in sorted(steps_and_files, key=lambda x: x[0]):\n      ret = estimator.evaluate(\n          input_fn=eval_input_fn,\n          steps=eval_steps,\n          checkpoint_path=filename)\n\n      ret[""step""] = global_step\n      ret[""path""] = filename\n\n      eval_results.append(ret)\n\n      tf.logging.info(""="" * 80)\n      log_str = ""Eval result | ""\n      for key, val in sorted(ret.items(), key=lambda x: x[0]):\n        log_str += ""{} {} | "".format(key, val)\n      tf.logging.info(log_str)\n\n    key_name = ""eval_pearsonr"" if FLAGS.is_regression else ""eval_accuracy""\n    eval_results.sort(key=lambda x: x[key_name], reverse=True)\n\n    tf.logging.info(""="" * 80)\n    log_str = ""Best result | ""\n    for key, val in sorted(eval_results[0].items(), key=lambda x: x[0]):\n      log_str += ""{} {} | "".format(key, val)\n    tf.logging.info(log_str)\n\n  if FLAGS.do_predict:\n    eval_file_base = ""{}.len-{}.{}.predict.tf_record"".format(\n        spm_basename, FLAGS.max_seq_length, FLAGS.eval_split)\n    eval_file = os.path.join(FLAGS.output_dir, eval_file_base)\n\n    file_based_convert_examples_to_features(\n        eval_examples, label_list, FLAGS.max_seq_length, tokenize_fn,\n        eval_file)\n\n    pred_input_fn = file_based_input_fn_builder(\n        input_file=eval_file,\n        seq_length=FLAGS.max_seq_length,\n        is_training=False,\n        drop_remainder=False)\n\n    predict_results = []\n    with tf.gfile.Open(os.path.join(predict_dir, ""{}.tsv"".format(\n        task_name)), ""w"") as fout:\n      fout.write(""index\\tprediction\\n"")\n\n      for pred_cnt, result in enumerate(estimator.predict(\n          input_fn=pred_input_fn,\n          yield_single_examples=True,\n          checkpoint_path=FLAGS.predict_ckpt)):\n        if pred_cnt % 1000 == 0:\n          tf.logging.info(""Predicting submission for example: {}"".format(\n              pred_cnt))\n\n        logits = [float(x) for x in result[""logits""].flat]\n        predict_results.append(logits)\n\n        if len(logits) == 1:\n          label_out = logits[0]\n        elif len(logits) == 2:\n          if logits[1] - logits[0] > FLAGS.predict_threshold:\n            label_out = label_list[1]\n          else:\n            label_out = label_list[0]\n        elif len(logits) > 2:\n          max_index = np.argmax(np.array(logits, dtype=np.float32))\n          label_out = label_list[max_index]\n        else:\n          raise NotImplementedError\n\n        fout.write(""{}\\t{}\\n"".format(pred_cnt, label_out))\n\n    predict_json_path = os.path.join(predict_dir, ""{}.logits.json"".format(\n        task_name))\n\n    with tf.gfile.Open(predict_json_path, ""w"") as fp:\n      json.dump(predict_results, fp, indent=4)\n\n\nif __name__ == ""__main__"":\n  tf.app.run()\n\n'"
src/run_cmrc_drcd.py,83,"b'# coding=utf-8\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl import flags\nimport absl.logging as _logging  # pylint: disable=unused-import\n\nimport collections\nimport os\nimport time\nimport math\nimport json\nimport six\nimport random\nimport gc\n\nimport numpy as np\n\nif six.PY2:\n  import cPickle as pickle\nelse:\n  import pickle\n\nimport tensorflow as tf\nimport sentencepiece as spm\nfrom prepro_utils import preprocess_text, encode_ids, encode_pieces, printable_text\nimport function_builder\nimport model_utils\nimport squad_utils\nfrom data_utils import SEP_ID, CLS_ID, VOCAB_SIZE\n\nSPIECE_UNDERLINE = u\'\xe2\x96\x81\'\n\nSEG_ID_P   = 0\nSEG_ID_Q   = 1\nSEG_ID_CLS = 2\nSEG_ID_PAD = 3\n\n# Preprocessing\nflags.DEFINE_bool(""do_prepro"", default=False,\n      help=""Perform preprocessing only."")\nflags.DEFINE_integer(""num_proc"", default=1,\n      help=""Number of preprocessing processes."")\nflags.DEFINE_integer(""proc_id"", default=0,\n      help=""Process id for preprocessing."")\n\n# Model\nflags.DEFINE_string(""model_config_path"", default=None,\n      help=""Model config path."")\nflags.DEFINE_float(""dropout"", default=0.1,\n      help=""Dropout rate."")\nflags.DEFINE_float(""dropatt"", default=0.1,\n      help=""Attention dropout rate."")\nflags.DEFINE_integer(""clamp_len"", default=-1,\n      help=""Clamp length."")\nflags.DEFINE_string(""summary_type"", default=""last"",\n      help=""Method used to summarize a sequence into a vector."")\nflags.DEFINE_bool(""use_bfloat16"", default=False,\n      help=""Whether to use bfloat16."")\n\n# Parameter initialization\nflags.DEFINE_enum(""init"", default=""normal"",\n                  enum_values=[""normal"", ""uniform""],\n                  help=""Initialization method."")\nflags.DEFINE_float(""init_std"", default=0.02,\n                   help=""Initialization std when init is normal."")\nflags.DEFINE_float(""init_range"", default=0.1,\n                   help=""Initialization std when init is uniform."")\n\n# I/O paths\nflags.DEFINE_bool(""overwrite_data"", default=False,\n                  help=""If False, will use cached data if available."")\nflags.DEFINE_string(""init_checkpoint"", default=None,\n                    help=""checkpoint path for initializing the model. ""\n                    ""Could be a pretrained model or a finetuned model."")\nflags.DEFINE_bool(""init_global_vars"", default=False,\n                  help=""If true, init all global vars. If false, init ""\n                  ""trainable vars only."")\nflags.DEFINE_string(""output_dir"", default="""",\n                    help=""Output dir for TF records."")\nflags.DEFINE_string(""predict_dir"", default="""",\n                    help=""Dir for predictions."")\nflags.DEFINE_string(""spiece_model_file"", default="""",\n                    help=""Sentence Piece model path."")\nflags.DEFINE_string(""model_dir"", default="""",\n                    help=""Directory for saving the finetuned model."")\nflags.DEFINE_string(""train_file"", default="""",\n                    help=""Path of train file."")\nflags.DEFINE_string(""predict_file"", default="""",\n                    help=""Path of prediction file."")\n\n# Data preprocessing config\nflags.DEFINE_integer(""max_seq_length"",\n                     default=512, help=""Max sequence length"")\nflags.DEFINE_integer(""max_query_length"",\n                     default=64, help=""Max query length"")\nflags.DEFINE_integer(""doc_stride"",\n                     default=128, help=""Doc stride"")\nflags.DEFINE_integer(""max_answer_length"",\n                     default=64, help=""Max answer length"")\nflags.DEFINE_bool(""uncased"", default=False, help=""Use uncased data."")\n\n# TPUs and machines\nflags.DEFINE_bool(""use_tpu"", default=False, help=""whether to use TPU."")\nflags.DEFINE_integer(""num_hosts"", default=1, help=""How many TPU hosts."")\nflags.DEFINE_integer(""num_core_per_host"", default=8,\n      help=""8 for TPU v2 and v3-8, 16 for larger TPU v3 pod. In the context ""\n      ""of GPU training, it refers to the number of GPUs used."")\nflags.DEFINE_string(""tpu_job_name"", default=None, help=""TPU worker job name."")\nflags.DEFINE_string(""tpu"", default=None, help=""TPU name."")\nflags.DEFINE_string(""tpu_zone"", default=None, help=""TPU zone."")\nflags.DEFINE_string(""gcp_project"", default=None, help=""gcp project."")\nflags.DEFINE_string(""master"", default=None, help=""master"")\nflags.DEFINE_integer(""iterations"", default=1000,\n                     help=""number of iterations per TPU training loop."")\n\n# Training\nflags.DEFINE_bool(""do_train"", default=True, help=""whether to do training"")\nflags.DEFINE_integer(""train_batch_size"", default=48,\n                     help=""batch size for training"")\nflags.DEFINE_integer(""train_steps"", default=8000,\n                     help=""Number of training steps"")\nflags.DEFINE_integer(""warmup_steps"", default=0, help=""number of warmup steps"")\nflags.DEFINE_integer(""save_steps"", default=None,\n                     help=""Save the model for every save_steps. ""\n                     ""If None, not to save any model."")\nflags.DEFINE_integer(""max_save"", default=5,\n                     help=""Max number of checkpoints to save. ""\n                     ""Use 0 to save all."")\nflags.DEFINE_integer(""shuffle_buffer"", default=2048,\n                     help=""Buffer size used for shuffle."")\n\n# Optimization\nflags.DEFINE_float(""learning_rate"", default=3e-5, help=""initial learning rate"")\nflags.DEFINE_float(""min_lr_ratio"", default=0.0,\n                   help=""min lr ratio for cos decay."")\nflags.DEFINE_float(""clip"", default=1.0, help=""Gradient clipping"")\nflags.DEFINE_float(""weight_decay"", default=0.00, help=""Weight decay rate"")\nflags.DEFINE_float(""adam_epsilon"", default=1e-6, help=""Adam epsilon"")\nflags.DEFINE_string(""decay_method"", default=""poly"", help=""poly or cos"")\nflags.DEFINE_float(""lr_layer_decay_rate"", default=0.75,\n                   help=""Top layer: lr[L] = FLAGS.learning_rate.""\n                   ""Lower layers: lr[l-1] = lr[l] * lr_layer_decay_rate."")\n\n# Eval / Prediction\nflags.DEFINE_bool(""do_predict"", default=False, help=""whether to do predict"")\nflags.DEFINE_integer(""predict_batch_size"", default=32,\n                     help=""batch size for prediction"")\nflags.DEFINE_integer(""n_best_size"", default=5,\n                     help=""n best size for predictions"")\nflags.DEFINE_integer(""start_n_top"", default=5, help=""Beam size for span start."")\nflags.DEFINE_integer(""end_n_top"", default=5, help=""Beam size for span end."")\nflags.DEFINE_string(""target_eval_key"", default=""best_f1"",\n                    help=""Use has_ans_f1 for Model I."")\n\n\nFLAGS = flags.FLAGS\n\n\nclass SquadExample(object):\n  """"""A single training/test example for simple sequence classification.\n\n     For examples without an answer, the start and end position are -1.\n  """"""\n\n  def __init__(self,\n               qas_id,\n               question_text,\n               paragraph_text,\n               orig_answer_text=None,\n               start_position=None,\n               is_impossible=False):\n    self.qas_id = qas_id\n    self.question_text = question_text\n    self.paragraph_text = paragraph_text\n    self.orig_answer_text = orig_answer_text\n    self.start_position = start_position\n    self.is_impossible = is_impossible\n\n  def __str__(self):\n    return self.__repr__()\n\n  def __repr__(self):\n    s = """"\n    s += ""qas_id: %s"" % (printable_text(self.qas_id))\n    s += "", question_text: %s"" % (\n        printable_text(self.question_text))\n    s += "", paragraph_text: [%s]"" % ("" "".join(self.paragraph_text))\n    if self.start_position:\n      s += "", start_position: %d"" % (self.start_position)\n    if self.start_position:\n      s += "", is_impossible: %r"" % (self.is_impossible)\n    return s\n\n\nclass InputFeatures(object):\n  """"""A single set of features of data.""""""\n\n  def __init__(self,\n               unique_id,\n               example_index,\n               doc_span_index,\n               tok_start_to_orig_index,\n               tok_end_to_orig_index,\n               token_is_max_context,\n               input_ids,\n               input_mask,\n               p_mask,\n               segment_ids,\n               paragraph_len,\n               cls_index,\n               start_position=None,\n               end_position=None,\n               is_impossible=None):\n    self.unique_id = unique_id\n    self.example_index = example_index\n    self.doc_span_index = doc_span_index\n    self.tok_start_to_orig_index = tok_start_to_orig_index\n    self.tok_end_to_orig_index = tok_end_to_orig_index\n    self.token_is_max_context = token_is_max_context\n    self.input_ids = input_ids\n    self.input_mask = input_mask\n    self.p_mask = p_mask\n    self.segment_ids = segment_ids\n    self.paragraph_len = paragraph_len\n    self.cls_index = cls_index\n    self.start_position = start_position\n    self.end_position = end_position\n    self.is_impossible = is_impossible\n\n\ndef read_squad_examples(input_file, is_training):\n  """"""Read a SQuAD json file into a list of SquadExample.""""""\n  with tf.gfile.Open(input_file, ""r"") as reader:\n    input_data = json.load(reader)[""data""]\n\n  examples = []\n  for entry in input_data:\n    for paragraph in entry[""paragraphs""]:\n      paragraph_text = paragraph[""context""]\n\n      for qa in paragraph[""qas""]:\n        qas_id = qa[""id""]\n        question_text = qa[""question""]\n        start_position = None\n        orig_answer_text = None\n        is_impossible = False\n\n        if is_training:\n          if ""is_impossible"" in qa:\n            is_impossible = qa[""is_impossible""]\n          else:\n            is_impossible = False\n          if (len(qa[""answers""]) != 1) and (not is_impossible):\n            raise ValueError(\n                ""For training, each question should have exactly 1 answer."")\n          if not is_impossible:\n            answer = qa[""answers""][0]\n            orig_answer_text = answer[""text""]\n            start_position = answer[""answer_start""]\n          else:\n            start_position = -1\n            orig_answer_text = """"\n\n        example = SquadExample(\n            qas_id=qas_id,\n            question_text=question_text,\n            paragraph_text=paragraph_text,\n            orig_answer_text=orig_answer_text,\n            start_position=start_position,\n            is_impossible=is_impossible)\n        examples.append(example)\n\n  return examples\n\n\ndef _convert_index(index, pos, M=None, is_start=True):\n  if pos >= len(index):\n    pos = len(index) - 1\n  if index[pos] is not None:\n    return index[pos]\n  N = len(index)\n  rear = pos\n  while rear < N - 1 and index[rear] is None:\n    rear += 1\n  front = pos\n  while front > 0 and index[front] is None:\n    front -= 1\n  assert index[front] is not None or index[rear] is not None\n  if index[front] is None:\n    if index[rear] >= 1:\n      if is_start:\n        return 0\n      else:\n        return index[rear] - 1\n    return index[rear]\n  if index[rear] is None:\n    if M is not None and index[front] < M - 1:\n      if is_start:\n        return index[front] + 1\n      else:\n        return M - 1\n    return index[front]\n  if is_start:\n    if index[rear] > index[front] + 1:\n      return index[front] + 1\n    else:\n      return index[rear]\n  else:\n    if index[rear] > index[front] + 1:\n      return index[rear] - 1\n    else:\n      return index[front]\n\n\ndef convert_examples_to_features(examples, sp_model, max_seq_length,\n                                 doc_stride, max_query_length, is_training,\n                                 output_fn):\n  """"""Loads a data file into a list of `InputBatch`s.""""""\n\n  cnt_pos, cnt_neg = 0, 0\n  unique_id = 1000000000\n  max_N, max_M = 1024, 1024\n  f = np.zeros((max_N, max_M), dtype=np.float32)\n\n  for (example_index, example) in enumerate(examples):\n\n    if example_index % 100 == 0:\n      tf.logging.info(\'Converting {}/{} pos {} neg {}\'.format(\n          example_index, len(examples), cnt_pos, cnt_neg))\n\n    query_tokens = encode_ids(\n        sp_model,\n        preprocess_text(example.question_text, lower=FLAGS.uncased))\n\n    if len(query_tokens) > max_query_length:\n      query_tokens = query_tokens[0:max_query_length]\n\n    paragraph_text = example.paragraph_text\n    para_tokens = encode_pieces(\n        sp_model,\n        preprocess_text(example.paragraph_text, lower=FLAGS.uncased))\n\n    chartok_to_tok_index = []\n    tok_start_to_chartok_index = []\n    tok_end_to_chartok_index = []\n    char_cnt = 0\n    for i, token in enumerate(para_tokens):\n      chartok_to_tok_index.extend([i] * len(token))\n      tok_start_to_chartok_index.append(char_cnt)\n      char_cnt += len(token)\n      tok_end_to_chartok_index.append(char_cnt - 1)\n\n    tok_cat_text = \'\'.join(para_tokens).replace(SPIECE_UNDERLINE, \' \')\n    N, M = len(paragraph_text), len(tok_cat_text)\n\n    if N > max_N or M > max_M:\n      max_N = max(N, max_N)\n      max_M = max(M, max_M)\n      f = np.zeros((max_N, max_M), dtype=np.float32)\n      gc.collect()\n\n    g = {}\n\n    def _lcs_match(max_dist):\n      f.fill(0)\n      g.clear()\n\n      ### longest common sub sequence\n      # f[i, j] = max(f[i - 1, j], f[i, j - 1], f[i - 1, j - 1] + match(i, j))\n      for i in range(N):\n\n        # note(zhiliny):\n        # unlike standard LCS, this is specifically optimized for the setting\n        # because the mismatch between sentence pieces and original text will\n        # be small\n        for j in range(i - max_dist, i + max_dist):\n          if j >= M or j < 0: continue\n\n          if i > 0:\n            g[(i, j)] = 0\n            f[i, j] = f[i - 1, j]\n\n          if j > 0 and f[i, j - 1] > f[i, j]:\n            g[(i, j)] = 1\n            f[i, j] = f[i, j - 1]\n\n          f_prev = f[i - 1, j - 1] if i > 0 and j > 0 else 0\n          if (preprocess_text(paragraph_text[i], lower=FLAGS.uncased,\n              remove_space=False)\n              == tok_cat_text[j]\n              and f_prev + 1 > f[i, j]):\n            g[(i, j)] = 2\n            f[i, j] = f_prev + 1\n\n    max_dist = abs(N - M) + 5\n    for _ in range(2):\n      _lcs_match(max_dist)\n      if f[N - 1, M - 1] > 0.8 * N: break\n      max_dist *= 2\n\n    orig_to_chartok_index = [None] * N\n    chartok_to_orig_index = [None] * M\n    i, j = N - 1, M - 1\n    while i >= 0 and j >= 0:\n      if (i, j) not in g: break\n      if g[(i, j)] == 2:\n        orig_to_chartok_index[i] = j\n        chartok_to_orig_index[j] = i\n        i, j = i - 1, j - 1\n      elif g[(i, j)] == 1:\n        j = j - 1\n      else:\n        i = i - 1\n\n    if all(v is None for v in orig_to_chartok_index) or f[N - 1, M - 1] < 0.8 * N:\n      print(\'MISMATCH DETECTED!\')\n      continue\n\n    tok_start_to_orig_index = []\n    tok_end_to_orig_index = []\n    for i in range(len(para_tokens)):\n      start_chartok_pos = tok_start_to_chartok_index[i]\n      end_chartok_pos = tok_end_to_chartok_index[i]\n      start_orig_pos = _convert_index(chartok_to_orig_index, start_chartok_pos,\n                                      N, is_start=True)\n      end_orig_pos = _convert_index(chartok_to_orig_index, end_chartok_pos,\n                                    N, is_start=False)\n\n      tok_start_to_orig_index.append(start_orig_pos)\n      tok_end_to_orig_index.append(end_orig_pos)\n\n    if not is_training:\n      tok_start_position = tok_end_position = None\n\n    if is_training and example.is_impossible:\n      tok_start_position = -1\n      tok_end_position = -1\n\n    if is_training and not example.is_impossible:\n      start_position = example.start_position\n      end_position = start_position + len(example.orig_answer_text) - 1\n\n      start_chartok_pos = _convert_index(orig_to_chartok_index, start_position,\n                                         is_start=True)\n      tok_start_position = chartok_to_tok_index[start_chartok_pos]\n\n      end_chartok_pos = _convert_index(orig_to_chartok_index, end_position,\n                                       is_start=False)\n      tok_end_position = chartok_to_tok_index[end_chartok_pos]\n      assert tok_start_position <= tok_end_position\n\n    def _piece_to_id(x):\n      if six.PY2 and isinstance(x, unicode):\n        x = x.encode(\'utf-8\')\n      return sp_model.PieceToId(x)\n\n    all_doc_tokens = list(map(_piece_to_id, para_tokens))\n\n    # The -3 accounts for [CLS], [SEP] and [SEP]\n    max_tokens_for_doc = max_seq_length - len(query_tokens) - 3\n\n    # We can have documents that are longer than the maximum sequence length.\n    # To deal with this we do a sliding window approach, where we take chunks\n    # of the up to our max length with a stride of `doc_stride`.\n    _DocSpan = collections.namedtuple(  # pylint: disable=invalid-name\n        ""DocSpan"", [""start"", ""length""])\n    doc_spans = []\n    start_offset = 0\n    while start_offset < len(all_doc_tokens):\n      length = len(all_doc_tokens) - start_offset\n      if length > max_tokens_for_doc:\n        length = max_tokens_for_doc\n      doc_spans.append(_DocSpan(start=start_offset, length=length))\n      if start_offset + length == len(all_doc_tokens):\n        break\n      start_offset += min(length, doc_stride)\n\n    for (doc_span_index, doc_span) in enumerate(doc_spans):\n      tokens = []\n      token_is_max_context = {}\n      segment_ids = []\n      p_mask = []\n\n      cur_tok_start_to_orig_index = []\n      cur_tok_end_to_orig_index = []\n\n      for i in range(doc_span.length):\n        split_token_index = doc_span.start + i\n\n        cur_tok_start_to_orig_index.append(\n            tok_start_to_orig_index[split_token_index])\n        cur_tok_end_to_orig_index.append(\n            tok_end_to_orig_index[split_token_index])\n\n        is_max_context = _check_is_max_context(doc_spans, doc_span_index,\n                                               split_token_index)\n        token_is_max_context[len(tokens)] = is_max_context\n        tokens.append(all_doc_tokens[split_token_index])\n        segment_ids.append(SEG_ID_P)\n        p_mask.append(0)\n\n      paragraph_len = len(tokens)\n\n      tokens.append(SEP_ID)\n      segment_ids.append(SEG_ID_P)\n      p_mask.append(1)\n\n      # note(zhiliny): we put P before Q\n      # because during pretraining, B is always shorter than A\n      for token in query_tokens:\n        tokens.append(token)\n        segment_ids.append(SEG_ID_Q)\n        p_mask.append(1)\n      tokens.append(SEP_ID)\n      segment_ids.append(SEG_ID_Q)\n      p_mask.append(1)\n\n      cls_index = len(segment_ids)\n      tokens.append(CLS_ID)\n      segment_ids.append(SEG_ID_CLS)\n      p_mask.append(0)\n\n      input_ids = tokens\n\n      # The mask has 0 for real tokens and 1 for padding tokens. Only real\n      # tokens are attended to.\n      input_mask = [0] * len(input_ids)\n\n      # Zero-pad up to the sequence length.\n      while len(input_ids) < max_seq_length:\n        input_ids.append(0)\n        input_mask.append(1)\n        segment_ids.append(SEG_ID_PAD)\n        p_mask.append(1)\n\n      assert len(input_ids) == max_seq_length\n      assert len(input_mask) == max_seq_length\n      assert len(segment_ids) == max_seq_length\n      assert len(p_mask) == max_seq_length\n\n      span_is_impossible = example.is_impossible\n      start_position = None\n      end_position = None\n      if is_training and not span_is_impossible:\n        # For training, if our document chunk does not contain an annotation\n        # we throw it out, since there is nothing to predict.\n        doc_start = doc_span.start\n        doc_end = doc_span.start + doc_span.length - 1\n        out_of_span = False\n        if not (tok_start_position >= doc_start and\n                tok_end_position <= doc_end):\n          out_of_span = True\n        if out_of_span:\n          # continue\n          start_position = 0\n          end_position = 0\n          span_is_impossible = True\n        else:\n          # note(zhiliny): we put P before Q, so doc_offset should be zero.\n          # doc_offset = len(query_tokens) + 2\n          doc_offset = 0\n          start_position = tok_start_position - doc_start + doc_offset\n          end_position = tok_end_position - doc_start + doc_offset\n\n      if is_training and span_is_impossible:\n        start_position = cls_index\n        end_position = cls_index\n\n      if example_index < 20:\n        tf.logging.info(""*** Example ***"")\n        tf.logging.info(""unique_id: %s"" % (unique_id))\n        tf.logging.info(""example_index: %s"" % (example_index))\n        tf.logging.info(""doc_span_index: %s"" % (doc_span_index))\n        tf.logging.info(""tok_start_to_orig_index: %s"" % "" "".join(\n            [str(x) for x in cur_tok_start_to_orig_index]))\n        tf.logging.info(""tok_end_to_orig_index: %s"" % "" "".join(\n            [str(x) for x in cur_tok_end_to_orig_index]))\n        tf.logging.info(""token_is_max_context: %s"" % "" "".join([\n            ""%d:%s"" % (x, y) for (x, y) in six.iteritems(token_is_max_context)\n        ]))\n        tf.logging.info(""input_ids: %s"" % "" "".join([str(x) for x in input_ids]))\n        tf.logging.info(\n            ""input_mask: %s"" % "" "".join([str(x) for x in input_mask]))\n        tf.logging.info(\n            ""segment_ids: %s"" % "" "".join([str(x) for x in segment_ids]))\n\n        if is_training and span_is_impossible:\n          tf.logging.info(""impossible example span"")\n\n        if is_training and not span_is_impossible:\n          pieces = [sp_model.IdToPiece(token) for token in\n                    tokens[start_position: (end_position + 1)]]\n          answer_text = sp_model.DecodePieces(pieces)\n          tf.logging.info(""start_position: %d"" % (start_position))\n          tf.logging.info(""end_position: %d"" % (end_position))\n          tf.logging.info(\n              ""answer: %s"" % (printable_text(answer_text)))\n\n          # note(zhiliny): With multi processing,\n          # the example_index is actually the index within the current process\n          # therefore we use example_index=None to avoid being used in the future.\n          # The current code does not use example_index of training data.\n      if is_training:\n        feat_example_index = None\n      else:\n        feat_example_index = example_index\n\n      feature = InputFeatures(\n          unique_id=unique_id,\n          example_index=feat_example_index,\n          doc_span_index=doc_span_index,\n          tok_start_to_orig_index=cur_tok_start_to_orig_index,\n          tok_end_to_orig_index=cur_tok_end_to_orig_index,\n          token_is_max_context=token_is_max_context,\n          input_ids=input_ids,\n          input_mask=input_mask,\n          p_mask=p_mask,\n          segment_ids=segment_ids,\n          paragraph_len=paragraph_len,\n          cls_index=cls_index,\n          start_position=start_position,\n          end_position=end_position,\n          is_impossible=span_is_impossible)\n\n      # Run callback\n      output_fn(feature)\n\n      unique_id += 1\n      if span_is_impossible:\n        cnt_neg += 1\n      else:\n        cnt_pos += 1\n\n  tf.logging.info(""Total number of instances: {} = pos {} neg {}"".format(\n      cnt_pos + cnt_neg, cnt_pos, cnt_neg))\n\n\ndef _check_is_max_context(doc_spans, cur_span_index, position):\n  """"""Check if this is the \'max context\' doc span for the token.""""""\n\n  # Because of the sliding window approach taken to scoring documents, a single\n  # token can appear in multiple documents. E.g.\n  #  Doc: the man went to the store and bought a gallon of milk\n  #  Span A: the man went to the\n  #  Span B: to the store and bought\n  #  Span C: and bought a gallon of\n  #  ...\n  #\n  # Now the word \'bought\' will have two scores from spans B and C. We only\n  # want to consider the score with ""maximum context"", which we define as\n  # the *minimum* of its left and right context (the *sum* of left and\n  # right context will always be the same, of course).\n  #\n  # In the example the maximum context for \'bought\' would be span C since\n  # it has 1 left context and 3 right context, while span B has 4 left context\n  # and 0 right context.\n  best_score = None\n  best_span_index = None\n  for (span_index, doc_span) in enumerate(doc_spans):\n    end = doc_span.start + doc_span.length - 1\n    if position < doc_span.start:\n      continue\n    if position > end:\n      continue\n    num_left_context = position - doc_span.start\n    num_right_context = end - position\n    score = min(num_left_context, num_right_context) + 0.01 * doc_span.length\n    if best_score is None or score > best_score:\n      best_score = score\n      best_span_index = span_index\n\n  return cur_span_index == best_span_index\n\n\nclass FeatureWriter(object):\n  """"""Writes InputFeature to TF example file.""""""\n\n  def __init__(self, filename, is_training):\n    self.filename = filename\n    self.is_training = is_training\n    self.num_features = 0\n    self._writer = tf.python_io.TFRecordWriter(filename)\n\n  def process_feature(self, feature):\n    """"""Write a InputFeature to the TFRecordWriter as a tf.train.Example.""""""\n    self.num_features += 1\n\n    def create_int_feature(values):\n      feature = tf.train.Feature(\n          int64_list=tf.train.Int64List(value=list(values)))\n      return feature\n\n    def create_float_feature(values):\n      f = tf.train.Feature(float_list=tf.train.FloatList(value=list(values)))\n      return f\n\n    features = collections.OrderedDict()\n    features[""unique_ids""] = create_int_feature([feature.unique_id])\n    features[""input_ids""] = create_int_feature(feature.input_ids)\n    features[""input_mask""] = create_float_feature(feature.input_mask)\n    features[""p_mask""] = create_float_feature(feature.p_mask)\n    features[""segment_ids""] = create_int_feature(feature.segment_ids)\n\n    features[""cls_index""] = create_int_feature([feature.cls_index])\n\n    if self.is_training:\n      features[""start_positions""] = create_int_feature([feature.start_position])\n      features[""end_positions""] = create_int_feature([feature.end_position])\n      impossible = 0\n      if feature.is_impossible:\n        impossible = 1\n      features[""is_impossible""] = create_float_feature([impossible])\n\n    tf_example = tf.train.Example(features=tf.train.Features(feature=features))\n    self._writer.write(tf_example.SerializeToString())\n\n  def close(self):\n    self._writer.close()\n\n\nRawResult = collections.namedtuple(""RawResult"",\n    [""unique_id"", ""start_top_log_probs"", ""start_top_index"",\n    ""end_top_log_probs"", ""end_top_index""])\n\n_PrelimPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n    ""PrelimPrediction"",\n    [""feature_index"", ""start_index"", ""end_index"",\n    ""start_log_prob"", ""end_log_prob""])\n\n_NbestPrediction = collections.namedtuple(  # pylint: disable=invalid-name\n    ""NbestPrediction"", [""text"", ""start_log_prob"", ""end_log_prob""])\n\ndef write_predictions(all_examples, all_features, all_results, n_best_size,\n                      max_answer_length, output_prediction_file,\n                      output_nbest_file,\n                      orig_data):\n  """"""Write final predictions to the json file and log-odds of null if needed.""""""\n  tf.logging.info(""Writing predictions to: %s"" % (output_prediction_file))\n  # tf.logging.info(""Writing nbest to: %s"" % (output_nbest_file))\n\n  example_index_to_features = collections.defaultdict(list)\n  for feature in all_features:\n    example_index_to_features[feature.example_index].append(feature)\n\n  unique_id_to_result = {}\n  for result in all_results:\n    unique_id_to_result[result.unique_id] = result\n\n  all_predictions = collections.OrderedDict()\n  all_nbest_json = collections.OrderedDict()\n  scores_diff_json = collections.OrderedDict()\n\n  for (example_index, example) in enumerate(all_examples):\n    features = example_index_to_features[example_index]\n\n    prelim_predictions = []\n    # keep track of the minimum score of null start+end of position 0\n    for (feature_index, feature) in enumerate(features):\n      result = unique_id_to_result[feature.unique_id]\n\n      for i in range(FLAGS.start_n_top):\n        for j in range(FLAGS.end_n_top):\n          start_log_prob = result.start_top_log_probs[i]\n          start_index = result.start_top_index[i]\n\n          j_index = i * FLAGS.end_n_top + j\n\n          end_log_prob = result.end_top_log_probs[j_index]\n          end_index = result.end_top_index[j_index]\n\n          # We could hypothetically create invalid predictions, e.g., predict\n          # that the start of the span is in the question. We throw out all\n          # invalid predictions.\n          if start_index >= feature.paragraph_len - 1:\n            continue\n          if end_index >= feature.paragraph_len - 1:\n            continue\n\n          if not feature.token_is_max_context.get(start_index, False):\n            continue\n          if end_index < start_index:\n            continue\n          length = end_index - start_index + 1\n          if length > max_answer_length:\n            continue\n\n          prelim_predictions.append(\n              _PrelimPrediction(\n                  feature_index=feature_index,\n                  start_index=start_index,\n                  end_index=end_index,\n                  start_log_prob=start_log_prob,\n                  end_log_prob=end_log_prob))\n\n    prelim_predictions = sorted(\n        prelim_predictions,\n        key=lambda x: (x.start_log_prob + x.end_log_prob),\n        reverse=True)\n\n    seen_predictions = {}\n    nbest = []\n    for pred in prelim_predictions:\n      if len(nbest) >= n_best_size:\n        break\n      feature = features[pred.feature_index]\n\n      tok_start_to_orig_index = feature.tok_start_to_orig_index\n      tok_end_to_orig_index = feature.tok_end_to_orig_index\n      start_orig_pos = tok_start_to_orig_index[pred.start_index]\n      end_orig_pos = tok_end_to_orig_index[pred.end_index]\n\n      paragraph_text = example.paragraph_text\n      final_text = paragraph_text[start_orig_pos: end_orig_pos + 1].strip()\n\n      if final_text in seen_predictions:\n        continue\n\n      seen_predictions[final_text] = True\n\n      nbest.append(\n          _NbestPrediction(\n              text=final_text,\n              start_log_prob=pred.start_log_prob,\n              end_log_prob=pred.end_log_prob))\n\n    # In very rare edge cases we could have no valid predictions. So we\n    # just create a nonce prediction in this case to avoid failure.\n    if not nbest:\n      nbest.append(\n          _NbestPrediction(text="""", start_log_prob=-1e6,\n          end_log_prob=-1e6))\n\n    total_scores = []\n    best_non_null_entry = None\n    for entry in nbest:\n      total_scores.append(entry.start_log_prob + entry.end_log_prob)\n      if not best_non_null_entry:\n        best_non_null_entry = entry\n\n    probs = _compute_softmax(total_scores)\n\n    nbest_json = []\n    for (i, entry) in enumerate(nbest):\n      output = collections.OrderedDict()\n      output[""text""] = entry.text\n      output[""probability""] = probs[i]\n      output[""start_log_prob""] = entry.start_log_prob\n      output[""end_log_prob""] = entry.end_log_prob\n      nbest_json.append(output)\n\n    assert len(nbest_json) >= 1\n    assert best_non_null_entry is not None\n\n    score_diff = 0 #score_null\n    scores_diff_json[example.qas_id] = score_diff\n    # note(zhiliny): always predict best_non_null_entry\n    # and the evaluation script will search for the best threshold\n    all_predictions[example.qas_id] = best_non_null_entry.text\n\n    all_nbest_json[example.qas_id] = nbest_json\n\n  with tf.gfile.GFile(output_prediction_file, ""w"") as writer:\n    writer.write(json.dumps(all_predictions, indent=4) + ""\\n"")\n\n  with tf.gfile.GFile(output_nbest_file, ""w"") as writer:\n    writer.write(json.dumps(all_nbest_json, indent=4) + ""\\n"")\n\n  qid_to_has_ans = squad_utils.make_qid_to_has_ans(orig_data)\n  has_ans_qids = [k for k, v in qid_to_has_ans.items() if v]\n  no_ans_qids = [k for k, v in qid_to_has_ans.items() if not v]\n  exact_raw, f1_raw = squad_utils.get_raw_scores(orig_data, all_predictions)\n  out_eval = {}\n\n  squad_utils.find_all_best_thresh_v2(out_eval, all_predictions, exact_raw, f1_raw,\n                                   scores_diff_json, qid_to_has_ans)\n\n  return out_eval\n\n\ndef _get_best_indexes(logits, n_best_size):\n  """"""Get the n-best logits from a list.""""""\n  index_and_score = sorted(enumerate(logits), key=lambda x: x[1], reverse=True)\n\n  best_indexes = []\n  for i in range(len(index_and_score)):\n    if i >= n_best_size:\n      break\n    best_indexes.append(index_and_score[i][0])\n  return best_indexes\n\n\ndef _compute_softmax(scores):\n  """"""Compute softmax probability over raw logits.""""""\n  if not scores:\n    return []\n\n  max_score = None\n  for score in scores:\n    if max_score is None or score > max_score:\n      max_score = score\n\n  exp_scores = []\n  total_sum = 0.0\n  for score in scores:\n    x = math.exp(score - max_score)\n    exp_scores.append(x)\n    total_sum += x\n\n  probs = []\n  for score in exp_scores:\n    probs.append(score / total_sum)\n  return probs\n\n\ndef input_fn_builder(input_glob, seq_length, is_training, drop_remainder,\n                     num_hosts, num_threads=8):\n  """"""Creates an `input_fn` closure to be passed to TPUEstimator.""""""\n\n  name_to_features = {\n      ""unique_ids"": tf.FixedLenFeature([], tf.int64),\n      ""input_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""input_mask"": tf.FixedLenFeature([seq_length], tf.float32),\n      ""segment_ids"": tf.FixedLenFeature([seq_length], tf.int64),\n      ""cls_index"": tf.FixedLenFeature([], tf.int64),\n      ""p_mask"": tf.FixedLenFeature([seq_length], tf.float32)\n  }\n\n  if is_training:\n    name_to_features[""start_positions""] = tf.FixedLenFeature([], tf.int64)\n    name_to_features[""end_positions""] = tf.FixedLenFeature([], tf.int64)\n    name_to_features[""is_impossible""] = tf.FixedLenFeature([], tf.float32)\n\n  tf.logging.info(""Input tfrecord file glob {}"".format(input_glob))\n  global_input_paths = tf.gfile.Glob(input_glob)\n  tf.logging.info(""Find {} input paths {}"".format(\n      len(global_input_paths), global_input_paths))\n\n  def _decode_record(record, name_to_features):\n    """"""Decodes a record to a TensorFlow example.""""""\n    example = tf.parse_single_example(record, name_to_features)\n\n    # tf.Example only supports tf.int64, but the TPU only supports tf.int32.\n    # So cast all int64 to int32.\n    for name in list(example.keys()):\n      t = example[name]\n      if t.dtype == tf.int64:\n        t = tf.cast(t, tf.int32)\n      example[name] = t\n\n    return example\n\n  def input_fn(params):\n    """"""The actual input function.""""""\n    if FLAGS.use_tpu:\n      batch_size = params[""batch_size""]\n    elif is_training:\n      batch_size = FLAGS.train_batch_size\n    else:\n      batch_size = FLAGS.predict_batch_size\n\n    # Split tfrecords across hosts\n    if num_hosts > 1:\n      host_id = params[""context""].current_host\n      num_files = len(global_input_paths)\n      if num_files >= num_hosts:\n        num_files_per_host = (num_files + num_hosts - 1) // num_hosts\n        my_start_file_id = host_id * num_files_per_host\n        my_end_file_id = min((host_id + 1) * num_files_per_host, num_files)\n        input_paths = global_input_paths[my_start_file_id: my_end_file_id]\n      tf.logging.info(""Host {} handles {} files"".format(host_id,\n                                                        len(input_paths)))\n    else:\n      input_paths = global_input_paths\n\n    if len(input_paths) == 1:\n      d = tf.data.TFRecordDataset(input_paths[0])\n      # For training, we want a lot of parallel reading and shuffling.\n      # For eval, we want no shuffling and parallel reading doesn\'t matter.\n      if is_training:\n        d = d.shuffle(buffer_size=FLAGS.shuffle_buffer)\n        d = d.repeat()\n    else:\n      d = tf.data.Dataset.from_tensor_slices(input_paths)\n      # file level shuffle\n      d = d.shuffle(len(input_paths)).repeat()\n\n      # `cycle_length` is the number of parallel files that get read.\n      cycle_length = min(num_threads, len(input_paths))\n\n      d = d.apply(\n          tf.contrib.data.parallel_interleave(\n              tf.data.TFRecordDataset,\n              sloppy=is_training,\n              cycle_length=cycle_length))\n\n      if is_training:\n        # sample level shuffle\n        d = d.shuffle(buffer_size=FLAGS.shuffle_buffer)\n\n    d = d.apply(\n        tf.contrib.data.map_and_batch(\n            lambda record: _decode_record(record, name_to_features),\n            batch_size=batch_size,\n            num_parallel_batches=num_threads,\n            drop_remainder=drop_remainder))\n    d = d.prefetch(1024)\n\n    return d\n\n  return input_fn\n\n\ndef get_model_fn():\n  def model_fn(features, labels, mode, params):\n    #### Training or Evaluation\n    is_training = (mode == tf.estimator.ModeKeys.TRAIN)\n\n    #### Get loss from inputs\n    outputs = function_builder.get_qa_outputs(FLAGS, features, is_training)\n\n    #### Check model parameters\n    num_params = sum([np.prod(v.shape) for v in tf.trainable_variables()])\n    tf.logging.info(\'#params: {}\'.format(num_params))\n\n    scaffold_fn = None\n\n    #### Evaluation mode\n    if mode == tf.estimator.ModeKeys.PREDICT:\n      if FLAGS.init_checkpoint:\n        tf.logging.info(""init_checkpoint not being used in predict mode."")\n\n      predictions = {\n          ""unique_ids"": features[""unique_ids""],\n          ""start_top_index"": outputs[""start_top_index""],\n          ""start_top_log_probs"": outputs[""start_top_log_probs""],\n          ""end_top_index"": outputs[""end_top_index""],\n          ""end_top_log_probs"": outputs[""end_top_log_probs""]\n      }\n\n      if FLAGS.use_tpu:\n        output_spec = tf.contrib.tpu.TPUEstimatorSpec(\n            mode=mode, predictions=predictions, scaffold_fn=scaffold_fn)\n      else:\n        output_spec = tf.estimator.EstimatorSpec(\n            mode=mode, predictions=predictions)\n      return output_spec\n\n    ### Compute loss\n    seq_length = tf.shape(features[""input_ids""])[1]\n    def compute_loss(log_probs, positions):\n      one_hot_positions = tf.one_hot(\n          positions, depth=seq_length, dtype=tf.float32)\n\n      loss = - tf.reduce_sum(one_hot_positions * log_probs, axis=-1)\n      loss = tf.reduce_mean(loss)\n      return loss\n\n    start_loss = compute_loss(\n        outputs[""start_log_probs""], features[""start_positions""])\n    end_loss = compute_loss(\n        outputs[""end_log_probs""], features[""end_positions""])\n\n    total_loss = (start_loss + end_loss) * 0.5\n\n    #### Configuring the optimizer\n    train_op, learning_rate, _ = model_utils.get_train_op(FLAGS, total_loss)\n\n    monitor_dict = {}\n    monitor_dict[""lr""] = learning_rate\n\n    #### load pretrained models\n    scaffold_fn = model_utils.init_from_checkpoint(FLAGS)\n\n    #### Constucting training TPUEstimatorSpec with new cache.\n    if FLAGS.use_tpu:\n      host_call = function_builder.construct_scalar_host_call(\n          monitor_dict=monitor_dict,\n          model_dir=FLAGS.model_dir,\n          prefix=""train/"",\n          reduce_fn=tf.reduce_mean)\n\n      train_spec = tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode, loss=total_loss, train_op=train_op, host_call=host_call,\n          scaffold_fn=scaffold_fn)\n    else:\n      train_spec = tf.estimator.EstimatorSpec(\n          mode=mode, loss=total_loss, train_op=train_op)\n\n    return train_spec\n\n  return model_fn\n\n\ndef _get_spm_basename():\n  spm_basename = os.path.basename(FLAGS.spiece_model_file)\n  return spm_basename\n\n\ndef preprocess():\n  sp_model = spm.SentencePieceProcessor()\n  sp_model.Load(FLAGS.spiece_model_file)\n  spm_basename = _get_spm_basename()\n\n  train_rec_file = os.path.join(\n      FLAGS.output_dir,\n      ""{}.{}.slen-{}.qlen-{}.train.tf_record"".format(\n          spm_basename, FLAGS.proc_id, FLAGS.max_seq_length,\n          FLAGS.max_query_length))\n\n  tf.logging.info(""Read examples from {}"".format(FLAGS.train_file))\n  train_examples = read_squad_examples(FLAGS.train_file, is_training=True)\n  train_examples = train_examples[FLAGS.proc_id::FLAGS.num_proc]\n\n  # Pre-shuffle the input to avoid having to make a very large shuffle\n  # buffer in the `input_fn`.\n  random.shuffle(train_examples)\n\n  tf.logging.info(""Write to {}"".format(train_rec_file))\n  train_writer = FeatureWriter(\n      filename=train_rec_file,\n      is_training=True)\n  convert_examples_to_features(\n      examples=train_examples,\n      sp_model=sp_model,\n      max_seq_length=FLAGS.max_seq_length,\n      doc_stride=FLAGS.doc_stride,\n      max_query_length=FLAGS.max_query_length,\n      is_training=True,\n      output_fn=train_writer.process_feature)\n  train_writer.close()\n\n\ndef main(_):\n  tf.logging.set_verbosity(tf.logging.INFO)\n\n  if not tf.gfile.Exists(FLAGS.output_dir):\n    tf.gfile.MakeDirs(FLAGS.output_dir)\n\n  if FLAGS.do_prepro:\n    preprocess()\n    return\n\n  #### Validate flags\n  if FLAGS.save_steps is not None:\n    FLAGS.iterations = min(FLAGS.iterations, FLAGS.save_steps)\n\n  if not FLAGS.do_train and not FLAGS.do_predict:\n    raise ValueError(\n        ""At least one of `do_train` and `do_predict` must be True."")\n\n  if FLAGS.do_predict and not tf.gfile.Exists(FLAGS.predict_dir):\n    tf.gfile.MakeDirs(FLAGS.predict_dir)\n\n  sp_model = spm.SentencePieceProcessor()\n  sp_model.Load(FLAGS.spiece_model_file)\n\n  ### TPU Configuration\n  run_config = model_utils.configure_tpu(FLAGS)\n\n  model_fn = get_model_fn()\n  spm_basename = _get_spm_basename()\n\n  # If TPU is not available, this will fall back to normal Estimator on CPU\n  # or GPU.\n  if FLAGS.use_tpu:\n    estimator = tf.contrib.tpu.TPUEstimator(\n        use_tpu=FLAGS.use_tpu,\n        model_fn=model_fn,\n        config=run_config,\n        train_batch_size=FLAGS.train_batch_size,\n        predict_batch_size=FLAGS.predict_batch_size)\n  else:\n    estimator = tf.estimator.Estimator(\n        model_fn=model_fn,\n        config=run_config)\n\n  if FLAGS.do_train:\n    train_rec_glob = os.path.join(\n        FLAGS.output_dir,\n        ""{}.*.slen-{}.qlen-{}.train.tf_record"".format(\n        spm_basename, FLAGS.max_seq_length,\n        FLAGS.max_query_length))\n\n    train_input_fn = input_fn_builder(\n        input_glob=train_rec_glob,\n        seq_length=FLAGS.max_seq_length,\n        is_training=True,\n        drop_remainder=True,\n        num_hosts=FLAGS.num_hosts)\n\n    estimator.train(input_fn=train_input_fn, max_steps=FLAGS.train_steps)\n\n  if FLAGS.do_predict:\n    for eval_set in [\'dev\',\'test\',\'challenge\']:\n      new_predict_file = FLAGS.predict_file + ""_"" + eval_set + "".json""\n\n      eval_examples = read_squad_examples(new_predict_file, is_training=False)\n\n      with tf.gfile.Open(new_predict_file) as f:\n        orig_data = json.load(f)[""data""]\n\n      eval_rec_file = os.path.join(\n          FLAGS.output_dir,\n          ""{}.slen-{}.qlen-{}.{}.tf_record"".format(\n              spm_basename, FLAGS.max_seq_length, FLAGS.max_query_length, eval_set))\n      eval_feature_file = os.path.join(\n          FLAGS.output_dir,\n          ""{}.slen-{}.qlen-{}.{}.features.pkl"".format(\n              spm_basename, FLAGS.max_seq_length, FLAGS.max_query_length, eval_set))\n\n      if tf.gfile.Exists(eval_rec_file) and tf.gfile.Exists(\n          eval_feature_file) and not FLAGS.overwrite_data:\n        tf.logging.info(""Loading eval features from {}"".format(eval_feature_file))\n        with tf.gfile.Open(eval_feature_file, \'rb\') as fin:\n          eval_features = pickle.load(fin)\n      else:\n        eval_writer = FeatureWriter(filename=eval_rec_file, is_training=False)\n        eval_features = []\n\n        def append_feature(feature):\n          eval_features.append(feature)\n          eval_writer.process_feature(feature)\n\n        convert_examples_to_features(\n            examples=eval_examples,\n            sp_model=sp_model,\n            max_seq_length=FLAGS.max_seq_length,\n            doc_stride=FLAGS.doc_stride,\n            max_query_length=FLAGS.max_query_length,\n            is_training=False,\n            output_fn=append_feature)\n        eval_writer.close()\n\n        with tf.gfile.Open(eval_feature_file, \'wb\') as fout:\n          pickle.dump(eval_features, fout)\n\n      eval_input_fn = input_fn_builder(\n          input_glob=eval_rec_file,\n          seq_length=FLAGS.max_seq_length,\n          is_training=False,\n          drop_remainder=False,\n          num_hosts=1)\n\n      cur_results = []\n      for result in estimator.predict(\n          input_fn=eval_input_fn,\n          yield_single_examples=True):\n\n        if len(cur_results) % 1000 == 0:\n          tf.logging.info(""Processing example: %d"" % (len(cur_results)))\n\n        unique_id = int(result[""unique_ids""])\n        start_top_log_probs = (\n            [float(x) for x in result[""start_top_log_probs""].flat])\n        start_top_index = [int(x) for x in result[""start_top_index""].flat]\n        end_top_log_probs = (\n            [float(x) for x in result[""end_top_log_probs""].flat])\n        end_top_index = [int(x) for x in result[""end_top_index""].flat]\n\n\n        cur_results.append(\n            RawResult(\n                unique_id=unique_id,\n                start_top_log_probs=start_top_log_probs,\n                start_top_index=start_top_index,\n                end_top_log_probs=end_top_log_probs,\n                end_top_index=end_top_index))\n\n      output_prediction_file = os.path.join(\n          FLAGS.predict_dir, eval_set+""_predictions.json"")\n      output_nbest_file = os.path.join(\n          FLAGS.predict_dir, eval_set+""_nbest_predictions.json"")\n\n      ret = write_predictions(eval_examples, eval_features, cur_results,\n                              FLAGS.n_best_size, FLAGS.max_answer_length,\n                              output_prediction_file,\n                              output_nbest_file,\n                              orig_data)\n\n      # Log current result\n      tf.logging.info(""="" * 80)\n      log_str = ""Result | ""\n      for key, val in ret.items():\n        log_str += ""{} {} | "".format(key, val)\n      tf.logging.info(log_str)\n      tf.logging.info(""="" * 80)\n\n\nif __name__ == ""__main__"":\n  tf.app.run()\n\n'"
src/squad_utils.py,0,"b'""""""Official evaluation script for SQuAD version 2.0.\n\nIn addition to basic functionality, we also compute additional statistics and\nplot precision-recall curves if an additional na_prob.json file is provided.\nThis file is expected to map question ID\'s to the model\'s predicted probability\nthat a question is unanswerable.\n""""""\nimport argparse\nimport collections\nimport json\nimport numpy as np\nimport os\nimport re\nimport string\nimport sys\n\nOPTS = None\n\ndef parse_args():\n  parser = argparse.ArgumentParser(\'Official evaluation script for SQuAD version 2.0.\')\n  parser.add_argument(\'data_file\', metavar=\'data.json\', help=\'Input data JSON file.\')\n  parser.add_argument(\'pred_file\', metavar=\'pred.json\', help=\'Model predictions.\')\n  parser.add_argument(\'--out-file\', \'-o\', metavar=\'eval.json\',\n                      help=\'Write accuracy metrics to file (default is stdout).\')\n  parser.add_argument(\'--na-prob-file\', \'-n\', metavar=\'na_prob.json\',\n                      help=\'Model estimates of probability of no answer.\')\n  parser.add_argument(\'--na-prob-thresh\', \'-t\', type=float, default=1.0,\n                      help=\'Predict """" if no-answer probability exceeds this (default = 1.0).\')\n  parser.add_argument(\'--out-image-dir\', \'-p\', metavar=\'out_images\', default=None,\n                      help=\'Save precision-recall curves to directory.\')\n  parser.add_argument(\'--verbose\', \'-v\', action=\'store_true\')\n  if len(sys.argv) == 1:\n    parser.print_help()\n    sys.exit(1)\n  return parser.parse_args()\n\ndef make_qid_to_has_ans(dataset):\n  qid_to_has_ans = {}\n  for article in dataset:\n    for p in article[\'paragraphs\']:\n      for qa in p[\'qas\']:\n        qid_to_has_ans[qa[\'id\']] = bool(qa[\'answers\'])\n  return qid_to_has_ans\n\ndef normalize_answer(s):\n  """"""Lower text and remove punctuation, articles and extra whitespace.""""""\n  def remove_articles(text):\n    regex = re.compile(r\'\\b(a|an|the)\\b\', re.UNICODE)\n    return re.sub(regex, \' \', text)\n  def white_space_fix(text):\n    return \' \'.join(text.split())\n  def remove_punc(text):\n    exclude = set(string.punctuation)\n    return \'\'.join(ch for ch in text if ch not in exclude)\n  def lower(text):\n    return text.lower()\n  return white_space_fix(remove_articles(remove_punc(lower(s))))\n\ndef get_tokens(s):\n  if not s: return []\n  return normalize_answer(s).split()\n\ndef compute_exact(a_gold, a_pred):\n  return int(normalize_answer(a_gold) == normalize_answer(a_pred))\n\ndef compute_f1(a_gold, a_pred):\n  gold_toks = get_tokens(a_gold)\n  pred_toks = get_tokens(a_pred)\n  common = collections.Counter(gold_toks) & collections.Counter(pred_toks)\n  num_same = sum(common.values())\n  if len(gold_toks) == 0 or len(pred_toks) == 0:\n    # If either is no-answer, then F1 is 1 if they agree, 0 otherwise\n    return int(gold_toks == pred_toks)\n  if num_same == 0:\n    return 0\n  precision = 1.0 * num_same / len(pred_toks)\n  recall = 1.0 * num_same / len(gold_toks)\n  f1 = (2 * precision * recall) / (precision + recall)\n  return f1\n\ndef get_raw_scores(dataset, preds):\n  exact_scores = {}\n  f1_scores = {}\n  for article in dataset:\n    for p in article[\'paragraphs\']:\n      for qa in p[\'qas\']:\n        qid = qa[\'id\']\n        gold_answers = [a[\'text\'] for a in qa[\'answers\']\n                        if normalize_answer(a[\'text\'])]\n        if not gold_answers:\n          # For unanswerable questions, only correct answer is empty string\n          gold_answers = [\'\']\n        if qid not in preds:\n          print(\'Missing prediction for %s\' % qid)\n          continue\n        a_pred = preds[qid]\n        # Take max over all gold answers\n        exact_scores[qid] = max(compute_exact(a, a_pred) for a in gold_answers)\n        f1_scores[qid] = max(compute_f1(a, a_pred) for a in gold_answers)\n  return exact_scores, f1_scores\n\ndef apply_no_ans_threshold(scores, na_probs, qid_to_has_ans, na_prob_thresh):\n  new_scores = {}\n  for qid, s in scores.items():\n    pred_na = na_probs[qid] > na_prob_thresh\n    if pred_na:\n      new_scores[qid] = float(not qid_to_has_ans[qid])\n    else:\n      new_scores[qid] = s\n  return new_scores\n\ndef make_eval_dict(exact_scores, f1_scores, qid_list=None):\n  if not qid_list:\n    total = len(exact_scores)\n    return collections.OrderedDict([\n        (\'exact\', 100.0 * sum(exact_scores.values()) / total),\n        (\'f1\', 100.0 * sum(f1_scores.values()) / total),\n        (\'total\', total),\n    ])\n  else:\n    total = len(qid_list)\n    return collections.OrderedDict([\n        (\'exact\', 100.0 * sum(exact_scores[k] for k in qid_list) / total),\n        (\'f1\', 100.0 * sum(f1_scores[k] for k in qid_list) / total),\n        (\'total\', total),\n    ])\n\ndef merge_eval(main_eval, new_eval, prefix):\n  for k in new_eval:\n    main_eval[\'%s_%s\' % (prefix, k)] = new_eval[k]\n\ndef plot_pr_curve(precisions, recalls, out_image, title):\n  plt.step(recalls, precisions, color=\'b\', alpha=0.2, where=\'post\')\n  plt.fill_between(recalls, precisions, step=\'post\', alpha=0.2, color=\'b\')\n  plt.xlabel(\'Recall\')\n  plt.ylabel(\'Precision\')\n  plt.xlim([0.0, 1.05])\n  plt.ylim([0.0, 1.05])\n  plt.title(title)\n  plt.savefig(out_image)\n  plt.clf()\n\ndef make_precision_recall_eval(scores, na_probs, num_true_pos, qid_to_has_ans,\n                               out_image=None, title=None):\n  qid_list = sorted(na_probs, key=lambda k: na_probs[k])\n  true_pos = 0.0\n  cur_p = 1.0\n  cur_r = 0.0\n  precisions = [1.0]\n  recalls = [0.0]\n  avg_prec = 0.0\n  for i, qid in enumerate(qid_list):\n    if qid_to_has_ans[qid]:\n      true_pos += scores[qid]\n    cur_p = true_pos / float(i+1)\n    cur_r = true_pos / float(num_true_pos)\n    if i == len(qid_list) - 1 or na_probs[qid] != na_probs[qid_list[i+1]]:\n      # i.e., if we can put a threshold after this point\n      avg_prec += cur_p * (cur_r - recalls[-1])\n      precisions.append(cur_p)\n      recalls.append(cur_r)\n  if out_image:\n    plot_pr_curve(precisions, recalls, out_image, title)\n  return {\'ap\': 100.0 * avg_prec}\n\ndef run_precision_recall_analysis(main_eval, exact_raw, f1_raw, na_probs, \n                                  qid_to_has_ans, out_image_dir):\n  if out_image_dir and not os.path.exists(out_image_dir):\n    os.makedirs(out_image_dir)\n  num_true_pos = sum(1 for v in qid_to_has_ans.values() if v)\n  if num_true_pos == 0:\n    return\n  pr_exact = make_precision_recall_eval(\n      exact_raw, na_probs, num_true_pos, qid_to_has_ans,\n      out_image=os.path.join(out_image_dir, \'pr_exact.png\'),\n      title=\'Precision-Recall curve for Exact Match score\')\n  pr_f1 = make_precision_recall_eval(\n      f1_raw, na_probs, num_true_pos, qid_to_has_ans,\n      out_image=os.path.join(out_image_dir, \'pr_f1.png\'),\n      title=\'Precision-Recall curve for F1 score\')\n  oracle_scores = {k: float(v) for k, v in qid_to_has_ans.items()}\n  pr_oracle = make_precision_recall_eval(\n      oracle_scores, na_probs, num_true_pos, qid_to_has_ans,\n      out_image=os.path.join(out_image_dir, \'pr_oracle.png\'),\n      title=\'Oracle Precision-Recall curve (binary task of HasAns vs. NoAns)\')\n  merge_eval(main_eval, pr_exact, \'pr_exact\')\n  merge_eval(main_eval, pr_f1, \'pr_f1\')\n  merge_eval(main_eval, pr_oracle, \'pr_oracle\')\n\ndef histogram_na_prob(na_probs, qid_list, image_dir, name):\n  if not qid_list:\n    return\n  x = [na_probs[k] for k in qid_list]\n  weights = np.ones_like(x) / float(len(x))\n  plt.hist(x, weights=weights, bins=20, range=(0.0, 1.0))\n  plt.xlabel(\'Model probability of no-answer\')\n  plt.ylabel(\'Proportion of dataset\')\n  plt.title(\'Histogram of no-answer probability: %s\' % name)\n  plt.savefig(os.path.join(image_dir, \'na_prob_hist_%s.png\' % name))\n  plt.clf()\n\ndef find_best_thresh(preds, scores, na_probs, qid_to_has_ans):\n  num_no_ans = sum(1 for k in qid_to_has_ans if not qid_to_has_ans[k])\n  cur_score = num_no_ans\n  best_score = cur_score\n  best_thresh = 0.0\n  qid_list = sorted(na_probs, key=lambda k: na_probs[k])\n  for i, qid in enumerate(qid_list):\n    if qid not in scores: continue\n    if qid_to_has_ans[qid]:\n      diff = scores[qid]\n    else:\n      if preds[qid]:\n        diff = -1\n      else:\n        diff = 0\n    cur_score += diff\n    if cur_score > best_score:\n      best_score = cur_score\n      best_thresh = na_probs[qid]\n  return 100.0 * best_score / len(scores), best_thresh\n\ndef find_best_thresh_v2(preds, scores, na_probs, qid_to_has_ans):\n  num_no_ans = sum(1 for k in qid_to_has_ans if not qid_to_has_ans[k])\n  cur_score = num_no_ans\n  best_score = cur_score\n  best_thresh = 0.0\n  qid_list = sorted(na_probs, key=lambda k: na_probs[k])\n  for i, qid in enumerate(qid_list):\n    if qid not in scores: continue\n    if qid_to_has_ans[qid]:\n      diff = scores[qid]\n    else:\n      if preds[qid]:\n        diff = -1\n      else:\n        diff = 0\n    cur_score += diff\n    if cur_score > best_score:\n      best_score = cur_score\n      best_thresh = na_probs[qid]\n\n  has_ans_score, has_ans_cnt = 0, 0\n  for qid in qid_list:\n    if not qid_to_has_ans[qid]: continue\n    has_ans_cnt += 1\n\n    if qid not in scores: continue\n    has_ans_score += scores[qid]\n\n  return 100.0 * best_score / len(scores), best_thresh, 1.0 * has_ans_score / has_ans_cnt\n\ndef find_all_best_thresh(main_eval, preds, exact_raw, f1_raw, na_probs, qid_to_has_ans):\n  best_exact, exact_thresh = find_best_thresh(preds, exact_raw, na_probs, qid_to_has_ans)\n  best_f1, f1_thresh = find_best_thresh(preds, f1_raw, na_probs, qid_to_has_ans)\n  main_eval[\'best_exact\'] = best_exact\n  main_eval[\'best_exact_thresh\'] = exact_thresh\n  main_eval[\'best_f1\'] = best_f1\n  main_eval[\'best_f1_thresh\'] = f1_thresh\n\ndef find_all_best_thresh_v2(main_eval, preds, exact_raw, f1_raw, na_probs, qid_to_has_ans):\n  best_exact, exact_thresh, has_ans_exact = find_best_thresh_v2(preds, exact_raw, na_probs, qid_to_has_ans)\n  best_f1, f1_thresh, has_ans_f1 = find_best_thresh_v2(preds, f1_raw, na_probs, qid_to_has_ans)\n  main_eval[\'best_exact\'] = best_exact\n  main_eval[\'best_exact_thresh\'] = exact_thresh\n  main_eval[\'best_f1\'] = best_f1\n  main_eval[\'best_f1_thresh\'] = f1_thresh\n  main_eval[\'has_ans_exact\'] = has_ans_exact\n  main_eval[\'has_ans_f1\'] = has_ans_f1\n\ndef main():\n  with open(OPTS.data_file) as f:\n    dataset_json = json.load(f)\n    dataset = dataset_json[\'data\']\n  with open(OPTS.pred_file) as f:\n    preds = json.load(f)\n\n  new_orig_data = []\n  for article in dataset:\n    for p in article[\'paragraphs\']:\n      for qa in p[\'qas\']:\n        if qa[\'id\'] in preds:\n          new_para = {\'qas\': [qa]}\n          new_article = {\'paragraphs\': [new_para]}\n          new_orig_data.append(new_article)\n  dataset = new_orig_data\n\n  if OPTS.na_prob_file:\n    with open(OPTS.na_prob_file) as f:\n      na_probs = json.load(f)\n  else:\n    na_probs = {k: 0.0 for k in preds}\n  qid_to_has_ans = make_qid_to_has_ans(dataset)  # maps qid to True/False\n  has_ans_qids = [k for k, v in qid_to_has_ans.items() if v]\n  no_ans_qids = [k for k, v in qid_to_has_ans.items() if not v]\n  exact_raw, f1_raw = get_raw_scores(dataset, preds)\n  exact_thresh = apply_no_ans_threshold(exact_raw, na_probs, qid_to_has_ans,\n                                        OPTS.na_prob_thresh)\n  f1_thresh = apply_no_ans_threshold(f1_raw, na_probs, qid_to_has_ans,\n                                     OPTS.na_prob_thresh)\n  out_eval = make_eval_dict(exact_thresh, f1_thresh)\n  if has_ans_qids:\n    has_ans_eval = make_eval_dict(exact_thresh, f1_thresh, qid_list=has_ans_qids)\n    merge_eval(out_eval, has_ans_eval, \'HasAns\')\n  if no_ans_qids:\n    no_ans_eval = make_eval_dict(exact_thresh, f1_thresh, qid_list=no_ans_qids)\n    merge_eval(out_eval, no_ans_eval, \'NoAns\')\n  if OPTS.na_prob_file:\n    find_all_best_thresh(out_eval, preds, exact_raw, f1_raw, na_probs, qid_to_has_ans)\n  if OPTS.na_prob_file and OPTS.out_image_dir:\n    run_precision_recall_analysis(out_eval, exact_raw, f1_raw, na_probs, \n                                  qid_to_has_ans, OPTS.out_image_dir)\n    histogram_na_prob(na_probs, has_ans_qids, OPTS.out_image_dir, \'hasAns\')\n    histogram_na_prob(na_probs, no_ans_qids, OPTS.out_image_dir, \'noAns\')\n  if OPTS.out_file:\n    with open(OPTS.out_file, \'w\') as f:\n      json.dump(out_eval, f)\n  else:\n    print(json.dumps(out_eval, indent=2))\n\nif __name__ == \'__main__\':\n  OPTS = parse_args()\n  if OPTS.out_image_dir:\n    import matplotlib\n    matplotlib.use(\'Agg\')\n    import matplotlib.pyplot as plt \n  main()\n'"
src/summary.py,0,"b'# -*- coding: utf-8 -*-\n\'\'\'\nprint summary\n\'\'\'\nfrom __future__ import print_function\nfrom collections import Counter, OrderedDict\nimport string\nimport re\nimport argparse\nimport json\nimport sys\nreload(sys)\nsys.setdefaultencoding(\'utf-8\')\nimport pdb\nimport os\nimport math\nimport numpy as np\nimport collections\nfrom prettytable import PrettyTable\n\ndef print_summary():\n\tlscmd = os.popen(\'ls \'+sys.argv[1]+\'/result.*\').read()\n\tresult_list = lscmd.split()\n\tnum_args = len(result_list)\n\tassert num_args==2 or num_args==3\n\n\tdev_input_file = open(sys.argv[1]+\'/result.dev\', \'rb\')\n\ttest_input_file = open(sys.argv[1]+\'/result.test\', \'rb\')\n\tif num_args==2:\n\t\tprint_table = PrettyTable([\'#\',\'DEV-AVG\',\'DEV-EM\',\'DEV-F1\',\'TEST-AVG\',\'TEST-EM\',\'TEST-F1\',\'FILE\'])\n\telif num_args==3:\n\t\tchl_input_file = open(sys.argv[1]+\'/result.challenge\', \'rb\')\n\t\tprint_table = PrettyTable([\'#\',\'DEV-AVG\',\'DEV-EM\',\'DEV-F1\',\'TEST-AVG\',\'TEST-EM\',\'TEST-F1\',\'CHL-AVG\',\'CHL-EM\',\'CHL-F1\',\'FILE\'])\n\n\t# style set\n\tprint_table.align[\'FILE\'] = \'l\'\n\tprint_table.float_format = \'2.3\'\n\n\t# data fill\n\tdev_avg = []\n\tdev_em = []\n\tdev_f1 = []\n\tdev_file = []\n\tfor dline in dev_input_file.readlines():\n\t\tdline = dline.strip()\n\t\tif re.search(\'^{\', dline):\n\t\t\tddict = json.loads(dline)\n\t\t\tdev_avg.append(float(ddict[\'AVERAGE\']))\n\t\t\tdev_em.append(float(ddict[\'EM\']))\n\t\t\tdev_f1.append(float(ddict[\'F1\']))\n\t\t\tdev_file.append(ddict[\'FILE\'])\n\n\ttest_avg = []\n\ttest_em = []\n\ttest_f1 = []\n\ttest_file = []\n\tfor dline in test_input_file.readlines():\n\t\tdline = dline.strip()\n\t\tif re.search(\'^{\', dline):\n\t\t\tddict = json.loads(dline)\n\t\t\ttest_avg.append(float(ddict[\'AVERAGE\']))\n\t\t\ttest_em.append(float(ddict[\'EM\']))\n\t\t\ttest_f1.append(float(ddict[\'F1\']))\n\t\t\ttest_file.append(ddict[\'FILE\'])\n\n\tif num_args==3:\n\t\tchl_avg = []\n\t\tchl_em = []\n\t\tchl_f1 = []\n\t\tchl_file = []\n\t\tfor dline in chl_input_file.readlines():\n\t\t\tdline = dline.strip()\n\t\t\tif re.search(\'^{\', dline):\n\t\t\t\tddict = json.loads(dline)\n\t\t\t\tchl_avg.append(float(ddict[\'AVERAGE\']))\n\t\t\t\tchl_em.append(float(ddict[\'EM\']))\n\t\t\t\tchl_f1.append(float(ddict[\'F1\']))\n\t\t\t\tchl_file.append(ddict[\'FILE\'])\n\n\t# print\n\tif num_args == 2:\n\t\tmin_len = min(len(dev_avg),len(test_avg))\n\t\tfor k in range(min_len):\n\t\t\tprint_table.add_row([k+1, dev_avg[k], dev_em[k], dev_f1[k], test_avg[k], test_em[k], test_f1[k], dev_file[k]])\n\telif num_args == 3:\n\t\tmin_len = min(len(dev_avg),len(test_avg),len(chl_avg))\n\t\tfor k in range(min_len):\n\t\t\tprint_table.add_row([k+1, dev_avg[k], dev_em[k], dev_f1[k], test_avg[k], test_em[k], test_f1[k], chl_avg[k], chl_em[k], chl_f1[k], dev_file[k]])\n\n\tif len(sys.argv)==3:\n\t\tsk = sys.argv[2].upper()\n\t\tprint(\'sort key detected: {}\'.format(sk))\n\t\tprint(print_table.get_string(sortby=sk, reversesort=True))\n\telse:\n\t\tprint(print_table)\n\t\n\n\tif num_args == 2:\n\t\tsummary_table = PrettyTable([\'#\',\'DEV-AVG\',\'DEV-EM\',\'DEV-F1\',\'TEST-AVG\',\'TEST-EM\',\'TEST-F1\',\'FILE\'])\n\t\tsummary_table.add_row([""M"", np.max(dev_avg), np.max(dev_em), np.max(dev_f1), \n\t\t\t\t\t\t\t\t  np.max(test_avg), np.max(test_em), np.max(test_f1),""-""])\n\t\tsummary_table.add_row([""A"", np.mean(dev_avg), np.mean(dev_em), np.mean(dev_f1), \n\t\t\t\t\t\t\t\t  np.mean(test_avg), np.mean(test_em), np.mean(test_f1),""-""])\n\t\tsummary_table.add_row([""D"", np.std(dev_avg), np.std(dev_em), np.std(dev_f1), \n\t\t\t\t\t\t\t\t  np.std(test_avg), np.std(test_em), np.std(test_f1),""-""])\n\telif num_args == 3:\n\t\tsummary_table = PrettyTable([\'#\',\'DEV-AVG\',\'DEV-EM\',\'DEV-F1\',\'TEST-AVG\',\'TEST-EM\',\'TEST-F1\',\'CHL-AVG\',\'CHL-EM\',\'CHL-F1\',\'FILE\'])\n\t\tsummary_table.add_row([""M"", np.max(dev_avg), np.max(dev_em), np.max(dev_f1), \n\t\t\t\t\t\t\t\t  np.max(test_avg), np.max(test_em), np.max(test_f1),\n\t\t\t\t\t\t\t\t  np.max(chl_avg), np.max(chl_em), np.max(chl_f1), ""-""])\n\t\tsummary_table.add_row([""A"", np.mean(dev_avg), np.mean(dev_em), np.mean(dev_f1), \n\t\t\t\t\t\t\t\t  np.mean(test_avg), np.mean(test_em), np.mean(test_f1),\n\t\t\t\t\t\t\t\t  np.mean(chl_avg), np.mean(chl_em), np.mean(chl_f1), ""-""])\n\t\tsummary_table.add_row([""D"", np.std(dev_avg), np.std(dev_em), np.std(dev_f1), \n\t\t\t\t\t\t\t\t  np.std(test_avg), np.std(test_em), np.std(test_f1),\n\t\t\t\t\t\t\t\t  np.std(chl_avg), np.std(chl_em), np.std(chl_f1), ""-""])\n\t# style set\n\tsummary_table.align[\'FILE\'] = \'l\'\n\tsummary_table.float_format = \'2.3\'\n\tprint(summary_table)\n\treturn 0\n\n\n\n\nif __name__ == \'__main__\':\n\tprint_summary()\n\n'"
src/tpu_estimator.py,28,"b'# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ===================================================================\n""""""TPUEstimator class.""""""\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport copy\nimport os\nimport signal\nimport sys\nimport threading\nimport time\n\nimport numpy as np\nimport six\nfrom six.moves import queue as Queue  # pylint: disable=redefined-builtin\nfrom six.moves import xrange  # pylint: disable=redefined-builtin\n\nfrom tensorflow.contrib.tpu.proto import compilation_result_pb2 as tpu_compilation_result\nfrom tensorflow.contrib.tpu.python.tpu import tensor_tracer\nfrom tensorflow.contrib.tpu.python.ops import tpu_ops\nfrom tensorflow.contrib.tpu.python.tpu import error_handling\nfrom tensorflow.contrib.tpu.python.tpu import session_support\nfrom tensorflow.contrib.tpu.python.tpu import tpu\nfrom tensorflow.contrib.tpu.python.tpu import tpu_config\nfrom tensorflow.contrib.tpu.python.tpu import tpu_context\nfrom tensorflow.contrib.tpu.python.tpu import tpu_feed\nfrom tensorflow.contrib.tpu.python.tpu import training_loop\nfrom tensorflow.contrib.tpu.python.tpu import util as util_lib\nfrom tensorflow.contrib.training.python.training import hparam\nfrom tensorflow.core.framework import variable_pb2\nfrom tensorflow.core.framework.summary_pb2 import Summary\nfrom tensorflow.core.protobuf import config_pb2\nfrom tensorflow.python.client import session as tf_session\nfrom tensorflow.python.data.ops import dataset_ops\nfrom tensorflow.python.data.util import nest as data_nest\nfrom tensorflow.python.estimator import estimator as estimator_lib\nfrom tensorflow.python.estimator import model_fn as model_fn_lib\nfrom tensorflow.python.estimator.export import export_output as export_output_lib\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import check_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import init_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.ops import state_ops\nfrom tensorflow.python.ops import summary_ops_v2 as contrib_summary\nfrom tensorflow.python.ops import variable_scope\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import tf_logging as logging\nfrom tensorflow.python.saved_model import tag_constants\nfrom tensorflow.python.summary import summary\nfrom tensorflow.python.training import basic_session_run_hooks\nfrom tensorflow.python.training import evaluation\nfrom tensorflow.python.training import session_run_hook\nfrom tensorflow.python.training import training\nfrom tensorflow.python.training import training_util\nfrom tensorflow.python.util import function_utils\nfrom tensorflow.python.util import nest\nfrom tensorflow.python.util import tf_inspect\n\n_INITIAL_LOSS = 1e7\n_ZERO_LOSS = 0.\n_TPU_ESTIMATOR = \'custom_tpu_estimator\'\n_ITERATIONS_PER_LOOP_VAR = \'iterations_per_loop\'\n_BATCH_SIZE_KEY = \'batch_size\'\n_CTX_KEY = \'context\'\n_USE_TPU_KEY = \'use_tpu\'\n_CROSS_REPLICA_SUM_OP = \'CrossReplicaSum\'\n_ONE_GIGABYTE = 1024 * 1024 * 1024\n_TPU_ENQUEUE_OPS = \'_tpu_enqueue_ops\'\n_TPU_TRAIN_OP = \'_tpu_train_op\'\n_REWRITE_FOR_INFERENCE_MODE = \'_rewrite_for_inference\'\n\n# Ideally _USE_TPU_KEY should be reserved as well. However there are already\n# models that make use of this key, thus it can not be reserved now to prevent\n# breakage. In the long run, we would like to mitigate this by migrating models\n# off of using _USE_TPU_KEY.\n_RESERVED_PARAMS_KEYS = [_BATCH_SIZE_KEY, _CTX_KEY]\n\n# TODO(b/65703635): Flip the value and remove all dead code. Currently, this is\n# only used for per-core based deployments. For per-host based pipelines, if a\n# user returns a Dataset instance it will be automatically wrapped in a\n# tf.while_loop (This can be disabled by returning features and labels\n# explicitly).\n_WRAP_INPUT_FN_INTO_WHILE_LOOP = False\n\nops.register_proto_function(\n    \'{}_{}\'.format(_TPU_ESTIMATOR, _ITERATIONS_PER_LOOP_VAR),\n    proto_type=variable_pb2.VariableDef,\n    to_proto=resource_variable_ops._to_proto_fn,  # pylint: disable=protected-access\n    from_proto=resource_variable_ops._from_proto_fn)  # pylint: disable=protected-access\n\n\ndef _is_iterable(obj):\n  """"""A Python 2 and 3 compatible util to check whether `obj` is iterable.""""""\n  try:\n    iter(obj)\n    return True\n  except TypeError:\n    return False\n\n\ndef _create_global_step(graph):\n  graph = graph or ops.get_default_graph()\n  if training.get_global_step(graph) is not None:\n    raise ValueError(\'""global_step"" already exists.\')\n  # Create in proper graph and base name_scope.\n  with graph.as_default() as g, g.name_scope(None):\n    return variable_scope.get_variable(\n        ops.GraphKeys.GLOBAL_STEP,\n        shape=[],\n        dtype=dtypes.int64,\n        initializer=init_ops.zeros_initializer(),\n        trainable=False,\n        use_resource=True,\n        collections=[ops.GraphKeys.GLOBAL_VARIABLES, ops.GraphKeys.GLOBAL_STEP])\n\n\ndef _create_or_get_iterations_per_loop():\n  """"""Creates or gets the iterations_per_loop variable.\n\n  In TPUEstimator, the user provided computation, the model_fn, is wrapped\n  inside a tf.while_loop for peak performance. The iterations of the loop are\n  specified by this variable, which adjusts its value on the CPU after each TPU\n  program execution and before the next TPU execution.\n\n  The purpose of using a variable, rather then a constant, is to allow\n  TPUEstimator adapt the TPU training iterations according to the final steps\n  specified by users. For example, if the user sets the iterations_per_loop as 4\n  in TPUConfig and steps as 10 in TPUEstimator.train(), the iterations_per_loop\n  variable will have the following value before each TPU training.\n\n      - 1-th TPU execution: iterations_per_loop = 4\n      - 2-th TPU execution: iterations_per_loop = 4\n      - 3-th TPU execution: iterations_per_loop = 2\n\n  As model_fn increases the global step once per train_op invocation, the global\n  step is 10 after all TPU executions, matching the steps=10 inputs passed in by\n  users.\n\n  Returns:\n    A TF non-trainable resource variable.\n\n  Raises:\n    RuntimeError: If multi iterations_per_loop variables were found.\n  """"""\n  graph = ops.get_default_graph()\n  collection_name = \'{}_{}\'.format(_TPU_ESTIMATOR, _ITERATIONS_PER_LOOP_VAR)\n  iter_vars = graph.get_collection(collection_name)\n  if len(iter_vars) == 1:\n    return iter_vars[0]\n  elif len(iter_vars) > 1:\n    raise RuntimeError(\'Multiple iterations_per_loop_var in collection.\')\n\n  with ops.colocate_with(training_util.get_global_step()):\n    with variable_scope.variable_scope(\n        _TPU_ESTIMATOR, reuse=variable_scope.AUTO_REUSE):\n      return variable_scope.get_variable(\n          _ITERATIONS_PER_LOOP_VAR,\n          initializer=init_ops.zeros_initializer(),\n          shape=[],\n          dtype=dtypes.int32,\n          trainable=False,\n          collections=[collection_name, ops.GraphKeys.LOCAL_VARIABLES],\n          use_resource=True)\n\n\ndef _sync_variables_ops(ctx):\n  """"""Create varriables synchronization ops.\n\n  Gets the variables back from TPU nodes. This means the variables updated\n  by TPU will now be *synced* to host memory.\n  In BROADCAST mode, we skip this sync since the variables are ususally too\n  big to transmit via RPC.\n\n  Args:\n    ctx: A `_InternalTPUContext` instance with mode.\n\n  Returns:\n    A list of sync ops.\n  """"""\n\n  if not ctx.is_input_broadcast_with_iterators():\n    return [\n        array_ops.check_numerics(v.read_value(),\n                                 \'Gradient for %s is NaN\' % v.name).op\n        for v in variables.trainable_variables()\n    ]\n  else:\n    return [control_flow_ops.no_op()]\n\n\ndef _increase_eval_step_op(iterations_per_loop):\n  """"""Returns an op to increase the eval step for TPU evaluation.\n\n  Args:\n    iterations_per_loop: Tensor. The number of eval steps running in TPU system\n      before returning to CPU host for each `Session.run`.\n\n  Returns:\n    An operation\n  """"""\n  eval_step = evaluation._get_or_create_eval_step()  # pylint: disable=protected-access\n  # Estimator evaluate increases 1 by default. So, we increase the difference.\n  return state_ops.assign_add(\n      eval_step,\n      math_ops.cast(iterations_per_loop - 1, dtype=eval_step.dtype),\n      use_locking=True)\n\n\ndef _extract_key_names(tensor_or_dict):\n  if isinstance(tensor_or_dict, dict):\n    return sorted(tensor_or_dict.keys())\n  return []\n\n\nclass _SIGNAL(object):\n  """"""Signal used to control the thread of infeed/outfeed.\n\n  All preserved signals must be negative numbers. Positive numbers are used to\n  indicate the number of iterations for next training/evaluation loop.\n  """"""\n  NEXT_BATCH = -1\n  STOP = -2\n\n\nclass TPUEstimatorSpec(model_fn_lib._TPUEstimatorSpec):  # pylint: disable=protected-access\n  """"""Ops and objects returned from a `model_fn` and passed to `TPUEstimator`.\n\n  See `EstimatorSpec` for `mode`, `predictions`, `loss`, `train_op`, and\n  `export_outputs`.\n\n  For evaluation, `eval_metrics `is a tuple of `metric_fn` and `tensors`, where\n  `metric_fn` runs on CPU to generate metrics and `tensors` represents the\n  `Tensor`s transferred from TPU system to CPU host and passed to `metric_fn`.\n  To be precise, TPU evaluation expects a slightly different signature from the\n  `tf.estimator.Estimator`. While `EstimatorSpec.eval_metric_ops` expects a\n  dict, `TPUEstimatorSpec.eval_metrics` is a tuple of `metric_fn` and `tensors`.\n  The `tensors` could be a list of `Tensor`s or dict of names to `Tensor`s. The\n  `tensors` usually specify the model logits, which are transferred back from\n  TPU system to CPU host. All tensors must have be batch-major, i.e., the batch\n  size is the first dimension. Once all tensors are available at CPU host from\n  all shards, they are concatenated (on CPU) and passed as positional arguments\n  to the `metric_fn` if `tensors` is list or keyword arguments if `tensors` is\n  a dict. `metric_fn` takes the `tensors` and returns a dict from metric string\n  name to the result of calling a metric function, namely a `(metric_tensor,\n  update_op)` tuple. See `TPUEstimator` for MNIST example how to specify the\n  `eval_metrics`.\n\n  `scaffold_fn` is a function running on CPU to generate the `Scaffold`. This\n  function should not capture any Tensors in `model_fn`.\n\n  `host_call` is a tuple of a `function` and a list or dictionary of `tensors`\n  to pass to that function and returns a list of Tensors. `host_call` currently\n  works for train() and evaluate(). The Tensors returned by the function is\n  executed on the CPU on every step, so there is communication overhead when\n  sending tensors from TPU to CPU. To reduce the overhead, try reducing the\n  size of the tensors. The `tensors` are concatenated along their major (batch)\n  dimension, and so must be >= rank 1. The `host_call` is useful for writing\n  summaries with `tf.contrib.summary.create_file_writer`.\n  """"""\n\n  def __new__(cls,\n              mode,\n              predictions=None,\n              loss=None,\n              train_op=None,\n              eval_metrics=None,\n              export_outputs=None,\n              scaffold_fn=None,\n              host_call=None,\n              training_hooks=None,\n              evaluation_hooks=None,\n              prediction_hooks=None):\n    """"""Creates a validated `TPUEstimatorSpec` instance.""""""\n    host_calls = {}\n    if eval_metrics is not None:\n      host_calls[\'eval_metrics\'] = eval_metrics\n    if host_call is not None:\n      host_calls[\'host_call\'] = host_call\n    _OutfeedHostCall.validate(host_calls)\n\n    training_hooks = tuple(training_hooks or [])\n    evaluation_hooks = tuple(evaluation_hooks or [])\n    prediction_hooks = tuple(prediction_hooks or [])\n\n    for hook in training_hooks + evaluation_hooks + prediction_hooks:\n      if not isinstance(hook, session_run_hook.SessionRunHook):\n        raise TypeError(\'All hooks must be SessionRunHook instances, given: {}\'\n                        .format(hook))\n\n    return super(TPUEstimatorSpec, cls).__new__(\n        cls,\n        mode=mode,\n        predictions=predictions,\n        loss=loss,\n        train_op=train_op,\n        eval_metrics=eval_metrics,\n        export_outputs=export_outputs,\n        scaffold_fn=scaffold_fn,\n        host_call=host_call,\n        training_hooks=training_hooks,\n        evaluation_hooks=evaluation_hooks,\n        prediction_hooks=prediction_hooks)\n\n  def as_estimator_spec(self):\n    """"""Creates an equivalent `EstimatorSpec` used by CPU train/eval.""""""\n    host_calls = {}\n    if self.eval_metrics is not None:\n      host_calls[\'eval_metrics\'] = self.eval_metrics\n    if self.host_call is not None:\n      host_calls[\'host_call\'] = self.host_call\n    host_call_ret = _OutfeedHostCall.create_cpu_hostcall(host_calls)\n    eval_metric_ops = None\n    if self.eval_metrics is not None:\n      eval_metric_ops = host_call_ret[\'eval_metrics\']\n    hooks = None\n    if self.host_call is not None:\n      hooks = [_OutfeedHostCallHook(host_call_ret[\'host_call\'])]\n    if tensor_tracer.TensorTracer.is_enabled():\n      tt = tensor_tracer.TensorTracer()\n      tracing_calls = tt.trace_cpu(ops.get_default_graph())\n      tracing_call_ret = _OutfeedHostCall.create_cpu_hostcall(tracing_calls)\n      tracing_functions = tracing_call_ret.values()\n      if tracing_functions:\n        if hooks:\n          hooks.extend([_OutfeedHostCallHook(tracing_functions)])\n        else:\n          hooks = [_OutfeedHostCallHook(tracing_functions)]\n    hooks = tuple(hooks or [])\n    scaffold = self.scaffold_fn() if self.scaffold_fn else None\n    return model_fn_lib.EstimatorSpec(\n        mode=self.mode,\n        predictions=self.predictions,\n        loss=self.loss,\n        train_op=self.train_op,\n        eval_metric_ops=eval_metric_ops,\n        export_outputs=self.export_outputs,\n        scaffold=scaffold,\n        training_hooks=self.training_hooks + hooks,\n        evaluation_hooks=self.evaluation_hooks + hooks,\n        prediction_hooks=self.prediction_hooks + hooks)\n\n\nclass _OpQueueContext(object):\n  """"""Manages work queue and thread for a infeed/outfeed thread.""""""\n\n  def __init__(self, name, target, args):\n    self._name = name\n    self._queue = Queue.Queue()\n    args = (self,) + args\n    self._thread = threading.Thread(name=name, target=target, args=args)\n    self._thread.daemon = True\n    self._thread.start()\n\n  def stop(self):\n    self._queue.put(_SIGNAL.STOP)\n\n  def send_next_batch_signal(self, iterations):\n    self._queue.put(iterations)\n\n  def read_iteration_counts(self):\n    while True:\n      iterations = self._queue.get(block=True)\n      logging.debug(\'%s read iterations %s\', self._name, iterations)\n      if iterations == _SIGNAL.STOP:\n        logging.info(\'%s received shutdown signal, stopping.\', self._name)\n        return\n      yield iterations\n\n  def join(self):\n    logging.info(\'Shutting down %s thread.\', self._name)\n    self.stop()\n    self._thread.join()\n\n\nclass _OpSignalOnceQueueContext(_OpQueueContext):\n  """"""Manages work queue and thread for a infeed/outfeed thread.\n\n  This subclass only signals once.\n  """"""\n\n  def __init__(self, name, target, args):\n    super(_OpSignalOnceQueueContext, self).__init__(name, target, args)\n    self._has_signaled = False\n\n  def send_next_batch_signal(self, iterations):\n    if not self._has_signaled:\n      self._queue.put(iterations)\n      self._has_signaled = True\n\n\nclass TPUInfeedOutfeedSessionHook(session_run_hook.SessionRunHook):\n  """"""A Session hook setting up the TPU initialization, infeed, and outfeed.\n\n  This hook does two major things:\n  1. initialize and shutdown TPU system.\n  2. launch and join the threads for infeed enqueue and (optional) outfeed\n     dequeue.\n  """"""\n\n  def __init__(self,\n               ctx,\n               enqueue_ops,\n               dequeue_ops,\n               tpu_compile_op,\n               run_infeed_loop_on_coordinator=True,\n               rendezvous=None,\n               master=None,\n               session_config=None):\n    self._master_job = ctx.master_job\n    self._enqueue_ops = enqueue_ops\n    self._dequeue_ops = dequeue_ops\n    self._rendezvous = rendezvous\n    self._master = master\n    self._session_config = session_config\n    self._run_infeed_loop_on_coordinator = run_infeed_loop_on_coordinator\n    self._initial_infeed_sleep_secs = (\n        ctx.config.tpu_config.initial_infeed_sleep_secs)\n\n    self._feed_error = None\n    self._finished = False\n    self._should_initialize_tpu = True\n    self._tpu_compile_op = tpu_compile_op\n\n  def begin(self):\n    logging.info(\'TPU job name %s\', self._master_job)\n    self._iterations_per_loop_var = _create_or_get_iterations_per_loop()\n    self._init_ops = []\n    if self._should_initialize_tpu:\n      self._finalize_ops = [tpu.shutdown_system(job=self._master_job)]\n    else:\n      self._finalize_ops = []\n\n    summary_writer_init_ops = contrib_summary.summary_writer_initializer_op()\n    self._init_ops.extend(summary_writer_init_ops)\n    # Get all the writer resources from the initializer, so we know what to\n    # flush.\n    for op in summary_writer_init_ops:\n      self._finalize_ops.append(contrib_summary.flush(writer=op.inputs[0]))\n\n  def _run_infeed(self, queue_ctx, session):\n    logging.info(\'Starting infeed thread controller.\')\n    if self._initial_infeed_sleep_secs:\n      logging.info(\'Infeed thread sleeping for %d seconds.\',\n                   self._initial_infeed_sleep_secs)\n      time.sleep(self._initial_infeed_sleep_secs)\n      logging.info(\'Infeed thread starting after sleep\')\n\n    with self._rendezvous.catch_errors(source=\'infeed\', session=session):\n      if self._run_infeed_loop_on_coordinator:\n        for count, steps in enumerate(queue_ctx.read_iteration_counts()):\n          for i in xrange(steps):\n            logging.debug(\'Infeed enqueue for iteration (%d, %d)\', count, i)\n            session.run(self._enqueue_ops)\n      else:\n        for _ in queue_ctx.read_iteration_counts():\n          session.run(self._enqueue_ops)\n      logging.info(\'Infeed thread finished, shutting down.\')\n\n  def _run_outfeed(self, queue_ctx, session):\n    logging.info(\'Starting outfeed thread controller.\')\n    with self._rendezvous.catch_errors(source=\'outfeed\', session=session):\n      for count, steps in enumerate(queue_ctx.read_iteration_counts()):\n        for i in xrange(steps):\n          logging.debug(\'Outfeed dequeue for iteration (%d, %d)\', count, i)\n          session.run(self._dequeue_ops)\n      logging.info(\'Outfeed thread finished, shutting down.\')\n\n  def _create_infeed_controller(self, name, target, args):\n    return _OpQueueContext(name=name, target=target, args=args)\n\n  def _assertCompilationSucceeded(self, result, coord):\n    proto = tpu_compilation_result.CompilationResultProto()\n    proto.ParseFromString(result)\n    if proto.status_error_message:\n      logging.error(\'Compilation failed: {}\'.format(proto.status_error_message))\n      coord.request_stop()\n    else:\n      logging.info(\'Compilation succeeded\')\n\n  def after_create_session(self, session, coord):\n    if self._should_initialize_tpu:\n      logging.info(\'Init TPU system\')\n      start = time.time()\n      with ops.Graph().as_default():\n        with tf_session.Session(\n            self._master, config=self._session_config) as sess:\n          sess.run(tpu.initialize_system(job=self._master_job))\n      logging.info(\'Initialized TPU in %d seconds\', time.time() - start)\n\n    session.run(self._init_ops,\n                options=config_pb2.RunOptions(timeout_in_ms=5 * 60 * 1000))\n\n    if os.environ.get(\'TPU_SPLIT_COMPILE_AND_EXECUTE\', \'\') == \'1\':\n      logging.info(\'Compiling user program: this may take a while...\')\n      self._assertCompilationSucceeded(session.run(self._tpu_compile_op), coord)\n\n    self._infeed_controller = self._create_infeed_controller(\n        name=\'InfeedController\', target=self._run_infeed, args=(session,))\n\n    self._outfeed_controller = _OpQueueContext(\n        name=\'OutfeedController\', target=self._run_outfeed, args=(session,))\n\n    # Enable the worker watchdog to terminate workers on coordinator exit.\n    watchdog_timeout = int(os.environ.get(\'TF_TPU_WATCHDOG_TIMEOUT\', \'0\'))\n    if watchdog_timeout > 0:\n      session_support.start_worker_watchdog(session,\n                                            shutdown_timeout=watchdog_timeout)\n\n  def before_run(self, run_context):\n    self._feed_error = None\n\n    iterations = run_context.session.run(self._iterations_per_loop_var)\n\n    logging.info(\'Enqueue next (%d) batch(es) of data to infeed.\', iterations)\n    self._infeed_controller.send_next_batch_signal(iterations)\n\n    logging.info(\'Dequeue next (%d) batch(es) of data from outfeed.\',\n                 iterations)\n    self._outfeed_controller.send_next_batch_signal(iterations)\n\n  def end(self, session):\n    self._finished = True\n    logging.info(\'Stop infeed thread controller\')\n    self._infeed_controller.join()\n    self._rendezvous.record_done(\'infeed\')\n\n    logging.info(\'Stop output thread controller\')\n    self._outfeed_controller.join()\n    self._rendezvous.record_done(\'outfeed\')\n\n    logging.info(\'Shutdown TPU system.\')\n    session.run(self._finalize_ops)\n\n\nclass TPUInfeedOutfeedSessionHookForPrediction(TPUInfeedOutfeedSessionHook):\n\n  def __init__(self, ctx, enqueue_ops, dequeue_ops, tpu_compile_op,\n               rendezvous=None, master=None, session_config=None):\n    super(TPUInfeedOutfeedSessionHookForPrediction, self).__init__(\n        ctx,\n        enqueue_ops,\n        dequeue_ops,\n        tpu_compile_op=tpu_compile_op,\n        run_infeed_loop_on_coordinator=False,\n        rendezvous=rendezvous,\n        master=master,\n        session_config=session_config)\n\n  def _create_infeed_controller(self, name, target, args):\n    return _OpSignalOnceQueueContext(name=name, target=target, args=args)\n\n\nclass _TPUStopAtStepHook(session_run_hook.SessionRunHook):\n  """"""Hook that requests stop at a specified step.\n\n  This hook is similar to the `session_run_hook._StopAfterNEvalsHook` with\n  following differences for TPU training:\n\n  1. This hook sets the variable for iterations_per_loop, which is used by\n     `TPUInfeedOutfeedSessionHook` to control the iterations for infeed/outfeed.\n     As the hook execution order is not guaranteed, the variable update is\n     handled in `after_create_session` and `after_run` as\n     `TPUInfeedOutfeedSessionHook` reads the variable value in `before_run`.\n\n  2. For each training loop (session.run), the global step could be increased\n     multiple times on TPU. The global step tensor value will be explicitly read\n     again in `after_run` to ensure the latest value is retrieved to avoid race\n     condition.\n  """"""\n\n  def __init__(self, iterations, num_steps=None, last_step=None):\n    """"""Initializes a `StopAtStepHook`.\n\n    Args:\n      iterations: The number of iterations to run optimizer per training loop.\n      num_steps: Number of steps to execute.\n      last_step: Step after which to stop.\n\n    Raises:\n      ValueError: If one of the arguments is invalid.\n    """"""\n    if num_steps is None and last_step is None:\n      raise ValueError(\'One of num_steps or last_step must be specified.\')\n    if num_steps is not None and last_step is not None:\n      raise ValueError(\'Only one of num_steps or last_step can be specified.\')\n    self._num_steps = num_steps\n    self._last_step = last_step\n    self._iterations = iterations\n\n  def _next_iterations(self, global_step, last_step):\n    gap = last_step - global_step\n    return min(gap, self._iterations)\n\n  def begin(self):\n    self._global_step_tensor = training_util.get_global_step()\n    if self._global_step_tensor is None:\n      raise RuntimeError(\'Global step should be created.\')\n\n    self._iterations_per_loop_var = _create_or_get_iterations_per_loop()\n\n  def after_create_session(self, session, coord):\n    global_step = session.run(self._global_step_tensor)\n    if self._last_step is None:\n      self._last_step = global_step + self._num_steps\n\n    iterations = self._next_iterations(global_step, self._last_step)\n\n    self._iterations_per_loop_var.load(iterations, session=session)\n\n  def after_run(self, run_context, run_values):\n    # Global step cannot be retrieved via SessionRunArgs and before_run due to\n    # race condition.\n    global_step = run_context.session.run(self._global_step_tensor)\n    if global_step >= self._last_step:\n      run_context.request_stop()\n    else:\n      iterations = self._next_iterations(global_step, self._last_step)\n      self._iterations_per_loop_var.load(\n          iterations, session=run_context.session)\n\n\nclass _SetEvalIterationsHook(session_run_hook.SessionRunHook):\n  """"""Hook that requests stop at a specified step.""""""\n\n  def __init__(self, num_steps):\n    """"""Initializes a `_SetEvalIterationsHook`.\n\n    Args:\n      num_steps: Number of steps to execute.\n    """"""\n    self._num_steps = num_steps\n\n  def begin(self):\n    self._iterations_per_loop_var = _create_or_get_iterations_per_loop()\n\n  def after_create_session(self, session, coord):\n    self._iterations_per_loop_var.load(self._num_steps, session=session)\n\n\nclass _StoppingPredictHook(session_run_hook.SessionRunHook):\n  """"""Hook that requests stop according to the stopping signal in prediction.""""""\n\n  def __init__(self, scalar_stopping_signal):\n    self._scalar_stopping_signal = scalar_stopping_signal\n\n  def begin(self):\n    self._iterations_per_loop_var = _create_or_get_iterations_per_loop()\n\n  def after_create_session(self, session, coord):\n    # This is not necessary as we do not run infeed enqueue and outfeed dequeue\n    # in side threads for prediction model. But it makes the\n    # TPUInfeedOutfeedSessionHook prints nice message.\n    self._iterations_per_loop_var.load(1, session=session)\n\n  def before_run(self, run_context):\n    return session_run_hook.SessionRunArgs(self._scalar_stopping_signal)\n\n  def after_run(self, run_context, run_values):\n    _ = run_context\n    scalar_stopping_signal = run_values.results\n    if _StopSignals.should_stop(scalar_stopping_signal):\n      # NOTE(xiejw): In prediction, stopping signals are inserted for each\n      # batch. And we append one more batch to signal the system it should stop.\n      # The data flow might look like\n      #\n      #  batch   0: images, labels, stop = 0  (user provided)\n      #  batch   1: images, labels, stop = 0  (user provided)\n      #  ...\n      #  batch  99: images, labels, stop = 0  (user provided)\n      #  batch 100: images, labels, stop = 1  (TPUEstimator appended)\n      #\n      # where the final batch (id = 100) is appended by TPUEstimator, so we\n      # should drop it before returning the predictions to user.\n      # To achieve that, we throw the OutOfRangeError in after_run. Once\n      # Monitored Session sees this error in SessionRunHook.after_run, the\n      # ""current"" prediction, i.e., batch with id=100, will be discarded\n      # immediately\n      raise errors.OutOfRangeError(None, None, \'Stopped by stopping signal.\')\n\n\ndef generate_per_core_enqueue_ops_fn_for_host(\n    ctx, input_fn, inputs_structure_recorder, host_device, host_id):\n  """"""Generates infeed enqueue ops for per-core input_fn on a single host.""""""\n  captured_infeed_queue = _CapturedObject()\n  tpu_ordinal_function_impl = ctx.tpu_ordinal_function(host_id)\n\n  def enqueue_ops_fn():\n    """"""A fn returns enqueue_ops.""""""\n    num_cores_per_host = ctx.num_of_cores_per_host\n    per_host_sharded_inputs = []\n    for core_ordinal in range(num_cores_per_host):\n      with ops.name_scope(\'ordinal_%d\' % (core_ordinal)):\n        user_context = tpu_context.TPUContext(\n            internal_ctx=ctx,\n            input_device=host_device,\n            invocation_index=host_id * ctx.num_of_cores_per_host + core_ordinal)\n        inputs = _Inputs.from_input_fn(input_fn(user_context))\n        if inputs.is_dataset:\n          raise TypeError(\n              \'`input_fn` returning `Dataset`  is not yet supported in \'\n              \'per-Core input pipeline deployment yet. Please set \'\n              \'TPUConfig.per_host_input_for_training to True or return \'\n              \'`features` and `labels` from `input_fn`\')\n        features, labels = inputs.features_and_labels()\n\n        inputs_structure_recorder.validate_and_record_structure(\n            features, labels)\n        flattened_inputs = (\n            inputs_structure_recorder.flatten_features_and_labels(\n                features, labels))\n        per_host_sharded_inputs.append(flattened_inputs)\n\n    infeed_queue = tpu_feed.InfeedQueue(\n        number_of_tuple_elements=len(per_host_sharded_inputs[0]))\n    captured_infeed_queue.capture(infeed_queue)\n\n    per_host_enqueue_ops = infeed_queue.generate_enqueue_ops(\n        per_host_sharded_inputs, tpu_ordinal_function=tpu_ordinal_function_impl)\n    return per_host_enqueue_ops\n\n  return enqueue_ops_fn, captured_infeed_queue\n\n\ndef generate_per_host_enqueue_ops_fn_for_host(\n    ctx, input_fn, inputs_structure_recorder, batch_axis, device, host_id):\n  """"""Generates infeed enqueue ops for per-host input_fn on a single host.""""""\n  captured_infeed_queue = _CapturedObject()\n\n  dataset_initializer = None\n\n  with ops.device(device):\n    user_context = tpu_context.TPUContext(\n        internal_ctx=ctx, input_device=device, invocation_index=host_id)\n    inputs = _Inputs.from_input_fn(input_fn(user_context))\n\n    is_dataset = inputs.is_dataset\n    if ctx.mode == model_fn_lib.ModeKeys.PREDICT:\n      if not is_dataset:\n        raise TypeError(\n            \'For mode PREDICT, `input_fn` must return `Dataset` instead of \'\n            \'`features` and `labels`.\')\n      if batch_axis is not None:\n        raise TypeError(\'For mode PREDICT, batch_axis is not supported yet.\')\n      inputs = _InputsWithStoppingSignals(\n          dataset=inputs.dataset,\n          batch_size=ctx.batch_size_for_input_fn,\n          add_padding=True)\n\n    if is_dataset:\n      dataset_initializer = inputs.dataset_initializer()\n\n    tpu_ordinal_function_impl = ctx.tpu_ordinal_function(host_id)\n\n  def enqueue_ops_fn():\n    """"""A Fn returning the TPU infeed enqueue ops.\n\n    By providing as a Fn, it can be invoked inside the tf.while_loop such that\n    the input pipeline for multiple iterations can be executed by one\n    Session.run call.\n\n    Returns:\n      list of dict of ops.\n    """"""\n    with ops.device(device):\n      num_of_replicas_per_host = ctx.num_of_replicas_per_host\n      # Convert user input to features and labels.  If the user returns a\n      # dataset, it is initialized and the features and labels extracted via\n      # `dataset.iterator.get_next()`\n      features, labels = inputs.features_and_labels()\n      signals = inputs.signals()\n\n      inputs_structure_recorder.validate_and_record_structure(features, labels)\n      unsharded_tensor_list = (\n          inputs_structure_recorder.flatten_features_and_labels(\n              features, labels, signals))\n\n      infeed_queue = tpu_feed.InfeedQueue(\n          tuple_types=[t.dtype for t in unsharded_tensor_list],\n          tuple_shapes=[t.shape for t in unsharded_tensor_list],\n          shard_dimensions=batch_axis)\n      captured_infeed_queue.capture(infeed_queue)\n      infeed_queue.set_number_of_shards(num_of_replicas_per_host)\n      per_host_enqueue_ops = (\n          infeed_queue.split_inputs_and_generate_enqueue_ops(\n              unsharded_tensor_list,\n              placement_function=lambda x: device,\n              tpu_ordinal_function=tpu_ordinal_function_impl))\n      if signals is None:\n        return per_host_enqueue_ops\n      else:\n        return {\n            \'ops\': per_host_enqueue_ops,\n            \'signals\': signals,\n        }\n\n  return enqueue_ops_fn, captured_infeed_queue, dataset_initializer\n\n\ndef generate_per_host_v2_enqueue_ops_fn_for_host(\n    ctx, input_fn, inputs_structure_recorder, device, host_id):\n  """"""Generates infeed enqueue ops for per-host input_fn on a single host.""""""\n  captured_infeed_queue = _CapturedObject()\n  dataset_initializer = None\n\n  with ops.device(device):\n    user_context = tpu_context.TPUContext(\n        internal_ctx=ctx, input_device=device, invocation_index=host_id)\n    inputs = _Inputs.from_input_fn(input_fn(user_context))\n\n    is_dataset = inputs.is_dataset\n    if not is_dataset:\n      raise TypeError(\'`input_fn` must return a `Dataset` for the PER_HOST_V2 \'\n                      \'input pipeline configuration.\')\n\n    if ctx.mode == model_fn_lib.ModeKeys.PREDICT:\n      inputs = _InputsWithStoppingSignals(\n          dataset=inputs.dataset,\n          batch_size=ctx.batch_size_for_input_fn,\n          add_padding=True,\n          num_invocations_per_step=ctx.num_of_replicas_per_host)\n\n    dataset_initializer = inputs.dataset_initializer()\n    tpu_ordinal_function_impl = ctx.tpu_ordinal_function(host_id)\n\n  def enqueue_ops_fn():\n    """"""Generates the per_host enqueue ops.""""""\n    control_deps = []\n    per_host_sharded_inputs = []\n    num_replicas_per_host = ctx.num_of_replicas_per_host\n    cached_signals = None\n    with ops.device(device):\n      if not inputs.is_dataset:\n        raise TypeError(\'`input_fn` must return a `Dataset` for this mode.\')\n      for _ in range(num_replicas_per_host):\n        # Use control dependencies to ensure a deterministic ordering.\n        with ops.control_dependencies(control_deps):\n          features, labels = inputs.features_and_labels()  # Calls get_next()\n          signals = inputs.signals()\n\n          # All the replicas share the replica 0\'s stopping singal.\n          # This avoids inconsistent state among different model replcias.\n          if cached_signals:\n            signals[\'stopping\'] = cached_signals[\'stopping\']\n          else:\n            cached_signals = signals\n\n        inputs_structure_recorder.validate_and_record_structure(\n            features, labels)\n        flattened_inputs = (\n            inputs_structure_recorder.flatten_features_and_labels(\n                features, labels, signals))\n        control_deps.extend(flattened_inputs)\n        per_host_sharded_inputs.append(flattened_inputs)\n\n      if inputs_structure_recorder.flattened_input_dims:\n        input_partition_dims = inputs_structure_recorder.flattened_input_dims\n        if signals:\n          input_partition_dims += [None] * len(signals)\n        # pylint: disable=protected-access\n        infeed_queue = tpu_feed._PartitionedInfeedQueue(\n            number_of_tuple_elements=len(per_host_sharded_inputs[0]),\n            host_id=host_id,\n            input_partition_dims=input_partition_dims,\n            device_assignment=ctx.device_assignment)\n        per_host_enqueue_ops = infeed_queue.generate_enqueue_ops(\n            per_host_sharded_inputs)\n      else:\n        infeed_queue = tpu_feed.InfeedQueue(\n            number_of_tuple_elements=len(per_host_sharded_inputs[0]))\n        per_host_enqueue_ops = infeed_queue.generate_enqueue_ops(\n            per_host_sharded_inputs,\n            tpu_ordinal_function=tpu_ordinal_function_impl)\n      captured_infeed_queue.capture(infeed_queue)\n\n    if signals is None:\n      return per_host_enqueue_ops\n    else:\n      return {\n          \'ops\': per_host_enqueue_ops,\n          \'signals\': signals,\n      }\n\n  return enqueue_ops_fn, captured_infeed_queue, dataset_initializer\n\n\ndef generate_broadcast_enqueue_ops_fn(ctx, input_fn, inputs_structure_recorder,\n                                      num_hosts):\n  """"""Generates infeed enqueue ops for one input_fn on all the hosts.""""""\n  captured_infeed_queue = _CapturedObject()\n  dataset_initializer = None\n  device_0 = ctx.tpu_host_placement_function(host_id=0)\n  with ops.device(device_0):\n    user_context = tpu_context.TPUContext(\n        internal_ctx=ctx, input_device=device_0, invocation_index=0)\n    inputs = _Inputs.from_input_fn(input_fn(user_context))\n\n    is_dataset = inputs.is_dataset\n    if ctx.mode == model_fn_lib.ModeKeys.PREDICT:\n      if not is_dataset:\n        raise TypeError(\n            \'For mode PREDICT, `input_fn` must return `Dataset` instead of \'\n            \'`features` and `labels`.\')\n\n      inputs = _InputsWithStoppingSignals(\n          dataset=inputs.dataset,\n          batch_size=ctx.batch_size_for_input_fn,\n          add_padding=True)\n\n    if is_dataset:\n      dataset_initializer = inputs.dataset_initializer()\n    num_replicas_per_host = ctx.num_of_replicas_per_host\n\n  def tpu_ordinal_function_impl(replica_id):\n    if ctx.device_assignment:\n      return ctx.device_assignment.tpu_ordinal(replica=replica_id)\n    else:\n      return replica_id % num_replicas_per_host\n\n  def device_function_impl(replica_id):\n    return ctx.tpu_host_placement_function(replica_id=replica_id)\n\n  def enqueue_ops_fn():\n    """"""Generates enqueue ops for all the hosts.""""""\n    broadcasted_inputs = []\n    flattened_inputs = None  # Cache result from input_fn.\n    signals = None\n    for host_id in xrange(num_hosts):\n      with ops.device(ctx.tpu_host_placement_function(host_id=host_id)):\n        for _ in xrange(ctx.num_of_replicas_per_host):\n          # Note: input_fn is only called once at host 0 for the first replica.\n          # The features and labels returned from that invocation are\n          # broadcasted to other replicas(including the replicas on other\n          # hosts).\n          if flattened_inputs is None:\n            features, labels = inputs.features_and_labels()  # Calls get_next()\n            signals = inputs.signals()\n\n            inputs_structure_recorder.validate_and_record_structure(\n                features, labels)\n            flattened_inputs = (\n                inputs_structure_recorder.flatten_features_and_labels(\n                    features, labels, signals))\n          broadcasted_inputs.append(flattened_inputs)\n\n    infeed_queue = tpu_feed.InfeedQueue(\n        number_of_tuple_elements=len(broadcasted_inputs[0]))\n    captured_infeed_queue.capture(infeed_queue)\n    enqueue_ops = infeed_queue.generate_enqueue_ops(\n        broadcasted_inputs,\n        tpu_ordinal_function=tpu_ordinal_function_impl,\n        placement_function=device_function_impl)\n\n    if signals is None:\n      return enqueue_ops\n    else:\n      return {\n          \'ops\': enqueue_ops,\n          \'signals\': signals,\n      }\n\n  return enqueue_ops_fn, captured_infeed_queue, dataset_initializer\n\n\nclass _InputPipeline(object):\n  """"""`_InputPipeline` handles invoking `input_fn` and piping to infeed queue.\n\n  `_InputPipeline` abstracts the per-core/per-host `input_fn` invocation from\n  call site.  To be precise, based on the configuration in\n  `_InternalTPUContext`,  it invokes `input_fn` for all cores (usually\n  multi-host TPU training) or for one host (usually for single-host TPU\n  evaluation), and sends all `features` and `labels` returned by `input_fn` to\n  TPU infeed. For per-core invocation, `features` and `labels` are piped to\n  infeed directly, one tuple for each core. For per-host invocation,  `features`\n  and `labels` are split at host (with respect to `batch_axis`) and piped to all\n  cores accordingly.\n\n  In addition, flatten/unflatten are handled by `_InputPipeline` also.  Model\n  inputs returned by the `input_fn` can have one of the following forms:\n  1. features\n  2. (features, labels)\n  3. ((arbitrarily nested structure of features), labels)\n\n  Internally, form 1 is reformed to `(features, None)` as features and labels\n  are passed separately to underlying methods. For TPU training, TPUEstimator\n  may expect multiple `features` and `labels` tuples one for each core.\n\n  TPUEstimator allows various different structures for inputs (namely `features`\n  and `labels`).  Both `features` and `labels` can be any nested sturcture\n  supported by TF nest (namely, dict, tuples, namedtuples or any nested\n  structure of such of Tensors).  `labels` could be `None` as well.\n\n  These are flattened before they are passed to the infeed/outfeed library\n  as that expectes flattend lists.\n  """"""\n\n  class InputsStructureRecorder(object):\n    """"""The recorder to record inputs structure.""""""\n\n    def __init__(self, input_partition_dims=None):\n      # Holds the structure of inputs\n      self._feature_structure = {}\n      self._flattened_input_dims = None\n\n      if input_partition_dims:\n        # This should have been validated in TPUConfig.\n        assert len(input_partition_dims) <= 2, \'must have 1 or 2 elements.\'\n        if len(input_partition_dims) == 2:\n          self._feature_dims, self._label_dims = input_partition_dims\n        else:\n          self._feature_dims = input_partition_dims[0]\n          self._label_dims = None\n\n        assert self._feature_dims is not None, (\'input_partition_dims[0] must \'\n                                                \'not be None\')\n      else:\n        self._feature_dims = None\n        self._label_dims = None\n\n      # Internal state.\n      self._initialized = False\n\n    @property\n    def flattened_input_dims(self):\n      assert self._initialized, \'InputsStructureRecorder is not initialized.\'\n      return self._flattened_input_dims\n\n    def has_labels(self):\n      return \'labels\' in self._feature_structure\n\n    def _flatten_input_dims(self, feature_dims, feature_dims_names, label_dims,\n                            label_dims_names, label_names, has_labels):\n      """"""Flatten input dims with the same order as flattened input tensors.""""""\n      flattened_input_dims = []\n      if feature_dims_names:\n        # We need a fixed ordering for matching the tensors in features.\n        flattened_input_dims.extend(\n            [feature_dims[name] for name in feature_dims_names])\n      else:\n        flattened_input_dims.append(feature_dims)\n\n      if label_dims_names:\n        # We need a fixed ordering for matching the tensors in labels.\n        flattened_input_dims.extend(\n            [label_dims[name] for name in label_dims_names])\n      else:\n        if label_names:\n          num_tensors_in_label = len(label_names)\n        else:\n          num_tensors_in_label = int(has_labels)\n        # Setting `None` in input_partition_dims[1] will apply `None` to\n        # all the tensors in labels, regardless of internal structure.\n        flattened_input_dims.extend([label_dims] * num_tensors_in_label)\n\n      return flattened_input_dims\n\n    def validate_and_record_structure(self, features, labels):\n      """"""Validates and records the structure of `features` and `labels`.""""""\n      # Extract structure.\n      has_labels = labels is not None\n      feature_names = _extract_key_names(features)\n      label_names = _extract_key_names(labels)\n\n      if not self._initialized:\n        # Record structure.\n        self._initialized = True\n        if self._feature_dims is not None:\n          feature_dims_names = _extract_key_names(self._feature_dims)\n          if feature_dims_names != feature_names:\n            raise ValueError(\n                \'TPUConfig.input_partition_dims[0] mismatched feature\'\n                \' keys. Expected {}, got {}\'.format(feature_names,\n                                                    feature_dims_names))\n\n          label_dims_names = _extract_key_names(self._label_dims)\n          if self._label_dims is not None and label_dims_names != label_names:\n            raise ValueError(\n                \'TPUConfig.input_partition_dims[1] mismatched label\'\n                \' keys. Expected {}, got {}\'.format(label_names,\n                                                    label_dims_names))\n\n          self._flattened_input_dims = self._flatten_input_dims(\n              self._feature_dims, feature_dims_names, self._label_dims,\n              label_dims_names, label_names, has_labels)\n\n    def flatten_features_and_labels(self, features, labels, signals=None):\n      """"""Flattens the `features` and `labels` to a single tensor list.""""""\n      self._feature_structure[\'features\'] = features\n      if labels is not None:\n        self._feature_structure[\'labels\'] = labels\n      if signals is not None:\n        self._feature_structure[\'signals\'] = signals\n      return data_nest.flatten(self._feature_structure)\n\n    def unflatten_features_and_labels(self, flattened_inputs):\n      """"""Restores the flattened inputs to original features and labels form.\n\n      Args:\n        flattened_inputs: Flattened inputs for each shard.\n\n      Returns:\n        A tuple of (`features`, `labels`), where `labels` could be None.\n        Each one, if present, should have identical structure (single tensor vs\n        dict) as the one returned by input_fn.\n\n      Raises:\n        ValueError: If the number of expected tensors from `flattened_inputs`\n          mismatches the recorded structure.\n      """"""\n\n      unflattened_inputs = data_nest.pack_sequence_as(self._feature_structure,\n                                                      flattened_inputs)\n      return _Inputs(\n          unflattened_inputs[\'features\'],\n          unflattened_inputs.get(\'labels\'),\n          signals=unflattened_inputs.get(\'signals\'))\n\n  def __init__(self, input_fn, batch_axis, ctx):\n    """"""Constructor.\n\n    Args:\n      input_fn: input fn for train or eval.\n      batch_axis: A python tuple of int values describing how each tensor\n        produced by the Estimator `input_fn` should be split across the TPU\n        compute shards.\n      ctx: A `_InternalTPUContext` instance with mode.\n\n    Raises:\n      ValueError: If both `sharded_features` and `num_cores` are `None`.\n    """"""\n    self._inputs_structure_recorder = _InputPipeline.InputsStructureRecorder(\n        ctx.input_partition_dims)\n\n    self._sharded_per_core = ctx.is_input_sharded_per_core()\n    self._input_fn = input_fn\n    self._infeed_queue = None\n    self._ctx = ctx\n    self._batch_axis = batch_axis\n\n  def generate_infeed_enqueue_ops_and_dequeue_fn(self):\n    """"""Generates infeed enqueue ops and dequeue_fn.""""""\n    # While tf.while_loop is called, the body function, which invokes\n    # `enqueue_fn` passed in, is called to construct the graph. So, input_fn\n    # structure is recorded.\n    enqueue_ops, all_hooks, run_infeed_loop_on_coordinator = (\n        self._invoke_input_fn_and_record_structure())\n\n    self._validate_input_pipeline()\n\n    def dequeue_fn():\n      """"""dequeue_fn is used by TPU to retrieve the tensors.""""""\n      # In the model-parallel case, both the host-side and device-side\n      # computations must agree on the core on which infeed takes place. We\n      # choose to perform infeed on logical core 0 of each replica.\n      values = self._infeed_queue.generate_dequeue_op(tpu_device=0)\n      # The unflatten process uses the structure information recorded above.\n      return self._inputs_structure_recorder.unflatten_features_and_labels(\n          values)\n\n    return (enqueue_ops, dequeue_fn, all_hooks, run_infeed_loop_on_coordinator)\n\n  def _invoke_input_fn_and_record_structure(self):\n    """"""Deploys the input pipeline and record input structure.""""""\n    enqueue_ops = []\n    infeed_queues = []\n    all_dataset_initializers = []\n    num_hosts = self._ctx.num_hosts\n    tpu_host_placement_fn = self._ctx.tpu_host_placement_function\n\n    run_infeed_loop_on_coordinator = True\n\n    if self._sharded_per_core:\n      # Per-Core input pipeline deployment.\n      # Invoke input pipeline for each core and placed on the corresponding\n      # host.\n      for host_id in range(num_hosts):\n        host_device = tpu_host_placement_fn(host_id=host_id)\n        with ops.device(host_device):\n          with ops.name_scope(\'input_pipeline_task%d\' % (host_id)):\n            enqueue_ops_fn, captured_infeed_queue = (\n                generate_per_core_enqueue_ops_fn_for_host(\n                    self._ctx, self._input_fn, self._inputs_structure_recorder,\n                    host_device, host_id))\n\n            if _WRAP_INPUT_FN_INTO_WHILE_LOOP:\n              run_infeed_loop_on_coordinator = False\n              enqueue_ops.append(\n                  _wrap_computation_in_while_loop(\n                      device=host_device, op_fn=enqueue_ops_fn))\n            else:\n              enqueue_ops.append(enqueue_ops_fn())\n            # Infeed_queue_getter must be called after enqueue_ops_fn is called.\n            infeed_queues.append(captured_infeed_queue.get())\n\n    elif self._ctx.is_input_broadcast_with_iterators():\n      # Only calls input_fn in host 0.\n      host_device = tpu_host_placement_fn(host_id=0)\n      enqueue_ops_fn, captured_infeed_queue, dataset_initializer = (\n          generate_broadcast_enqueue_ops_fn(self._ctx, self._input_fn,\n                                            self._inputs_structure_recorder,\n                                            num_hosts))\n      if dataset_initializer:\n        all_dataset_initializers.append(dataset_initializer)\n        run_infeed_loop_on_coordinator = False\n        wrap_fn = (\n            _wrap_computation_in_while_loop\n            if self._ctx.mode != model_fn_lib.ModeKeys.PREDICT else\n            _wrap_computation_in_while_loop_with_stopping_signals)\n        enqueue_ops.append(wrap_fn(device=host_device, op_fn=enqueue_ops_fn))\n      else:\n        enqueue_ops.append(enqueue_ops_fn())\n      infeed_queues.append(captured_infeed_queue.get())\n    else:\n      for host_id in range(num_hosts):\n        host_device = tpu_host_placement_fn(host_id=host_id)\n        with ops.device(host_device):\n          with ops.name_scope(\'input_pipeline_task%d\' % (host_id)):\n            if self._ctx.is_input_per_host_with_iterators():\n              enqueue_ops_fn, captured_infeed_queue, dataset_initializer = (\n                  generate_per_host_v2_enqueue_ops_fn_for_host(\n                      self._ctx, self._input_fn,\n                      self._inputs_structure_recorder, host_device, host_id))\n            else:\n              enqueue_ops_fn, captured_infeed_queue, dataset_initializer = (\n                  generate_per_host_enqueue_ops_fn_for_host(\n                      self._ctx, self._input_fn,\n                      self._inputs_structure_recorder, self._batch_axis,\n                      host_device, host_id))\n\n            # NOTE(xiejw): We dispatch here based on the return type of the\n            # users `input_fn`.\n            #\n            # 1. If input_fn returns a Dataset instance, we initialize the\n            # iterator outside of tf.while_loop, and call the iterator.get_next\n            # inside tf.while_loop.  This should be always safe.\n            #\n            # 2. If input_fn returns (features, labels), it is too late to wrap\n            # them inside tf.while_loop, as resource initialization cannot be\n            # handled in TF control flow properly. In this case, we will use\n            # python loop to enqueue the data into TPU system.  This may be\n            # slow compared to the previous case.\n            if dataset_initializer:\n              all_dataset_initializers.append(dataset_initializer)\n              run_infeed_loop_on_coordinator = False\n              wrap_fn = (\n                  _wrap_computation_in_while_loop\n                  if self._ctx.mode != model_fn_lib.ModeKeys.PREDICT else\n                  _wrap_computation_in_while_loop_with_stopping_signals)\n              enqueue_ops.append(\n                  wrap_fn(device=host_device, op_fn=enqueue_ops_fn))\n            else:\n              enqueue_ops.append(enqueue_ops_fn())\n            infeed_queues.append(captured_infeed_queue.get())\n    # infeed_queue is used to generate dequeue ops. The only thing it uses for\n    # dequeue is dtypes and types. So, any one can be used. Here, grab the\n    # first one.\n    self._infeed_queue = infeed_queues[0]\n    return enqueue_ops, [\n        util_lib.MultiHostDatasetInitializerHook(all_dataset_initializers)\n    ], run_infeed_loop_on_coordinator\n\n  def _validate_input_pipeline(self):\n    """"""Validates the input pipeline.\n\n    Perform some sanity checks to log user friendly information. We should\n    error out to give users better error message. But, if\n    _WRAP_INPUT_FN_INTO_WHILE_LOOP is False (legacy behavior), we cannot break\n    user code, so, log a warning.\n\n    Raises:\n      RuntimeError: If the validation failed.\n    """"""\n    if ops.get_default_graph().get_collection(ops.GraphKeys.QUEUE_RUNNERS):\n      err_msg = (\'Input pipeline contains one or more QueueRunners. \'\n                 \'It could be slow and not scalable. Please consider \'\n                 \'converting your input pipeline to use `tf.data` instead (see \'\n                 \'https://www.tensorflow.org/guide/datasets for \'\n                 \'instructions.\')\n      if _WRAP_INPUT_FN_INTO_WHILE_LOOP:\n        raise RuntimeError(err_msg)\n      else:\n        logging.warn(err_msg)\n\n\nclass _ModelFnWrapper(object):\n  """"""A `model_fn` wrapper.\n\n  This makes calling model_fn on CPU and TPU easier and more consistent and\n  performs necessary check and mutation required by TPU training and evaluation.\n\n  In addition, this wrapper manages converting the `model_fn` to a single TPU\n  train and eval step.\n  """"""\n\n  def __init__(self, model_fn, train_cache_fn, eval_cache_fn, config, params, ctx):\n    self._model_fn = model_fn\n    self._train_cache_fn = train_cache_fn\n    self._eval_cache_fn = eval_cache_fn\n    self._config = config\n    self._params = params\n    self._ctx = ctx\n\n  def call_without_tpu(self, features, labels, is_export_mode):\n    return self._call_model_fn(features, labels, is_export_mode=is_export_mode)\n\n  def convert_to_single_tpu_train_step(self, dequeue_fn):\n    """"""Converts user provided model_fn` as a single train step on TPU.\n\n    The user provided `model_fn` takes input tuple\n    (features, labels) and produces the EstimatorSpec with train_op and loss for\n    train `mode`. This usually represents a single train computation on CPU.\n\n    For TPU training, a train (computation) step is first wrapped in a\n    tf.while_loop control flow to repeat for many times and then replicated to\n    all TPU shards. Besides the input should be taken from TPU infeed rather\n    than input pipeline (input_fn) directly. To fit TPU loop and replicate\n    pattern, the original train computation should be reformed, which is the\n    returned `train_step`.\n\n    Args:\n      dequeue_fn: The function to retrieve inputs, features and labels, from TPU\n        infeed dequeue channel.\n\n    Returns:\n      A tuple of train_fn, host_calls, and captured scaffold_fn. The train_fn\n      representing the train step for TPU.\n    """"""\n\n    host_call = _OutfeedHostCall(self._ctx)\n    captured_scaffold_fn = _CapturedObject()\n    captured_training_hooks = _CapturedObject()\n\n    def train_step(loss, *cache):\n      """"""Training step function for use inside a while loop.""""""\n      del loss  # unused; required in function signature.\n      inputs = dequeue_fn()\n      features, labels = inputs.features_and_labels()\n\n      # Consume the current cache\n      estimator_spec = self._verify_estimator_spec(\n          self._call_model_fn(features, labels, cache=cache))\n\n      # Retrieve the new returned cache\n      """"""\n        `cache` consists of a list of tensors, potentially empty (of length 0)\n      """"""\n      cache = estimator_spec.cache\n      loss, train_op = estimator_spec.loss, estimator_spec.train_op\n\n      if isinstance(estimator_spec, model_fn_lib._TPUEstimatorSpec):  # pylint: disable=protected-access\n        captured_scaffold_fn.capture(estimator_spec.scaffold_fn)\n      else:\n        captured_scaffold_fn.capture(None)\n\n      captured_training_hooks.capture(estimator_spec.training_hooks)\n\n      tracing_ops = []\n      if tensor_tracer.TensorTracer.is_enabled():\n        tt = tensor_tracer.TensorTracer()\n        loss, tracing_ops = tt.trace_tpu(ops.get_default_graph(), loss,\n                                         self._ctx.num_replicas)\n\n      # We must run train_op to update the variables prior to running the\n      # outfeed.\n      with ops.control_dependencies([train_op]+tracing_ops):\n        host_call_outfeed_ops = []\n        if (isinstance(estimator_spec, model_fn_lib._TPUEstimatorSpec)  # pylint: disable=protected-access\n            and estimator_spec.host_call is not None):\n          host_call.record({\'host_call\': estimator_spec.host_call})\n          host_call_outfeed_ops = host_call.create_enqueue_op()\n        with ops.control_dependencies(host_call_outfeed_ops):\n          return [array_ops.identity(loss)] + cache\n\n    return (train_step, host_call, captured_scaffold_fn,\n            captured_training_hooks)\n\n  def convert_to_single_tpu_eval_step(self, dequeue_fn):\n    """"""Converts user provided model_fn` as a single eval step on TPU.\n\n    Similar to training, the user provided `model_fn` takes input tuple\n    (features, labels) and produces the TPUEstimatorSpec with eval_metrics for\n    eval `mode`. This usually represents a single evaluation computation on CPU.\n\n    For TPU evaluation, a eval (computation) step is first wrapped in a\n    tf.while_loop control flow to repeat for many times and then replicated to\n    all TPU shards. Besides the input and output are slightly different. Input,\n    features and labels, should be taken from TPU infeed rather than input\n    pipeline (input_fn) directly. Output is managed in two stages.  First, the\n    model outputs as the result of evaluation computation, usually model logits,\n    should be transferred from TPU system to CPU. Then, all model outputs are\n    concatenated first on CPU and sent to the metric_fn for metrics computation.\n    To fit TPU evaluation pattern, the original eval computation should be\n    reformed, which is the returned `eval_step`.\n\n    Args:\n      dequeue_fn: The function to retrieve inputs, features and labels, from TPU\n        infeed dequeue channel.\n\n    Returns:\n      A tuple of eval_fn, host_calls, and captured scaffold_fn. The eval_fn\n      representing the eval step for TPU.\n    """"""\n    host_calls = _OutfeedHostCall(self._ctx)\n    captured_scaffold_fn = _CapturedObject()\n    captured_eval_hooks = _CapturedObject()\n\n    def eval_step(total_loss, *cache):\n      """"""Evaluation step function for use inside a while loop.""""""\n      inputs = dequeue_fn()\n      features, labels = inputs.features_and_labels()\n\n      # Consume the current cache\n      tpu_estimator_spec = self._call_model_fn(features, labels, cache=cache)\n      if not isinstance(tpu_estimator_spec, model_fn_lib._TPUEstimatorSpec):  # pylint: disable=protected-access\n        raise RuntimeError(\n            \'estimator_spec used by TPU evaluation must have type\'\n            \'`TPUEstimatorSpec`. Got {}\'.format(type(tpu_estimator_spec)))\n\n      # Retrieve the new returned cache\n      cache = tpu_estimator_spec.cache\n      loss = tpu_estimator_spec.loss\n\n      captured_scaffold_fn.capture(tpu_estimator_spec.scaffold_fn)\n      captured_eval_hooks.capture(tpu_estimator_spec.evaluation_hooks)\n\n      to_record = {}\n      if tpu_estimator_spec.eval_metrics:\n        to_record[\'eval_metrics\'] = tpu_estimator_spec.eval_metrics\n      if tpu_estimator_spec.host_call is not None:\n        # We assume that evaluate won\'t update global step, so we don\'t wrap\n        # this host_call.\n        to_record[\'host_call\'] = tpu_estimator_spec.host_call\n      host_calls.record(to_record)\n\n      with ops.control_dependencies(host_calls.create_enqueue_op()):\n        return [math_ops.add(total_loss, loss)] + cache\n\n    return eval_step, host_calls, captured_scaffold_fn, captured_eval_hooks\n\n  def convert_to_single_tpu_predict_step(self, dequeue_fn):\n    """"""Converts user provided model_fn` as a single predict step on TPU.\n\n    Args:\n      dequeue_fn: The function to retrieve inputs, features and labels, from TPU\n        infeed dequeue channel.\n\n    Returns:\n      A tuple of predict_fn, host_calls, and captured scaffold_fn. The\n      predict_fn representing the predict step for TPU.\n    """"""\n    host_calls = _OutfeedHostCall(self._ctx)\n    captured_scaffold_fn = _CapturedObject()\n    captured_predict_hooks = _CapturedObject()\n\n    def predict_step(unused_scalar_stopping_signal):\n      """"""Evaluation step function for use inside a while loop.""""""\n      inputs = dequeue_fn()\n      features, labels = inputs.features_and_labels()\n      stopping_signals = inputs.signals()\n\n      assert stopping_signals is not None, (\n          \'Internal Error: `signals` is missing.\')\n\n      tpu_estimator_spec = self._call_model_fn(\n          features, labels, is_export_mode=False)\n      if not isinstance(tpu_estimator_spec, model_fn_lib._TPUEstimatorSpec):  # pylint: disable=protected-access\n        raise RuntimeError(\n            \'estimator_spec used by TPU prediction must have type\'\n            \'`TPUEstimatorSpec`. Got {}\'.format(type(tpu_estimator_spec)))\n\n      self._verify_tpu_spec_predictions(tpu_estimator_spec.predictions)\n\n      captured_scaffold_fn.capture(tpu_estimator_spec.scaffold_fn)\n      captured_predict_hooks.capture(tpu_estimator_spec.prediction_hooks)\n      to_record = {}\n      identity_fn = lambda **kwargs: kwargs\n      to_record[\'predictions\'] = [identity_fn, tpu_estimator_spec.predictions]\n      to_record[\'signals\'] = [identity_fn, stopping_signals]\n      if tpu_estimator_spec.host_call is not None:\n        to_record[\'host_call\'] = tpu_estimator_spec.host_call\n      host_calls.record(to_record)\n\n      with ops.control_dependencies(host_calls.create_enqueue_op()):\n        return _StopSignals.as_scalar_stopping_signal(stopping_signals)\n\n    return (predict_step, host_calls, captured_scaffold_fn,\n            captured_predict_hooks)\n\n  def _verify_tpu_spec_predictions(self, predictions):\n    """"""Validates TPUEstimatorSpec.predictions dict.""""""\n    # TODO(xiejw): Adds validation for prediction dictionrary.\n    # TODO(xiejw): Adds support for single tensor as predictions.\n    if not isinstance(predictions, dict):\n      raise TypeError(\'TPUEstimatorSpec.predictions must be dict of Tensors.\')\n\n    for (key, tensor) in predictions.items():\n      if tensor.shape.dims[0].value is None:\n        raise ValueError(\n            \'The tensor with key ({}) in TPUEstimatorSpec.predictions has \'\n            \'dynamic shape (should be static). Tensor: {}\'.format(key, tensor))\n    return predictions\n\n  def _validate_model_features_and_labels(self, features, labels,\n                                          is_export_mode):\n    """"""Validates that the features and labels for the model function are valid.\n\n    A valid features/labels object is the one with:\n    - Type: A tensor or any nested structure of tensors supported by TF nest,\n        namely nested dictionary, tuple, namedtuple, or sequence of tensors.\n    - Static shape if is_export_mode is False.\n\n    Args:\n      features: the features that would be input to the model function.\n      labels: the labels that would be input to the model function.\n      is_export_mode: boolean value specifying if in export mode.\n\n    Raises:\n      TypeError: If features/labels are not of the correct type.\n      ValueError: If features/labels have dynamic shape.\n    """"""\n\n    def validate(obj, obj_name):\n      """"""Helper validate function.""""""\n      if is_export_mode or self._ctx.is_running_on_cpu(is_export_mode):\n        return\n      if isinstance(obj, ops.Tensor):\n        if not obj.get_shape().is_fully_defined():\n          raise ValueError(\n              \'The {} to the model returned by input_fn must have static shape.\'\n              \' Tensor: {}\'.format(obj_name, obj))\n      else:\n        for tensor in data_nest.flatten(obj):\n          if not tensor.get_shape().is_fully_defined():\n            raise ValueError(\n                (\'The {} to the model returned by input_fn must have static \'\n                 \'shape. Tensor: {}\').format(obj_name, tensor))\n\n    validate(features, \'features\')\n    if labels is not None:\n      validate(labels, \'labels\')\n\n  def _call_model_fn(self, features, labels, cache=None, is_export_mode=False):\n    """"""Calls the model_fn with required parameters.""""""\n    self._validate_model_features_and_labels(features, labels, is_export_mode)\n    model_fn_args = function_utils.fn_args(self._model_fn)\n    kwargs = {}\n\n    # Makes deep copy with `config` and params` in case user mutates them.\n    config = copy.deepcopy(self._config)\n    params = copy.deepcopy(self._params)\n\n    if \'labels\' in model_fn_args:\n      kwargs[\'labels\'] = labels\n    elif labels is not None:\n      raise ValueError(\n          \'model_fn does not take labels, but input_fn returns labels.\')\n    if \'mode\' in model_fn_args:\n      kwargs[\'mode\'] = self._ctx.mode\n    if \'config\' in model_fn_args:\n      kwargs[\'config\'] = config\n    if \'params\' in model_fn_args:\n      kwargs[\'params\'] = params\n\n    if cache is not None:\n      params[\'cache\'] = cache\n\n    if \'params\' not in model_fn_args:\n      raise ValueError(\'model_fn ({}) does not include params argument, \'\n                       \'required by TPUEstimator to pass batch size as \'\n                       \'params[\\\'batch_size\\\']\'.format(self._model_fn))\n\n    if is_export_mode:\n      batch_size_for_model_fn = None\n    else:\n      batch_size_for_model_fn = self._ctx.batch_size_for_model_fn\n\n    if batch_size_for_model_fn is not None:\n      _add_item_to_params(params, _BATCH_SIZE_KEY, batch_size_for_model_fn)\n\n    running_on_cpu = self._ctx.is_running_on_cpu(is_export_mode)\n    _add_item_to_params(params, _USE_TPU_KEY, not running_on_cpu)\n\n    if not running_on_cpu:\n      user_context = tpu_context.TPUContext(\n          internal_ctx=self._ctx, call_from_input_fn=False)\n      _add_item_to_params(params, _CTX_KEY, user_context)\n\n    estimator_spec = self._model_fn(features=features, **kwargs)\n    if (running_on_cpu and\n        isinstance(estimator_spec, model_fn_lib._TPUEstimatorSpec)):  # pylint: disable=protected-access\n      # The estimator_spec will be passed to `Estimator` directly, which expects\n      # type `EstimatorSpec`.\n      return estimator_spec.as_estimator_spec()\n    else:\n      return estimator_spec\n\n  def _verify_estimator_spec(self, estimator_spec):\n    """"""Validates the estimator_spec.""""""\n    if isinstance(estimator_spec, model_fn_lib._TPUEstimatorSpec):  # pylint: disable=protected-access\n      return estimator_spec\n\n    err_msg = \'{} returned by EstimatorSpec is not supported in TPUEstimator.\'\n    if estimator_spec.training_chief_hooks:\n      raise ValueError(\n          err_msg.format(\'training_chief_hooks\') + \'If you want\' +\n          \' to pass training hooks, please pass via training_hooks.\')\n\n    if estimator_spec.scaffold:\n      logging.warning(\'EstimatorSpec.Scaffold is ignored by TPU train/eval. \'\n                      \'Please use TPUEstimatorSpec.\')\n    return estimator_spec\n\n\nclass _OutfeedHostCall(object):\n  """"""Support for `eval_metrics` and `host_call` in TPUEstimatorSpec.""""""\n\n  def __init__(self, ctx):\n    self._ctx = ctx\n    self._names = []\n    # All of these are dictionaries of lists keyed on the name.\n    self._host_fns = {}\n    self._tensor_keys = collections.defaultdict(list)\n    self._tensors = collections.defaultdict(list)\n    self._tensor_dtypes = collections.defaultdict(list)\n    self._tensor_shapes = collections.defaultdict(list)\n\n  @staticmethod\n  def validate(host_calls):\n    """"""Validates the `eval_metrics` and `host_call` in `TPUEstimatorSpec`.""""""\n\n    for name, host_call in host_calls.items():\n      if not isinstance(host_call, (tuple, list)):\n        raise ValueError(\'{} should be tuple or list\'.format(name))\n      if len(host_call) != 2:\n        raise ValueError(\'{} should have two elements.\'.format(name))\n      if not callable(host_call[0]):\n        raise TypeError(\'{}[0] should be callable.\'.format(name))\n      if not isinstance(host_call[1], (tuple, list, dict)):\n        raise ValueError(\'{}[1] should be tuple or list, or dict.\'.format(name))\n\n      if isinstance(host_call[1], (tuple, list)):\n        fullargspec = tf_inspect.getfullargspec(host_call[0])\n        fn_args = function_utils.fn_args(host_call[0])\n        # wrapped_hostcall_with_global_step uses varargs, so we allow that.\n        if fullargspec.varargs is None and len(host_call[1]) != len(fn_args):\n          raise RuntimeError(\n              \'In TPUEstimatorSpec.{}, length of tensors {} does not match \'\n              \'method args of the function, which takes {}.\'.format(\n                  name, len(host_call[1]), len(fn_args)))\n\n  @staticmethod\n  def create_cpu_hostcall(host_calls):\n    """"""Runs on the host_call on CPU instead of TPU when use_tpu=False.""""""\n\n    _OutfeedHostCall.validate(host_calls)\n    ret = {}\n    for name, host_call in host_calls.items():\n      host_fn, tensors = host_call\n      if isinstance(tensors, (tuple, list)):\n        ret[name] = host_fn(*tensors)\n      else:\n        # Must be dict.\n        try:\n          ret[name] = host_fn(**tensors)\n        except TypeError as e:\n          logging.warning(\n              \'Exception while calling %s: %s. It is likely the tensors \'\n              \'(%s[1]) do not match the \'\n              \'function\\\'s arguments\', name, e, name)\n          raise e\n    return ret\n\n  def record(self, host_calls):\n    """"""Records the host_call structure.""""""\n\n    for name, host_call in host_calls.items():\n      host_fn, tensor_list_or_dict = host_call\n      self._names.append(name)\n      self._host_fns[name] = host_fn\n\n      if isinstance(tensor_list_or_dict, dict):\n        for (key, tensor) in six.iteritems(tensor_list_or_dict):\n          self._tensor_keys[name].append(key)\n          self._tensors[name].append(tensor)\n          self._tensor_dtypes[name].append(tensor.dtype)\n          self._tensor_shapes[name].append(tensor.shape)\n      else:\n        # List or tuple.\n        self._tensor_keys[name] = None\n        for tensor in tensor_list_or_dict:\n          self._tensors[name].append(tensor)\n          self._tensor_dtypes[name].append(tensor.dtype)\n          self._tensor_shapes[name].append(tensor.shape)\n\n  def create_enqueue_op(self):\n    """"""Create the op to enqueue the recorded host_calls.\n\n    Returns:\n      A list of enqueue ops, which is empty if there are no host calls.\n    """"""\n    if not self._names:\n      return []\n\n    tensors = []\n    # TODO(jhseu): Consider deduping tensors.\n    for name in self._names:\n      tensors.extend(self._tensors[name])\n\n    with ops.device(tpu.core(0)):\n      return [tpu_ops.outfeed_enqueue_tuple(tensors)]\n\n  def create_tpu_hostcall(self):\n    """"""Sends the tensors through outfeed and runs the host_fn on CPU.\n\n    The tensors are concatenated along dimension 0 to form a global tensor\n    across all shards. The concatenated function is passed to the host_fn and\n    executed on the first host.\n\n    Returns:\n      A dictionary mapping name to the return type of the host_call by that\n      name.\n\n    Raises:\n      RuntimeError: If outfeed tensor is scalar.\n    """"""\n    if not self._names:\n      return {}\n\n    ret = {}\n    # For each i, dequeue_ops[i] is a list containing the tensors from all\n    # shards. This list is concatenated later.\n    dequeue_ops = []\n    tensor_dtypes = []\n    tensor_shapes = []\n    for name in self._names:\n      for _ in self._tensors[name]:\n        dequeue_ops.append([])\n      for dtype in self._tensor_dtypes[name]:\n        tensor_dtypes.append(dtype)\n      for shape in self._tensor_shapes[name]:\n        tensor_shapes.append(shape)\n\n    # Outfeed ops execute on each replica\'s first logical core. Note: we must\n    # constraint it such that we have at most one outfeed dequeue and enqueue\n    # per replica.\n    for i in xrange(self._ctx.num_replicas):\n      host_device, ordinal_id = self._ctx.device_for_replica(i)\n      with ops.device(host_device):\n        outfeed_tensors = tpu_ops.outfeed_dequeue_tuple(\n            dtypes=tensor_dtypes,\n            shapes=tensor_shapes,\n            device_ordinal=ordinal_id)\n        for j, item in enumerate(outfeed_tensors):\n          dequeue_ops[j].append(item)\n\n    # Deconstruct dequeue ops.\n    dequeue_ops_by_name = {}\n    pos = 0\n    for name in self._names:\n      dequeue_ops_by_name[name] = dequeue_ops[pos:pos +\n                                              len(self._tensors[name])]\n      pos += len(self._tensors[name])\n\n    # It is assumed evaluation always happens on single host TPU system. So,\n    # place all ops on tpu host if possible.\n    #\n    # TODO(jhseu): Evaluate whether this is right for summaries.\n    with ops.device(self._ctx.tpu_host_placement_function(replica_id=0)):\n      for name in self._names:\n        dequeue_ops = dequeue_ops_by_name[name]\n        for i, item in enumerate(dequeue_ops):\n          if dequeue_ops[i][0].shape.ndims == 0:\n            raise RuntimeError(\n                \'All tensors outfed from TPU should preserve batch size \'\n                \'dimension, but got scalar {}\'.format(dequeue_ops[i][0]))\n          # TODO(xiejw): Allow users to specify the axis for batch size\n          # dimension.\n          dequeue_ops[i] = array_ops.concat(dequeue_ops[i], axis=0)\n\n        if self._tensor_keys[name] is not None:\n          # The user-provided eval_metrics[1] is a dict.\n          dequeue_ops = dict(zip(self._tensor_keys[name], dequeue_ops))\n          try:\n            ret[name] = self._host_fns[name](**dequeue_ops)\n          except TypeError as e:\n            logging.warning(\n                \'Exception while calling %s: %s. It is likely the tensors \'\n                \'(%s[1]) do not match the \'\n                \'function\\\'s arguments\', name, e, name)\n            raise e\n        else:\n          ret[name] = self._host_fns[name](*dequeue_ops)\n\n    return ret\n\n\nclass _OutfeedHostCallHook(session_run_hook.SessionRunHook):\n  """"""Hook to run host calls when use_tpu=False.""""""\n\n  def __init__(self, tensors):\n    self._tensors = tensors\n\n  def begin(self):\n    # We duplicate this code from the TPUInfeedOutfeedSessionHook rather than\n    # create a separate hook to guarantee execution order, because summaries\n    # need to be initialized before the outfeed thread starts.\n    # TODO(jhseu): Make a wrapper hook instead?\n    self._init_ops = contrib_summary.summary_writer_initializer_op()\n    # Get all the writer resources from the initializer, so we know what to\n    # flush.\n    self._finalize_ops = []\n    for op in self._init_ops:\n      self._finalize_ops.append(contrib_summary.flush(writer=op.inputs[0]))\n\n  def after_create_session(self, session, coord):\n    session.run(self._init_ops)\n\n  def before_run(self, run_context):\n    return basic_session_run_hooks.SessionRunArgs(self._tensors)\n\n  def end(self, session):\n    session.run(self._finalize_ops)\n\n\nclass ExamplesPerSecondHook(basic_session_run_hooks.StepCounterHook):\n  """"""Calculate and report global_step/sec and examples/sec during runtime.""""""\n\n  def __init__(self,\n               batch_size,\n               every_n_steps=100,\n               every_n_secs=None,\n               output_dir=None,\n               summary_writer=None):\n    self._batch_size = batch_size\n    super(ExamplesPerSecondHook, self).__init__(\n        every_n_steps=every_n_steps,\n        every_n_secs=every_n_secs,\n        output_dir=output_dir,\n        summary_writer=summary_writer)\n\n  def _log_and_record(self, elapsed_steps, elapsed_time, global_step):\n    global_step_per_sec = elapsed_steps / elapsed_time\n    examples_per_sec = self._batch_size * global_step_per_sec\n    if self._summary_writer is not None:\n      global_step_summary = Summary(value=[\n          Summary.Value(tag=\'global_step/sec\', simple_value=global_step_per_sec)\n      ])\n      example_summary = Summary(value=[\n          Summary.Value(tag=\'examples/sec\', simple_value=examples_per_sec)\n      ])\n      self._summary_writer.add_summary(global_step_summary, global_step)\n      self._summary_writer.add_summary(example_summary, global_step)\n    logging.info(\'global_step/sec: %g\', global_step_per_sec)\n    logging.info(\'examples/sec: %g\', examples_per_sec)\n\n\nclass InstallSignalHandlerHook(session_run_hook.SessionRunHook):\n  """"""Change SIGINT (CTRL^C) handler to force quit the process.\n\n  The default behavior often results in hanging processes.\n  The original handler is restored after training/evaluation.\n  """"""\n\n  def __init__(self):\n    self._signal_fn = signal.getsignal(signal.SIGINT)\n\n  def before_run(self, run_context):\n    signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n  def end(self, session):\n    signal.signal(signal.SIGINT, self._signal_fn)\n\n\nclass TPUEstimator(estimator_lib.Estimator):\n  """"""Estimator with TPU support.\n\n  TPUEstimator also supports training on CPU and GPU. You don\'t need to define\n  a separate `tf.estimator.Estimator`.\n\n  TPUEstimator handles many of the details of running on TPU devices, such as\n  replicating inputs and models for each core, and returning to host\n  periodically to run hooks.\n\n  TPUEstimator transforms a global batch size in params to a per-shard batch\n  size when calling the `input_fn` and `model_fn`. Users should specify\n  global batch size in constructor, and then get the batch size for each shard\n  in `input_fn` and `model_fn` by `params[\'batch_size\']`.\n\n  - For training, `model_fn` gets per-core batch size; `input_fn` may get\n    per-core or per-host batch size depending on `per_host_input_for_training`\n    in `TPUConfig` (See docstring for TPUConfig for details).\n\n  - For evaluation and prediction, `model_fn` gets per-core batch size and\n    `input_fn` get per-host batch size.\n\n  Evaluation\n  ==========\n\n  `model_fn` should return `TPUEstimatorSpec`, which expects the `eval_metrics`\n  for TPU evaluation. However, if eval_on_tpu is False, `model_fn` must return\n  `EstimatorSpec` and the evaluation will execute on CPU or GPU; in this case\n  the following discussion on TPU evaluation does not apply.\n\n  `TPUEstimatorSpec.eval_metrics` is a tuple of `metric_fn` and `tensors`, where\n  `tensors` could be a list of any nested structure of `Tensor`s (See\n  `TPUEstimatorSpec` for details).  `metric_fn` takes the `tensors` and returns\n  a dict from metric string name to the result of calling a metric function,\n  namely a `(metric_tensor, update_op)` tuple.\n\n  One can set `use_tpu` to `False` for testing. All training, evaluation, and\n  predict will be executed on CPU. `input_fn` and `model_fn` will receive\n  `train_batch_size` or `eval_batch_size` unmodified as `params[\'batch_size\']`.\n\n  Current limitations:\n  --------------------\n\n  1. TPU evaluation only works on a single host (one TPU worker) except\n     BROADCAST mode.\n\n  2. `input_fn` for evaluation should **NOT** raise an end-of-input exception\n     (`OutOfRangeError` or `StopIteration`). And all evaluation steps and all\n     batches should have the same size.\n\n  Example (MNIST):\n  ----------------\n\n  ```\n  # The metric Fn which runs on CPU.\n  def metric_fn(labels, logits):\n    predictions = tf.argmax(logits, 1)\n    return {\n      \'accuracy\': tf.metrics.precision(\n          labels=labels, predictions=predictions),\n    }\n\n  # Your model Fn which runs on TPU (eval_metrics is list in this example)\n  def model_fn(features, labels, mode, config, params):\n    ...\n    logits = ...\n\n    if mode = tf.estimator.ModeKeys.EVAL:\n      return tpu_estimator.TPUEstimatorSpec(\n          mode=mode,\n          loss=loss,\n          eval_metrics=(metric_fn, [labels, logits]))\n\n  # or specify the eval_metrics tensors as dict.\n  def model_fn(features, labels, mode, config, params):\n    ...\n    final_layer_output = ...\n\n    if mode = tf.estimator.ModeKeys.EVAL:\n      return tpu_estimator.TPUEstimatorSpec(\n          mode=mode,\n          loss=loss,\n          eval_metrics=(metric_fn, {\n              \'labels\': labels,\n              \'logits\': final_layer_output,\n          }))\n  ```\n\n  Prediction\n  ==========\n\n  Prediction on TPU is an experimental feature to support large batch inference.\n  It is not designed for latency-critical system. In addition, due to some\n  usability issues, for prediction with small dataset, CPU `.predict`, i.e.,\n  creating a new `TPUEstimator` instance with `use_tpu=False`, might be more\n  convenient.\n\n  Note: In contrast to TPU training/evaluation, the `input_fn` for prediction\n  *should* raise an end-of-input exception (`OutOfRangeError` or\n  `StopIteration`), which serves as the stopping signal to `TPUEstimator`. To be\n  precise, the ops created by `input_fn` produce one batch of the data.\n  The `predict()` API processes one batch at a time. When reaching the end of\n  the data source, an end-of-input exception should be raised by one of these\n  operations. The user usually does not need to do this manually. As long as the\n  dataset is not repeated forever, the `tf.data` API will raise an end-of-input\n  exception automatically after the last batch has been produced.\n\n  Note: Estimator.predict returns a Python generator. Please consume all the\n  data from the generator so that TPUEstimator can shutdown the TPU system\n  properly for user.\n\n  Current limitations:\n  --------------------\n  1. TPU prediction only works on a single host (one TPU worker).\n\n  2. `input_fn` must return a `Dataset` instance rather than `features`. In\n  fact, .train() and .evaluate() also support Dataset as return value.\n\n  Example (MNIST):\n  ----------------\n  ```\n  height = 32\n  width = 32\n  total_examples = 100\n\n  def predict_input_fn(params):\n    batch_size = params[\'batch_size\']\n\n    images = tf.random_uniform(\n        [total_examples, height, width, 3], minval=-1, maxval=1)\n\n    dataset = tf.data.Dataset.from_tensor_slices(images)\n    dataset = dataset.map(lambda images: {\'image\': images})\n\n    dataset = dataset.batch(batch_size)\n    return dataset\n\n  def model_fn(features, labels, params, mode):\n     # Generate predictions, called \'output\', from features[\'image\']\n\n    if mode == tf.estimator.ModeKeys.PREDICT:\n      return tf.contrib.tpu.TPUEstimatorSpec(\n          mode=mode,\n          predictions={\n              \'predictions\': output,\n              \'is_padding\': features[\'is_padding\']\n          })\n\n  tpu_est = TPUEstimator(\n      model_fn=model_fn,\n      ...,\n      predict_batch_size=16)\n\n  # Fully consume the generator so that TPUEstimator can shutdown the TPU\n  # system.\n  for item in tpu_est.predict(input_fn=input_fn):\n    # Filter out item if the `is_padding` is 1.\n    # Process the \'predictions\'\n  ```\n\n  Exporting\n  =========\n\n  `export_savedmodel` exports 2 metagraphs, one with `tag_constants.SERVING`,\n  and another with `tag_constants.SERVING` and `tag_constants.TPU`.\n  At serving time, these tags are used to select metagraph to load.\n\n  Before running the graph on TPU, TPU system needs to be initialized. If\n  TensorFlow Serving model-server is used, this is done automatically. If\n  not, please call `session.run(tpu.initialize_system())`.\n\n  `tpu.outside_compilation` can be used to wrap TPU incompatible ops in\n  `model_fn`.\n\n  Example:\n  ----------------\n\n  ```\n  def model_fn(features, labels, mode, config, params):\n    ...\n    logits = ...\n    export_outputs = {\n      \'logits\': export_output_lib.PredictOutput(\n        {\'logits\': logits})\n    }\n\n    def host_call(logits):\n      class_ids = math_ops.argmax(logits)\n      classes = string_ops.as_string(class_ids)\n      export_outputs[\'classes\'] =\n        export_output_lib.ClassificationOutput(classes=classes)\n\n    tpu.outside_compilation(host_call, logits)\n\n    ...\n  ```\n\n  """"""\n\n  def __init__(self,\n               model_fn=None,\n               train_cache_fn=None,\n               eval_cache_fn=None,\n               model_dir=None,\n               config=None,\n               params=None,\n               use_tpu=True,\n               train_batch_size=None,\n               eval_batch_size=None,\n               predict_batch_size=None,\n               batch_axis=None,\n               eval_on_tpu=True,\n               export_to_tpu=True,\n               warm_start_from=None):\n    """"""Constructs an `TPUEstimator` instance.\n\n    Args:\n      model_fn: Model function as required by `Estimator` which returns\n        EstimatorSpec or TPUEstimatorSpec. `training_hooks`, \'evaluation_hooks\',\n        and `prediction_hooks` must not capure any TPU Tensor inside the\n        model_fn.\n      model_dir: Directory to save model parameters, graph and etc. This can\n        also be used to load checkpoints from the directory into a estimator to\n        continue training a previously saved model. If `None`, the model_dir in\n        `config` will be used if set. If both are set, they must be same. If\n        both are `None`, a temporary directory will be used.\n      config: An `tpu_config.RunConfig` configuration object. Cannot be `None`.\n      params: An optional `dict` of hyper parameters that will be passed into\n        `input_fn` and `model_fn`.  Keys are names of parameters, values are\n        basic python types. There are reserved keys for `TPUEstimator`,\n        including \'batch_size\'.\n      use_tpu: A bool indicating whether TPU support is enabled. Currently, -\n        TPU training and evaluation respect this bit, but eval_on_tpu can\n        override execution of eval. See below. - Predict still happens on CPU.\n      train_batch_size: An int representing the global training batch size.\n        TPUEstimator transforms this global batch size to a per-shard batch\n        size, as params[\'batch_size\'], when calling `input_fn` and `model_fn`.\n        Cannot be `None` if `use_tpu` is `True`. Must be divisible by total\n        number of replicas.\n      eval_batch_size: An int representing evaluation batch size. Must be\n        divisible by total number of replicas.\n      predict_batch_size: An int representing the prediction batch size. Must be\n        divisible by total number of replicas.\n      batch_axis: A python tuple of int values describing how each tensor\n        produced by the Estimator `input_fn` should be split across the TPU\n        compute shards. For example, if your input_fn produced (images, labels)\n        where the images tensor is in `HWCN` format, your shard dimensions would\n        be [3, 0], where 3 corresponds to the `N` dimension of your images\n        Tensor, and 0 corresponds to the dimension along which to split the\n        labels to match up with the corresponding images. If None is supplied,\n        and per_host_input_for_training is True, batches will be sharded based\n        on the major dimension. If tpu_config.per_host_input_for_training is\n        False or `PER_HOST_V2`, batch_axis is ignored.\n      eval_on_tpu: If False, evaluation runs on CPU or GPU. In this case, the\n        model_fn must return `EstimatorSpec` when called with `mode` as `EVAL`.\n      export_to_tpu: If True, `export_savedmodel()` exports a metagraph for\n        serving on TPU besides the one on CPU.\n      warm_start_from: Optional string filepath to a checkpoint or SavedModel to\n        warm-start from, or a `tf.estimator.WarmStartSettings` object to fully\n        configure warm-starting.  If the string filepath is provided instead of\n        a `WarmStartSettings`, then all variables are warm-started, and it is\n        assumed that vocabularies and Tensor names are unchanged.\n\n    Raises:\n      ValueError: `params` has reserved keys already.\n    """"""\n    if config is None or not isinstance(config, tpu_config.RunConfig):\n      raise ValueError(\n          \'`config` must be provided with type `tpu_config.RunConfig`\')\n\n    if params is not None and any(k in params for k in _RESERVED_PARAMS_KEYS):\n      raise ValueError(\'{} are reserved keys but existed in params {}.\'.format(\n          _RESERVED_PARAMS_KEYS, params))\n\n    if use_tpu:\n      # Perform some very basic validations. More validations will be found in\n      # _InternalTPUContext.\n      if train_batch_size is None:\n        raise ValueError(\'`train_batch_size` cannot be `None`\')\n      util_lib.check_positive_integer(train_batch_size, \'train_batch_size\')\n\n      if (config.tpu_config.per_host_input_for_training is\n          tpu_config.InputPipelineConfig.PER_SHARD_V1 and\n          config.tpu_config.num_cores_per_replica):\n        raise ValueError(\n            \'Model parallelism only supports per host input for training. \'\n            \'Please adjust TPURunconfig.per_host_input_for_training.\')\n\n      if eval_batch_size is not None:\n        util_lib.check_positive_integer(eval_batch_size, \'eval_batch_size\')\n\n      if predict_batch_size is not None:\n        util_lib.check_positive_integer(predict_batch_size,\n                                        \'predict_batch_size\')\n\n    # Verifies the model_fn signature according to Estimator framework.\n    estimator_lib._verify_model_fn_args(model_fn, params)  # pylint: disable=protected-access\n    # We cannot store config and params in this constructor as parent\n    # constructor might change them, such as assigning a temp dir for\n    # config.model_dir.\n    model_function = self._augment_model_fn(\n        model_fn,\n        train_cache_fn,\n        eval_cache_fn,\n        batch_axis)\n\n    # Overwrite log_step_count_steps to disable TensorLoggingHook and\n    # StepCounterHook from being created in Estimator. TPUEstimator already\n    # added equivalent hooks in _augment_model_fn above.\n    self._log_every_n_steps = config.log_step_count_steps\n    config = config.replace(log_step_count_steps=None)\n\n    # Passing non-None params as wrapped model_fn has it.\n    params = params or {}\n    super(TPUEstimator, self).__init__(\n        model_fn=model_function,\n        model_dir=model_dir,\n        config=config,\n        params=params,\n        warm_start_from=warm_start_from)\n    self._iterations_per_training_loop = (\n        self._config.tpu_config.iterations_per_loop)\n\n    # All properties passed to _InternalTPUContext are immutable.\n    # pylint: disable=protected-access\n    self._ctx = tpu_context._get_tpu_context(\n        self._config, train_batch_size, eval_batch_size, predict_batch_size,\n        use_tpu, eval_on_tpu)\n\n    self._export_to_tpu = export_to_tpu\n\n    self._is_input_fn_invoked = None\n    self._rendezvous = {}\n\n  def _add_meta_graph_for_mode(self,\n                               builder,\n                               input_receiver_fn_map,\n                               checkpoint_path,\n                               save_variables=True,\n                               mode=model_fn_lib.ModeKeys.PREDICT,\n                               export_tags=None,\n                               check_variables=True):\n    if self._export_to_tpu and mode != model_fn_lib.ModeKeys.PREDICT:\n      raise NotImplementedError(\n          \'TPUEstimator only handles mode PREDICT for exporting \'\n          \'when `export_to_tpu` is `True`; \'\n          \'got {}.\'.format(mode))\n\n    (super(TPUEstimator, self)._add_meta_graph_for_mode(\n        builder,\n        input_receiver_fn_map,\n        checkpoint_path,\n        save_variables,\n        mode=mode,\n        export_tags=export_tags,\n        check_variables=check_variables))\n\n    if self._export_to_tpu:\n      input_receiver_fn_map = {\n          _REWRITE_FOR_INFERENCE_MODE: input_receiver_fn_map[mode]\n      }\n      export_tags = [tag_constants.SERVING, tag_constants.TPU]\n      mode = _REWRITE_FOR_INFERENCE_MODE\n      # See b/110052256 for why `check_variables` is `False`.\n      (super(TPUEstimator, self)._add_meta_graph_for_mode(\n          builder,\n          input_receiver_fn_map,\n          checkpoint_path,\n          save_variables=False,\n          mode=mode,\n          export_tags=export_tags,\n          check_variables=False))\n\n  def _call_model_fn(self, features, labels, mode, config):\n    if mode == _REWRITE_FOR_INFERENCE_MODE:\n      return self._call_model_fn_for_inference(features, labels, mode, config)\n    else:\n      return super(TPUEstimator, self)._call_model_fn(features, labels, mode,\n                                                      config)\n\n  def _call_model_fn_for_inference(self, features, labels, mode, config):\n    """"""Wraps `_call_model_fn` for `export_savedmodel`.""""""\n    if mode != _REWRITE_FOR_INFERENCE_MODE:\n      raise ValueError(\'mode must be {}; \'\n                       \'got {}.\'.format(_REWRITE_FOR_INFERENCE_MODE, mode))\n\n    capture = _CapturedObject()\n\n    def computation():\n      """"""Compute tpu tensors used in export_outputs.\n\n      Passed to rewrite_for_inference so that model_fn will be called under\n      the rewriting contexts. Only tpu tensors are returned, but export_outputs\n      and scaffold are captured.\n\n      Returns:\n         A list of Tensors used in export_outputs and not marked for\n         outside_compilation.\n      """"""\n      # We should only call model fn once and it should be inside `computation`\n      # so that building the graph will happen under `rewrite_for_inference`.\n      mode = model_fn_lib.ModeKeys.PREDICT\n      estimator_spec = self._call_model_fn(features, labels, mode, config)\n\n      # We pick the TPU tensors out from `export_output` and later return them\n      # from `computation` for rewriting.\n      tensors_dict = collections.OrderedDict(\n          (k, _export_output_to_tensors(v))\n          for k, v in six.iteritems(estimator_spec.export_outputs))\n      tensors = nest.flatten(tensors_dict)\n      tpu_tensors = [t for t in tensors if t is not None]\n\n      # We cannot return anything other than `tpu_tensors` here so we capture\n      # the rest for later use.\n      capture.capture((estimator_spec, tensors_dict, tensors))\n      return tpu_tensors\n\n    tpu_tensors_on_cpu = tpu.rewrite_for_inference(computation)\n    estimator_spec, tensors_dict, tensors = capture.get()\n\n    # Reconstruct `tensors`, but with `tpu_tensors` replaced with\n    # `tpu_tensors_on_cpu`.\n    new_tensors = []\n    for t in tensors:\n      if t is None:\n        new_tensors.append(None)\n      else:\n        new_tensors.append(tpu_tensors_on_cpu.pop(0))\n\n    # Reconstruct `tensors_dict`.\n    new_tensors_dict = nest.pack_sequence_as(tensors_dict, new_tensors)\n    # Reconstruct `export_outputs`.\n    export_outputs = estimator_spec.export_outputs\n    new_export_outputs = collections.OrderedDict(\n        (k, _clone_export_output_with_tensors(export_outputs[k], v))\n        for k, v in six.iteritems(new_tensors_dict))\n\n    return estimator_spec._replace(export_outputs=new_export_outputs)\n\n  def _create_global_step(self, graph):\n    """"""Creates a global step suitable for TPUs.\n\n    Args:\n      graph: The graph in which to create the global step.\n\n    Returns:\n      A global step `Tensor`.\n\n    Raises:\n      ValueError: if the global step tensor is already defined.\n    """"""\n    return _create_global_step(graph)\n\n  def _convert_train_steps_to_hooks(self, steps, max_steps):\n    with self._ctx.with_mode(model_fn_lib.ModeKeys.TRAIN) as ctx:\n      if ctx.is_running_on_cpu():\n        return super(TPUEstimator, self)._convert_train_steps_to_hooks(\n            steps, max_steps)\n\n    # On TPU.\n    if steps is None and max_steps is None:\n      raise ValueError(\n          \'For TPU training, one of `steps` or `max_steps` must be set. \'\n          \'Cannot be both `None`.\')\n\n    # Estimator.train has explicit positiveness check.\n    if steps is not None:\n      util_lib.check_positive_integer(steps, \'Train steps\')\n    if max_steps is not None:\n      util_lib.check_positive_integer(max_steps, \'Train max_steps\')\n\n    return [\n        _TPUStopAtStepHook(self._iterations_per_training_loop, steps, max_steps)\n    ]\n\n  def _convert_eval_steps_to_hooks(self, steps):\n    with self._ctx.with_mode(model_fn_lib.ModeKeys.EVAL) as ctx:\n      if ctx.is_running_on_cpu():\n        return super(TPUEstimator, self)._convert_eval_steps_to_hooks(steps)\n\n    if steps is None:\n      raise ValueError(\'Evaluate `steps` must be set on TPU. Cannot be `None`.\')\n\n    util_lib.check_positive_integer(steps, \'Eval steps\')\n\n    return [\n        evaluation._StopAfterNEvalsHook(  # pylint: disable=protected-access\n            num_evals=steps),\n        _SetEvalIterationsHook(steps)\n    ]\n\n  def _call_input_fn(self, input_fn, mode):\n    """"""Calls the input function.\n\n    Args:\n      input_fn: The input function.\n      mode: ModeKeys\n\n    Returns:\n      In TPU mode, returns an input_fn to be called later in model_fn.\n      Otherwise, calls the input_fn and returns either fatures or\n        (features, labels).\n\n    Raises:\n      ValueError: if input_fn takes invalid arguments or does not have `params`.\n    """"""\n    input_fn_args = function_utils.fn_args(input_fn)\n    config = self.config  # a deep copy.\n    kwargs = {}\n    if \'params\' in input_fn_args:\n      kwargs[\'params\'] = self.params  # a deep copy.\n    else:\n      raise ValueError(\'input_fn ({}) does not include params argument, \'\n                       \'required by TPUEstimator to pass batch size as \'\n                       \'params[""batch_size""]\'.format(input_fn))\n    if \'config\' in input_fn_args:\n      kwargs[\'config\'] = config\n\n    if \'mode\' in input_fn_args:\n      kwargs[\'mode\'] = mode\n\n    # Records the fact input_fn has been invoked.\n    self._is_input_fn_invoked = True\n\n    with self._ctx.with_mode(mode) as ctx:\n      # Setting the batch size in params first. This helps user to have same\n      # input_fn for use_tpu=True/False.\n      batch_size_for_input_fn = ctx.batch_size_for_input_fn\n      if batch_size_for_input_fn is not None:\n        _add_item_to_params(kwargs[\'params\'], _BATCH_SIZE_KEY,\n                            batch_size_for_input_fn)\n\n      # For export_savedmodel, input_fn is never passed to Estimator. So,\n      # `is_export_mode` must be False.\n      if ctx.is_running_on_cpu(is_export_mode=False):\n        with ops.device(\'/device:CPU:0\'):\n          return input_fn(**kwargs)\n\n      # For TPU computation, input_fn should be invoked in a tf.while_loop for\n      # performance. While constructing the tf.while_loop, the structure of\n      # inputs returned by the `input_fn` needs to be recorded. The structure\n      # includes whether features or labels is dict or single Tensor, dict keys,\n      # tensor shapes, and dtypes. The recorded structure is used to create the\n      # infeed dequeue ops, which must be wrapped and passed as a Fn, called\n      # inside the TPU computation, as the TPU computation is wrapped inside a\n      # tf.while_loop also. So, we either pass input_fn to model_fn or pass\n      # dequeue_fn to model_fn. Here, `input_fn` is passed directly as\n      # `features` in `model_fn` signature.\n      def _input_fn(ctx):\n        _add_item_to_params(kwargs[\'params\'], _CTX_KEY, ctx)\n        return input_fn(**kwargs)\n\n      return _input_fn\n\n  def _validate_features_in_predict_input(self, result):\n    """"""Skip the validation.\n\n    For TPUEstimator, we do not need to check the result type. `_InputPipeline`\n    has stronger check. Parent class\'s check generates confusing warning msg.\n\n    Args:\n      result: `features` returned by input_fn.\n    """"""\n    pass\n\n  def train(self,\n            input_fn,\n            hooks=None,\n            steps=None,\n            max_steps=None,\n            saving_listeners=None):\n    rendezvous = error_handling.ErrorRendezvous(num_sources=3)\n    self._rendezvous[model_fn_lib.ModeKeys.TRAIN] = rendezvous\n    try:\n      return super(TPUEstimator, self).train(\n          input_fn=input_fn,\n          hooks=hooks,\n          steps=steps,\n          max_steps=max_steps,\n          saving_listeners=saving_listeners)\n    except Exception:  # pylint: disable=broad-except\n      rendezvous.record_error(\'training_loop\', sys.exc_info())\n    finally:\n      rendezvous.record_done(\'training_loop\')\n      rendezvous.raise_errors()\n\n  def evaluate(self,\n               input_fn,\n               steps=None,\n               hooks=None,\n               checkpoint_path=None,\n               name=None):\n    rendezvous = error_handling.ErrorRendezvous(num_sources=3)\n    self._rendezvous[model_fn_lib.ModeKeys.EVAL] = rendezvous\n    try:\n      return super(TPUEstimator, self).evaluate(\n          input_fn,\n          steps=steps,\n          hooks=hooks,\n          checkpoint_path=checkpoint_path,\n          name=name)\n    except Exception:  # pylint: disable=broad-except\n      rendezvous.record_error(\'evaluation_loop\', sys.exc_info())\n    finally:\n      rendezvous.record_done(\'evaluation_loop\')\n      rendezvous.raise_errors()\n\n  def predict(self,\n              input_fn,\n              predict_keys=None,\n              hooks=None,\n              checkpoint_path=None,\n              yield_single_examples=True):\n    rendezvous = error_handling.ErrorRendezvous(num_sources=3)\n    self._rendezvous[model_fn_lib.ModeKeys.PREDICT] = rendezvous\n    try:\n      for result in super(TPUEstimator, self).predict(\n          input_fn=input_fn,\n          predict_keys=predict_keys,\n          hooks=hooks,\n          checkpoint_path=checkpoint_path,\n          yield_single_examples=yield_single_examples):\n        yield result\n    except Exception:  # pylint: disable=broad-except\n      rendezvous.record_error(\'prediction_loop\', sys.exc_info())\n    finally:\n      rendezvous.record_done(\'prediction_loop\')\n      rendezvous.raise_errors()\n\n    rendezvous.record_done(\'prediction_loop\')\n    rendezvous.raise_errors()\n\n  def _augment_model_fn(self, model_fn, train_cache_fn, eval_cache_fn, batch_axis):\n    """"""Returns a new model_fn, which wraps the TPU support.""""""\n\n    def _model_fn(features, labels, mode, config, params):\n      """"""A Estimator `model_fn` for TPUEstimator.""""""\n      with self._ctx.with_mode(mode) as ctx:\n        model_fn_wrapper = _ModelFnWrapper(model_fn, train_cache_fn,\n            eval_cache_fn, config, params, ctx)\n\n        # `input_fn` is called in `train()`, `evaluate()`, and `predict()`,\n        # but not in `export_savedmodel()`.\n        if self._is_input_fn_invoked:\n          is_export_mode = False\n        else:\n          is_export_mode = True\n\n        # Clear the bit.\n        self._is_input_fn_invoked = None\n\n        # examples_hook is added to training_hooks for both CPU and TPU\n        # execution.\n        if self._log_every_n_steps is not None:\n          examples_hook = ExamplesPerSecondHook(\n              ctx.global_batch_size,\n              output_dir=self.model_dir,\n              every_n_steps=self._log_every_n_steps)\n\n        if ctx.is_running_on_cpu(is_export_mode=is_export_mode):\n          logging.info(\'Running %s on CPU\', mode)\n          estimator_spec = model_fn_wrapper.call_without_tpu(\n              features, labels, is_export_mode=is_export_mode)\n          if self._log_every_n_steps is not None:\n            estimator_spec = estimator_spec._replace(\n                training_hooks=estimator_spec.training_hooks + (examples_hook,))\n          return estimator_spec\n\n        assert labels is None, \'`labels` passed to `model_fn` must be `None`.\'\n        # TPUEstimator._call_input_fn passes `input_fn` as features to here.\n        assert callable(features), \'`input_fn` is not callable.\'\n        input_fn = features\n\n        input_holders = _InputPipeline(input_fn, batch_axis, ctx)\n        enqueue_ops, dequeue_fn, input_hooks, run_infeed_loop_on_coordinator = (\n            input_holders.generate_infeed_enqueue_ops_and_dequeue_fn())\n\n        graph = ops.get_default_graph()\n        for enqueue_op in enqueue_ops:\n          if isinstance(enqueue_op, list):\n            graph.get_collection_ref(_TPU_ENQUEUE_OPS).extend(enqueue_op)\n          else:\n            graph.add_to_collection(_TPU_ENQUEUE_OPS, enqueue_op)\n\n        if mode == model_fn_lib.ModeKeys.TRAIN:\n          compile_op, loss, host_call, scaffold, training_hooks = (\n              _train_on_tpu_system(ctx, model_fn_wrapper, dequeue_fn))\n          host_ops = host_call.create_tpu_hostcall()\n          if host_ops is None:\n            host_ops = []\n\n          shutdown_hooks = []\n          shutdown_mode = os.environ.get(\'TF_TPU_GRACEFUL_SHUTDOWN_MODE\',\n                                         \'shutdown_worker\')\n          if shutdown_mode:\n            if shutdown_mode == \'shutdown_worker\':\n              finalizer_hooks = [\n                  session_support.ShutdownLameWorkers(timeout_ms=60 * 1000),\n              ]\n            elif shutdown_mode == \'shutdown_computation\':\n              finalizer_hooks = [\n                  session_support.RestartComputation(timeout_ms=60 * 1000),\n              ]\n            else:\n              raise ValueError(\n                  \'Unknown TF_TPU_GRACEFUL_SHUTDOWN_MODE ""%s""\' % shutdown_mode)\n\n            shutdown_hooks.append(\n                session_support.GracefulShutdownHook(\n                    checkpoint_prefix=self.model_dir + \'/model.ckpt\',\n                    on_shutdown_hooks=finalizer_hooks))\n\n          with ops.control_dependencies([loss]):\n            global_step = array_ops.identity(training.get_global_step())\n          hooks = input_hooks + shutdown_hooks\n          hooks.extend([\n              TPUInfeedOutfeedSessionHook(\n                  ctx,\n                  enqueue_ops,\n                  host_ops,\n                  tpu_compile_op=compile_op,\n                  run_infeed_loop_on_coordinator=(\n                      run_infeed_loop_on_coordinator),\n                  rendezvous=self._rendezvous[mode],\n                  master=self._config.master,\n                  session_config=self._session_config,\n              ),\n              InstallSignalHandlerHook()\n          ])\n          if self._log_every_n_steps is not None:\n            logging_hook_frequency = (  # Divide and round up\n                (self._log_every_n_steps +\n                 self._config.tpu_config.iterations_per_loop - 1) //\n                self._config.tpu_config.iterations_per_loop)\n            hooks.append(\n                training.LoggingTensorHook({\n                    \'loss\': array_ops.identity(loss),\n                    \'step\': global_step,\n                },\n                                           every_n_iter=logging_hook_frequency))\n            examples_hook._set_steps_per_run(  # pylint: disable=protected-access\n                self._config.tpu_config.iterations_per_loop)\n            hooks.append(examples_hook)\n\n          if training_hooks:\n            hooks.extend(training_hooks)\n\n          chief_hooks = []\n          if (self._config.save_checkpoints_secs or\n              self._config.save_checkpoints_steps):\n            checkpoint_hook = training.CheckpointSaverHook(\n                self.model_dir,\n                save_secs=self._config.save_checkpoints_secs,\n                save_steps=self._config.save_checkpoints_steps,\n                scaffold=scaffold)\n            checkpoint_hook._set_steps_per_run(  # pylint: disable=protected-access\n                self._config.tpu_config.iterations_per_loop)\n            chief_hooks.append(checkpoint_hook)\n\n          summary.scalar(model_fn_lib.LOSS_METRIC_KEY, loss)\n          with ops.control_dependencies([loss]):\n            update_ops = _sync_variables_ops(ctx)\n\n          # Validate the TPU training graph to catch basic errors\n          _validate_tpu_training_graph()\n\n          train_op = control_flow_ops.group(*update_ops)\n          graph.add_to_collection(_TPU_TRAIN_OP, train_op)\n\n          return model_fn_lib.EstimatorSpec(\n              mode,\n              loss=loss,\n              training_chief_hooks=chief_hooks,\n              training_hooks=hooks,\n              train_op=train_op,\n              scaffold=scaffold)\n\n        if mode == model_fn_lib.ModeKeys.EVAL:\n          compile_op, total_loss, host_calls, scaffold, eval_hooks = (\n              _eval_on_tpu_system(ctx, model_fn_wrapper, dequeue_fn))\n          iterations_per_loop_var = _create_or_get_iterations_per_loop()\n          mean_loss = math_ops.div(\n              total_loss,\n              math_ops.cast(iterations_per_loop_var, dtype=total_loss.dtype))\n\n          with ops.control_dependencies([mean_loss]):\n            # After TPU evaluation computation is done (the mean_loss tensor),\n            # reads all variables back from TPU and updates the eval step\n            # counter properly\n            internal_ops_to_run = _sync_variables_ops(ctx)\n            internal_ops_to_run.append(\n                _increase_eval_step_op(iterations_per_loop_var))\n\n          host_call_ret = host_calls.create_tpu_hostcall()\n          eval_metric_ops = {}\n          eval_update_ops = []\n\n          eval_metrics = host_call_ret.get(\'eval_metrics\', {})\n          if eval_metrics:\n            # Creates a dummy metric update_op for all metrics. Estimator\n            # expects all metrics in `eval_metric_ops` have update_op and calls\n            # them one by one. The real metric update_ops are invoked in a\n            # separated thread. So, here give Estimator the dummy op for all\n            # metrics.\n            with ops.control_dependencies(internal_ops_to_run):\n              dummy_update_op = control_flow_ops.no_op()\n\n            for k, v in eval_metrics.items():\n              eval_metric_ops[k] = (v[0], dummy_update_op)\n              eval_update_ops.append(v[1])\n          else:\n            # If no eval metrics are passed, create an identity node for the\n            # loss and add `internal_ops_to_run` to its dependencies. So\n            # `internal_ops_to_run` can be executed.\n            with ops.control_dependencies(internal_ops_to_run):\n              mean_loss = array_ops.identity(mean_loss)\n\n          if \'host_call\' not in host_call_ret:\n            host_ops = []\n          else:\n            host_ops = host_call_ret[\'host_call\']\n          hooks = [\n              TPUInfeedOutfeedSessionHook(\n                  ctx,\n                  enqueue_ops,\n                  eval_update_ops + host_ops,\n                  tpu_compile_op=compile_op,\n                  run_infeed_loop_on_coordinator=(\n                      run_infeed_loop_on_coordinator),\n                  rendezvous=self._rendezvous[mode],\n                  master=self._config.evaluation_master,\n                  session_config=self._session_config,\n              )] + input_hooks\n\n          if eval_hooks:\n            hooks.extend(eval_hooks)\n\n          return model_fn_lib.EstimatorSpec(\n              mode,\n              loss=mean_loss,\n              evaluation_hooks=hooks,\n              eval_metric_ops=eval_metric_ops,\n              scaffold=scaffold)\n\n        # Predict\n        assert mode == model_fn_lib.ModeKeys.PREDICT\n\n        (compile_op, dummy_predict_op, host_calls,\n         scaffold, prediction_hooks) = _predict_on_tpu_system(\n             ctx, model_fn_wrapper, dequeue_fn)\n        with ops.control_dependencies([dummy_predict_op]):\n          internal_ops_to_run = _sync_variables_ops(ctx)\n          with ops.control_dependencies(internal_ops_to_run):\n            dummy_predict_op = control_flow_ops.no_op()\n\n        # In train and evaluation, the main TPU program is passed to monitored\n        # training session to run. Infeed enqueue and outfeed dequeue are\n        # executed in side threads. This is not the configuration for\n        # prediction mode.\n        #\n        # For prediction, the Estimator executes the EstimatorSpec.predictions\n        # directly and yield the element (via generator) to call site. So, the\n        # outfeed based prediction must be passed to MonitoredSession directly.\n        # Other parts of the TPU execution are organized as follows.\n        #\n        # 1. All outfeed based Tensors must be grouped with predictions Tensors\n        #    to form a single invocation. This avoid the issue we might trigger\n        #    multiple outfeeds incorrectly. To achieve this, `host_call` is\n        #    placed in control_dependencies of `stopping_signals`, and\n        #    `stopping_signals` is passed into _StoppingPredictHook, which sets\n        #    the `stopping_signals` as SessionRunArgs. MonitoredSession merges\n        #    all SessionRunArgs with the fetch in session.run together.\n        #\n        # 2. The TPU program (dummy_predict_op) and enqueue_ops (infeed Enqueue)\n        #    are grouped together. They will be launched once and only once in\n        #    side threads and they quit naturally according to the SAME stopping\n        #    condition.\n        enqueue_ops.append(dummy_predict_op)\n\n        host_call_ret = host_calls.create_tpu_hostcall()\n        if \'host_call\' not in host_call_ret:\n          host_ops = []\n        else:\n          host_ops = host_call_ret[\'host_call\']\n\n        predictions = host_call_ret[\'predictions\']\n        _verify_cross_hosts_transfer_size(\n            predictions,\n            message=(\n                \'The estimated size for TPUEstimatorSpec.predictions is too \'\n                \'large.\'))\n        signals = host_call_ret[\'signals\']\n\n        with ops.control_dependencies(host_ops):\n          host_ops = []  # Empty, we do do not need it anymore.\n          scalar_stopping_signal = _StopSignals.as_scalar_stopping_signal(\n              signals)\n          predictions = _PaddingSignals.slice_tensor_or_dict(\n              predictions, signals)\n\n        hooks = [\n            _StoppingPredictHook(scalar_stopping_signal),\n            TPUInfeedOutfeedSessionHookForPrediction(\n                ctx, enqueue_ops, host_ops, rendezvous=self._rendezvous[mode],\n                tpu_compile_op=compile_op,\n                master=self._config.master,\n                session_config=self._session_config),\n        ] + input_hooks\n\n        if prediction_hooks:\n          hooks.extend(prediction_hooks)\n\n        return model_fn_lib.EstimatorSpec(\n            mode,\n            prediction_hooks=hooks,\n            predictions=predictions,\n            scaffold=scaffold)\n\n    return _model_fn\n\n\ndef _export_output_to_tensors(export_output):\n  """"""Get a list of `Tensors` used in `export_output`.\n\n  Args:\n    export_output: an `ExportOutput` object such as `ClassificationOutput`,\n      `RegressionOutput`, or `PredictOutput`.\n\n  Returns:\n    a list of tensors used in export_output.\n\n  Raises:\n    ValueError: if `export_output` is not one of `ClassificationOutput`,\n        `RegressionOutput`, or `PredictOutput`.\n  """"""\n  if isinstance(export_output, export_output_lib.ClassificationOutput):\n    return [export_output.scores, export_output.classes]\n  elif isinstance(export_output, export_output_lib.RegressionOutput):\n    return [export_output.value]\n  elif isinstance(export_output, export_output_lib.PredictOutput):\n    return list(export_output.outputs.values())\n  else:\n    raise ValueError(\n        \'`export_output` must be have type `ClassificationOutput`, \'\n        \'`RegressionOutput`, or `PredictOutput`; got {}.\'.format(export_output))\n\n\ndef _clone_export_output_with_tensors(export_output, tensors):\n  """"""Clones `export_output` but with new `tensors`.\n\n  Args:\n    export_output: an `ExportOutput` object such as `ClassificationOutput`,\n      `RegressionOutput`, or `PredictOutput`.\n    tensors: a list of `Tensors` used to construct a new `export_output`.\n\n  Returns:\n    A dict similar to `export_output` but with `tensors`.\n\n  Raises:\n    ValueError: if `export_output` is not one of `ClassificationOutput`,\n        `RegressionOutput`, or `PredictOutput`.\n  """"""\n  if isinstance(export_output, export_output_lib.ClassificationOutput):\n    if len(tensors) != 2:\n      raise ValueError(\'tensors must be of length 2; \'\n                       \'got {}.\'.format(len(tensors)))\n    return export_output_lib.ClassificationOutput(*tensors)\n  elif isinstance(export_output, export_output_lib.RegressionOutput):\n    if len(tensors) != 1:\n      raise ValueError(\'tensors must be of length 1; \'\n                       \'got {}\'.format(len(tensors)))\n    return export_output_lib.RegressionOutput(*tensors)\n  elif isinstance(export_output, export_output_lib.PredictOutput):\n    return export_output_lib.PredictOutput(\n        dict(zip(export_output.outputs.keys(), tensors)))\n  else:\n    raise ValueError(\n        \'`export_output` must be have type `ClassificationOutput`, \'\n        \'`RegressionOutput`, or `PredictOutput`; got {}.\'.format(export_output))\n\n\ndef _eval_on_tpu_system(ctx, model_fn_wrapper, dequeue_fn):\n  """"""Executes `model_fn_wrapper` multiple times on all TPU shards.""""""\n  iterations_per_loop_var = _create_or_get_iterations_per_loop()\n\n  (single_tpu_eval_step, host_calls, captured_scaffold_fn, captured_eval_hooks\n  ) = model_fn_wrapper.convert_to_single_tpu_eval_step(dequeue_fn)\n\n  def multi_tpu_eval_steps_on_single_shard():\n    loop_vars = [_ZERO_LOSS]\n    if model_fn_wrapper._eval_cache_fn is not None:\n      batch_size = ctx.global_batch_size\n      num_shards = ctx._config._tpu_config.num_shards\n      loop_vars += model_fn_wrapper._eval_cache_fn(batch_size // num_shards)\n\n    return training_loop.repeat(\n        iterations_per_loop_var,\n        single_tpu_eval_step,\n        loop_vars)\n\n  compile_op, ret = tpu.split_compile_and_shard(\n      multi_tpu_eval_steps_on_single_shard,\n      inputs=[],\n      num_shards=ctx.num_replicas,\n      outputs_from_all_shards=False,\n      device_assignment=ctx.device_assignment)\n\n  loss = ret[0]\n  scaffold = _get_scaffold(captured_scaffold_fn)\n  return compile_op, loss, host_calls, scaffold, captured_eval_hooks.get()\n\n\ndef _train_on_tpu_system(ctx, model_fn_wrapper, dequeue_fn):\n  """"""Executes `model_fn_wrapper` multiple times on all TPU shards.""""""\n  iterations_per_loop_var = _create_or_get_iterations_per_loop()\n\n  (single_tpu_train_step, host_call, captured_scaffold_fn,\n   captured_training_hooks) = (\n       model_fn_wrapper.convert_to_single_tpu_train_step(dequeue_fn))\n\n  def multi_tpu_train_steps_on_single_shard():\n    loop_vars = [_INITIAL_LOSS]\n    if model_fn_wrapper._train_cache_fn is not None:\n      batch_size = ctx.global_batch_size\n      num_shards = ctx._config._tpu_config.num_shards\n      loop_vars += model_fn_wrapper._train_cache_fn(batch_size // num_shards)\n\n    return training_loop.repeat(\n        iterations_per_loop_var,\n        single_tpu_train_step,\n        loop_vars)\n\n  compile_op, ret = tpu.split_compile_and_shard(\n      multi_tpu_train_steps_on_single_shard,\n      inputs=[],\n      num_shards=ctx.num_replicas,\n      outputs_from_all_shards=False,\n      device_assignment=ctx.device_assignment)\n\n  loss = ret[0]\n  scaffold = _get_scaffold(captured_scaffold_fn)\n  return compile_op, loss, host_call, scaffold, captured_training_hooks.get()\n\n\ndef _predict_on_tpu_system(ctx, model_fn_wrapper, dequeue_fn):\n  """"""Executes `model_fn_wrapper` multiple times on all TPU shards.""""""\n  (single_tpu_predict_step, host_calls, captured_scaffold_fn,\n   captured_predict_hooks\n  ) = model_fn_wrapper.convert_to_single_tpu_predict_step(dequeue_fn)\n\n  def multi_tpu_predict_steps_on_single_shard():\n\n    def cond(scalar_stopping_signal):\n      return math_ops.logical_not(\n          _StopSignals.should_stop(scalar_stopping_signal))\n\n    inputs = [_StopSignals.NON_STOPPING_SIGNAL]\n    outputs = training_loop.while_loop(\n        cond, single_tpu_predict_step, inputs=inputs, name=b\'loop\')\n    return outputs\n\n  (compile_op, dummy_predict_op,) = tpu.split_compile_and_shard(\n      multi_tpu_predict_steps_on_single_shard,\n      inputs=[],\n      num_shards=ctx.num_replicas,\n      outputs_from_all_shards=False,\n      device_assignment=ctx.device_assignment)\n\n  dummy_predict_op = dummy_predict_op[0]\n  scaffold = _get_scaffold(captured_scaffold_fn)\n  return (compile_op, dummy_predict_op, host_calls, scaffold,\n          captured_predict_hooks.get())\n\n\ndef _wrap_computation_in_while_loop(device, op_fn):\n  """"""Wraps the ops generated by `op_fn` in tf.while_loop.""""""\n\n  def computation(i):\n    with ops.control_dependencies(op_fn()):\n      return i + 1\n\n  iterations_per_loop_var = _create_or_get_iterations_per_loop()\n  # By setting parallel_iterations=1, the parallel execution in while_loop is\n  # basically turned off.\n  with ops.device(device):\n    iterations = array_ops.identity(iterations_per_loop_var)\n    return control_flow_ops.while_loop(\n        lambda i: i < iterations,\n        computation, [constant_op.constant(0)],\n        parallel_iterations=1)\n\n\ndef _wrap_computation_in_while_loop_with_stopping_signals(device, op_fn):\n  """"""Wraps the ops generated by `op_fn` in tf.while_loop.""""""\n\n  def cond(scalar_stopping_signal):\n    return math_ops.logical_not(\n        _StopSignals.should_stop(scalar_stopping_signal))\n\n  def computation(unused_scalar_stopping_signal):\n    return_value = op_fn()\n    execute_ops = return_value[\'ops\']\n    signals = return_value[\'signals\']\n    with ops.control_dependencies(execute_ops):\n      return _StopSignals.as_scalar_stopping_signal(signals)\n\n  # By setting parallel_iterations=1, the parallel execution in while_loop is\n  # basically turned off.\n  with ops.device(device):\n    return control_flow_ops.while_loop(\n        cond,\n        computation, [_StopSignals.NON_STOPPING_SIGNAL],\n        parallel_iterations=1)\n\n\ndef _validate_tpu_training_graph():\n  """"""Validate graph before running distributed training.\n\n  Raises:\n    ValueError: If the graph seems invalid for running on device\n  """"""\n  operations = ops.get_default_graph().get_operations()\n\n  # Check if there is atleast one CrossReplicaSum operation in the graph\n  # This should be introduced by using the CrossShardOptimizer wrapper\n  cross_replica_sum_ops = [\n      o for o in operations if o.type == _CROSS_REPLICA_SUM_OP\n  ]\n  if not cross_replica_sum_ops:\n    raise ValueError(\n        \'CrossShardOptimizer must be used for model training on TPUs.\')\n\n\nclass _CapturedObject(object):\n  """"""A placeholder to capture an object.\n\n  This is useful when we need to capture a Python object in the Tensorflow\n  control flow body function and use it outside the control flow.\n  """"""\n\n  def __init__(self):\n    self._object = None\n    self._captured = False\n\n  def capture(self, o):\n    if self._captured:\n      raise RuntimeError(\n          \'InternalError: Object can capture only once. Please file bug.\')\n\n    self._captured = True\n    self._object = o\n\n  def get(self):\n    if not self._captured:\n      raise RuntimeError(\n          \'InternalError: Object is not captured properly before `get`. \'\n          \'Please file bug.\')\n    return self._object\n\n\ndef _get_scaffold(captured_scaffold_fn):\n  """"""Retrieves the Scaffold from `captured_scaffold_fn`.""""""\n  with _CapturingContext(message=\'Inside scaffold_fn\'):\n    scaffold_fn = captured_scaffold_fn.get()\n    if scaffold_fn:\n      scaffold = scaffold_fn()\n      if scaffold is None:\n        raise ValueError(\n            \'TPUEstimatorSpec.scaffold_fn returns None, which is not allowed\')\n    else:\n      scaffold = None\n\n  if scaffold:\n    wrapped_finalize = scaffold.finalize\n\n    def _finalize():\n      with _CapturingContext(\'Inside Scaffold.finalize\'):\n        wrapped_finalize()\n\n    scaffold.finalize = _finalize\n  return scaffold\n\n\nclass _CapturingContext(control_flow_ops.ControlFlowContext):\n  """"""Tracks references to Tensors defined in TPU replication.""""""\n\n  def __init__(self, message):\n    control_flow_ops.ControlFlowContext.__init__(self)\n    self._message = message\n\n  def to_control_flow_context_def(self, context_def, export_scope=None):\n    # pylint: disable=useless-super-delegation\n    # NOTE(slebedev): the method is required by `ControlFlowContext`.\n    super(_CapturingContext, self).to_control_flow_context_def(\n        context_def, export_scope)\n\n  def AddOp(self, op):  # pylint: disable=invalid-name\n    for c in op.inputs:\n      if tpu._TPU_REPLICATE_ATTR in c.op.node_def.attr:  # pylint: disable=protected-access\n        raise ValueError(\'{}: Op {} depends on TPU computation {}, \'\n                         \'which is not allowed.\'.format(self._message, op, c))\n\n  def __enter__(self):\n    # pylint: disable=protected-access\n    self._g = ops.get_default_graph()\n    self._old = self._g._get_control_flow_context()\n    self._g._set_control_flow_context(self)\n    # pylint: enable=protected-access\n\n  def __exit__(self, _, __, ___):  # pylint: disable=invalid-name\n    self._g._set_control_flow_context(self._old)  # pylint: disable=protected-access\n\n\nclass _Inputs(object):\n  """"""A data structure representing the input_fn returned values.\n\n  This also supports the returned value from input_fn as `Dataset`.\n  """"""\n\n  def __init__(self, features=None, labels=None, dataset=None, signals=None):\n    if dataset is not None and (features is not None or labels is not None or\n                                signals is not None):\n      raise RuntimeError(\'Internal Error: Either (features and labels) or \'\n                         \'dataset should be provided, not both. Please file \'\n                         \'bug\')\n\n    self._features = features\n    self._labels = labels\n    self._signals = signals\n\n    self._dataset = dataset\n    self._iterator = None\n\n  @staticmethod\n  def from_input_fn(return_values):\n    """"""Returns an `_Inputs` instance according to `input_fn` return value.""""""\n    if isinstance(return_values, dataset_ops.DatasetV2):\n      dataset = return_values\n      return _Inputs(dataset=dataset)\n\n    features, labels = _Inputs._parse_inputs(return_values)\n    return _Inputs(features, labels)\n\n  @staticmethod\n  def _parse_inputs(return_values):\n    if isinstance(return_values, tuple):\n      features, labels = return_values\n    else:\n      features, labels = return_values, None\n    return features, labels\n\n  @property\n  def is_dataset(self):\n    """"""Returns True if the return value from input_fn is Dataset.""""""\n    return self._dataset is not None\n\n  def dataset_initializer(self):\n    """"""Returns the dataset\'s initializer.\n\n    The initializer must be run before calling `features_and_labels`.\n    """"""\n    self._iterator = dataset_ops.make_initializable_iterator(self._dataset)\n    return self._iterator.initializer\n\n  def features_and_labels(self):\n    """"""Gets `features` and `labels`.""""""\n    if self.is_dataset:\n      if self._iterator is None:\n        raise RuntimeError(\'Internal error: Must run dataset_initializer \'\n                           \'before calling features_and_labels(). Please file \'\n                           \'a bug!\')\n      return _Inputs._parse_inputs(self._iterator.get_next())\n\n    return (self._features, self._labels)\n\n  def signals(self):\n    return self._signals\n\n  @property\n  def dataset(self):\n    return self._dataset\n\n\nclass _InputsWithStoppingSignals(_Inputs):\n  """"""Inputs with `_StopSignals` inserted into the dataset.""""""\n\n  def __init__(self,\n               dataset,\n               batch_size,\n               add_padding=False,\n               num_invocations_per_step=1):\n\n    assert dataset is not None\n    user_provided_dataset = dataset.map(\n        _InputsWithStoppingSignals.insert_stopping_signal(\n            stop=False, batch_size=batch_size, add_padding=add_padding))\n    if num_invocations_per_step == 1:\n      final_batch_dataset = dataset.take(1).map(\n          _InputsWithStoppingSignals.insert_stopping_signal(\n              stop=True, batch_size=batch_size, add_padding=add_padding))\n    else:\n      # We append (2 * num_invocations_per_step - 1) batches for exhausting the\n      # user_provided_dataset and stop properly.\n      # For example, if num_invocations_per_step is 2, we append 3 additional\n      # padding batches: b1, b2, b3.\n      # If user_provided_dataset contains two batches: a1, a2\n      # Step 1: [a1, a2]\n      # Step 2: [b1, b2] -> STOP\n      # If user_provided_dataset contains three batches: a1, a2, a3.\n      # The training loops:\n      # Step 1: [a1, a2]\n      # Step 2: [a3, b1]\n      # Step 3: [b2, b3] -> STOP.\n      final_batch_dataset = dataset.take(1).map(\n          _InputsWithStoppingSignals.insert_stopping_signal(\n              stop=True, batch_size=batch_size, add_padding=add_padding))\n      final_batch_dataset = final_batch_dataset.repeat(\n          2 * num_invocations_per_step - 1)\n\n      def _set_mask(data_dict):\n        signals = data_dict[\'signals\']\n        signals[\'padding_mask\'] = array_ops.ones_like(signals[\'padding_mask\'])\n        data_dict[\'signals\'] = signals\n        return data_dict\n\n      # Mask out the extra batch.\n      final_batch_dataset = final_batch_dataset.map(_set_mask)\n\n    dataset = user_provided_dataset.concatenate(final_batch_dataset).prefetch(2)\n\n    super(_InputsWithStoppingSignals, self).__init__(dataset=dataset)\n    self._current_inputs = None\n\n  def features_and_labels(self):\n    if self._current_inputs is not None:\n      raise RuntimeError(\n          \'Internal Error: The previous inputs have not been properly \'\n          \'consumed. First call features_and_labels, then call signals.\')\n\n    inputs_with_signals = self._iterator.get_next()\n    features = inputs_with_signals[\'features\']\n    labels = inputs_with_signals.get(\'labels\')\n\n    self._current_inputs = inputs_with_signals\n    return features, labels\n\n  def signals(self):\n    """"""Returns the `Signals` from `_Inputs`.""""""\n    if self._current_inputs is None:\n      raise RuntimeError(\n          \'Internal Error: The current inputs have not been properly \'\n          \'generated. First call features_and_labels, then call signals.\')\n    signals = self._current_inputs[\'signals\']\n    self._current_inputs = None\n    return signals\n\n  @staticmethod\n  def insert_stopping_signal(stop, batch_size, add_padding=False):\n    """"""Inserts stopping_signal into dataset via _map_fn.\n\n    Here we change the data structure in the dataset, such that the return value\n    is a dictionary now and `features`, `labels`, and `signals` are three\n    distinguished keys in that dict. This provides a better structure, which\n    eases the process to decompose the inputs (see `features_and_labels`).\n\n    Args:\n      stop: bool, state of current stopping signals.\n      batch_size: int, batch size.\n      add_padding: bool, whether to pad the tensor to full batch size.\n\n    Returns:\n      A map_fn passed to dataset.map API.\n    """"""\n\n    def _map_fn(*args):\n      """"""The map fn to insert signals.""""""\n      if len(args) == 1:\n        # Unpack the single Tensor/dict argument as features. This is required\n        # for the input_fn returns no labels.\n        args = args[0]\n      features, labels = _Inputs._parse_inputs(args)\n      new_input_dict = {}\n\n      if add_padding:\n        padding_mask, features, labels = (\n            _PaddingSignals.pad_features_and_labels(features, labels,\n                                                    batch_size))\n\n        new_input_dict[\'features\'] = features\n        if labels is not None:\n          new_input_dict[\'labels\'] = labels\n\n      else:\n        new_input_dict[\'features\'] = features\n        if labels is not None:\n          new_input_dict[\'labels\'] = labels\n        padding_mask = None\n\n      new_input_dict[\'signals\'] = _StopSignals(\n          stop=stop, batch_size=batch_size,\n          padding_mask=padding_mask).as_dict()\n\n      return new_input_dict\n\n    return _map_fn\n\n\nclass _StopSignals(object):\n  """"""Signals class holding all logic to handle TPU stopping condition.""""""\n\n  NON_STOPPING_SIGNAL = False\n  STOPPING_SIGNAL = True\n\n  def __init__(self, stop, batch_size, padding_mask=None):\n    self._stop = stop\n    self._batch_size = batch_size\n    self._padding_mask = padding_mask\n\n  def as_dict(self):\n    """"""Returns the signals as Python dict.""""""\n    shape = [self._batch_size, 1]\n    dtype = dtypes.bool\n\n    if self._stop:\n      stopping = array_ops.ones(shape=shape, dtype=dtype)\n    else:\n      stopping = array_ops.zeros(shape=shape, dtype=dtype)\n\n    signals = {\'stopping\': stopping}\n    if self._padding_mask is not None:\n      signals[\'padding_mask\'] = self._padding_mask\n    return signals\n\n  @staticmethod\n  def as_scalar_stopping_signal(signals):\n    return array_ops.identity(signals[\'stopping\'][0][0])\n\n  @staticmethod\n  def should_stop(scalar_stopping_signal):\n    """"""Detects whether scalar_stopping_signal indicates stopping.""""""\n    if isinstance(scalar_stopping_signal, ops.Tensor):\n      # STOPPING_SIGNAL is a constant True. Here, the logical_and is just the TF\n      # way to express the bool check whether scalar_stopping_signal is True.\n      return math_ops.logical_and(scalar_stopping_signal,\n                                  _StopSignals.STOPPING_SIGNAL)\n    else:\n      # For non Tensor case, it is used in SessionRunHook. So, we cannot modify\n      # the graph anymore. Here, we use pure Python.\n      return bool(scalar_stopping_signal)\n\n\nclass _PaddingSignals(object):\n  """"""Signals class holding all logic to handle padding.""""""\n\n  @staticmethod\n  def pad_features_and_labels(features, labels, batch_size):\n    """"""Pads out the batch dimension of features and labels.""""""\n    real_batch_size = array_ops.shape(\n        _PaddingSignals._find_any_tensor(features))[0]\n\n    batch_size_tensor = constant_op.constant(batch_size, dtypes.int32)\n\n    check_greater = check_ops.assert_greater_equal(\n        batch_size_tensor,\n        real_batch_size,\n        data=(batch_size_tensor, real_batch_size),\n        message=\'The real batch size should not be greater than batch_size.\')\n\n    with ops.control_dependencies([check_greater]):\n      missing_count = batch_size_tensor - real_batch_size\n\n    def pad_single_tensor(tensor):\n      """"""Pads out the batch dimension of a tensor to the complete batch_size.""""""\n      rank = len(tensor.shape)\n      assert rank > 0\n      padding = array_ops.stack([[0, missing_count]] + [[0, 0]] * (rank - 1))\n      padded_shape = (batch_size,) + tuple(tensor.shape[1:])\n      padded_tensor = array_ops.pad(tensor, padding)\n      padded_tensor.set_shape(padded_shape)\n      return padded_tensor\n\n    def nest_pad(tensor_or_dict):\n      return nest.map_structure(pad_single_tensor, tensor_or_dict)\n\n    features = nest_pad(features)\n    if labels is not None:\n      labels = nest_pad(labels)\n\n    padding_mask = _PaddingSignals._padding_mask(real_batch_size, missing_count,\n                                                 batch_size)\n\n    return padding_mask, features, labels\n\n  @staticmethod\n  def slice_tensor_or_dict(tensor_or_dict, signals):\n    """"""Slice the real Tensors according to padding mask in signals.""""""\n\n    padding_mask = signals[\'padding_mask\']\n    batch_size = array_ops.shape(padding_mask)[0]\n\n    def verify_batch_size(tensor):\n      check_batch_size = math_ops.equal(batch_size, tensor.shape[0])\n      with ops.control_dependencies([check_batch_size]):\n        return array_ops.identity(tensor)\n\n    def slice_single_tensor(tensor):\n      rank = len(tensor.shape)\n      assert rank > 0\n      real_batch_size = batch_size - math_ops.reduce_sum(padding_mask)\n      return verify_batch_size(tensor)[0:real_batch_size]\n\n    # As we split the Tensors to all TPU cores and concat them back, it is\n    # important to ensure the real data is placed before padded ones, i.e.,\n    # order is preserved. By that, the sliced padding mask should have all 0\'s.\n    # If this assertion failed, # the slice logic here would not hold.\n    sliced_padding_mask = slice_single_tensor(padding_mask)\n    assert_padding_mask = math_ops.equal(\n        math_ops.reduce_sum(sliced_padding_mask), 0)\n\n    with ops.control_dependencies([assert_padding_mask]):\n      should_stop = _StopSignals.should_stop(\n          _StopSignals.as_scalar_stopping_signal(signals))\n\n    is_full_batch = math_ops.equal(math_ops.reduce_sum(padding_mask), 0)\n\n    def slice_fn(tensor):\n      # If the current batch is full batch or part of stopping signals, we do\n      # not need to slice to save performance.\n      return control_flow_ops.cond(\n          math_ops.logical_or(should_stop, is_full_batch),\n          (lambda: verify_batch_size(tensor)),\n          (lambda: slice_single_tensor(tensor)))\n\n    return nest.map_structure(slice_fn, tensor_or_dict)\n\n  @staticmethod\n  def _find_any_tensor(batch_features):\n    tensors = [\n        x for x in nest.flatten(batch_features) if isinstance(x, ops.Tensor)\n    ]\n    if not tensors:\n      raise ValueError(\'Cannot find any Tensor in features dict.\')\n    return tensors[0]\n\n  @staticmethod\n  def _padding_mask(real_batch_size, missing_count, batch_size):\n    padding_mask = array_ops.concat([\n        array_ops.zeros((real_batch_size,), dtype=dtypes.int32),\n        array_ops.ones((missing_count,), dtype=dtypes.int32)\n    ],\n                                    axis=0)\n    padding_mask.set_shape((batch_size,))\n    return padding_mask\n\n\ndef _verify_cross_hosts_transfer_size(tensor_dict, message):\n  total_size = 0\n  tensor_structure = {}\n  for key, tensor in tensor_dict.items():\n    shape = tensor.shape\n    size = np.product(shape) * tensor.dtype.size\n    tensor_structure[key] = shape\n    total_size += size\n  if total_size >= _ONE_GIGABYTE:\n    raise ValueError(\n        \'{} The transfer size is larger than the protobuf limit. Please \'\n        \'consider to use Tensors with smaller shapes or reduce batch \'\n        \'size. Given:\\n\'\n        \'{}\'.format(\n            message, \'\\n\'.join([\n                \' -- Key: {}, Shape: {}\'.format(k, v)\n                for k, v in tensor_structure.items()\n            ])))\n\n\ndef _add_item_to_params(params, key, value):\n  """"""Adds a new item into `params`.""""""\n  if isinstance(params, hparam.HParams):\n    # For HParams, we need to use special API.\n    if key in params:\n      params.set_hparam(key, value)\n    else:\n      params.add_hparam(key, value)\n  else:\n    # Now params is Python dict.\n    params[key] = value\n\n\ndef export_estimator_savedmodel(estimator,\n                                export_dir_base,\n                                serving_input_receiver_fn,\n                                assets_extra=None,\n                                as_text=False,\n                                checkpoint_path=None,\n                                strip_default_attrs=False):\n  """"""Export `Estimator` trained model for TPU inference.\n\n  Args:\n    estimator: `Estimator` with which model has been trained.\n    export_dir_base: A string containing a directory in which to create\n      timestamped subdirectories containing exported SavedModels.\n    serving_input_receiver_fn: A function that takes no argument and returns a\n      `ServingInputReceiver` or `TensorServingInputReceiver`.\n    assets_extra: A dict specifying how to populate the assets.extra directory\n      within the exported SavedModel, or `None` if no extra assets are needed.\n    as_text: whether to write the SavedModel proto in text format.\n    checkpoint_path: The checkpoint path to export.  If `None` (the default),\n      the most recent checkpoint found within the model directory is chosen.\n    strip_default_attrs: Boolean. If `True`, default-valued attributes will be\n      removed from the NodeDefs.\n\n  Returns:\n    The string path to the exported directory.\n  """"""\n  # `TPUEstimator` requires `tpu_config.RunConfig`, so we cannot use\n  # `estimator.config`.\n  config = tpu_config.RunConfig(model_dir=estimator.model_dir)\n  est = TPUEstimator(\n      estimator._model_fn,  # pylint: disable=protected-access\n      config=config,\n      params=estimator.params,\n      use_tpu=True,\n      train_batch_size=2048,  # Does not matter.\n      eval_batch_size=2048,  # Does not matter.\n  )\n  return est.export_savedmodel(export_dir_base, serving_input_receiver_fn,\n                               assets_extra, as_text, checkpoint_path,\n                               strip_default_attrs)\n'"
src/xlnet.py,8,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport json\nimport os\nimport tensorflow as tf\nimport modeling\n\n\ndef _get_initializer(FLAGS):\n  """"""Get variable intializer.""""""\n  if FLAGS.init == ""uniform"":\n    initializer = tf.initializers.random_uniform(\n        minval=-FLAGS.init_range,\n        maxval=FLAGS.init_range,\n        seed=None)\n  elif FLAGS.init == ""normal"":\n    initializer = tf.initializers.random_normal(\n        stddev=FLAGS.init_std,\n        seed=None)\n  else:\n    raise ValueError(""Initializer {} not supported"".format(FLAGS.init))\n  return initializer\n\n\nclass XLNetConfig(object):\n  """"""XLNetConfig contains hyperparameters that are specific to a model checkpoint;\n  i.e., these hyperparameters should be the same between\n  pretraining and finetuning.\n\n  The following hyperparameters are defined:\n    n_layer: int, the number of layers.\n    d_model: int, the hidden size.\n    n_head: int, the number of attention heads.\n    d_head: int, the dimension size of each attention head.\n    d_inner: int, the hidden size in feed-forward layers.\n    ff_activation: str, ""relu"" or ""gelu"".\n    untie_r: bool, whether to untie the biases in attention.\n    n_token: int, the vocab size.\n  """"""\n\n  def __init__(self, FLAGS=None, json_path=None):\n    """"""Constructing an XLNetConfig.\n    One of FLAGS or json_path should be provided.""""""\n\n    assert FLAGS is not None or json_path is not None\n\n    self.keys = [""n_layer"", ""d_model"", ""n_head"", ""d_head"", ""d_inner"",\n                 ""ff_activation"", ""untie_r"", ""n_token""]\n\n    if FLAGS is not None:\n      self.init_from_flags(FLAGS)\n\n    if json_path is not None:\n      self.init_from_json(json_path)\n\n  def init_from_flags(self, FLAGS):\n    for key in self.keys:\n      setattr(self, key, getattr(FLAGS, key))\n\n  def init_from_json(self, json_path):\n    with tf.gfile.Open(json_path) as f:\n      json_data = json.load(f)\n      for key in self.keys:\n        setattr(self, key, json_data[key])\n\n  def to_json(self, json_path):\n    """"""Save XLNetConfig to a json file.""""""\n    json_data = {}\n    for key in self.keys:\n      json_data[key] = getattr(self, key)\n\n    json_dir = os.path.dirname(json_path)\n    if not tf.gfile.Exists(json_dir):\n      tf.gfile.MakeDirs(json_dir)\n    with tf.gfile.Open(json_path, ""w"") as f:\n      json.dump(json_data, f, indent=4, sort_keys=True)\n\n\ndef create_run_config(is_training, is_finetune, FLAGS):\n  kwargs = dict(\n      is_training=is_training,\n      use_tpu=FLAGS.use_tpu,\n      use_bfloat16=FLAGS.use_bfloat16,\n      dropout=FLAGS.dropout,\n      dropatt=FLAGS.dropatt,\n      init=FLAGS.init,\n      init_range=FLAGS.init_range,\n      init_std=FLAGS.init_std,\n      clamp_len=FLAGS.clamp_len)\n\n  if not is_finetune:\n    kwargs.update(dict(\n        mem_len=FLAGS.mem_len,\n        reuse_len=FLAGS.reuse_len,\n        bi_data=FLAGS.bi_data,\n        clamp_len=FLAGS.clamp_len,\n        same_length=FLAGS.same_length))\n\n  return RunConfig(**kwargs)\n\n\nclass RunConfig(object):\n  """"""RunConfig contains hyperparameters that could be different\n  between pretraining and finetuning.\n  These hyperparameters can also be changed from run to run.\n  We store them separately from XLNetConfig for flexibility.\n  """"""\n\n  def __init__(self, is_training, use_tpu, use_bfloat16, dropout, dropatt,\n               init=""normal"", init_range=0.1, init_std=0.02, mem_len=None,\n               reuse_len=None, bi_data=False, clamp_len=-1, same_length=False):\n    """"""\n    Args:\n      is_training: bool, whether in training mode.\n      use_tpu: bool, whether TPUs are used.\n      use_bfloat16: bool, use bfloat16 instead of float32.\n      dropout: float, dropout rate.\n      dropatt: float, dropout rate on attention probabilities.\n      init: str, the initialization scheme, either ""normal"" or ""uniform"".\n      init_range: float, initialize the parameters with a uniform distribution\n        in [-init_range, init_range]. Only effective when init=""uniform"".\n      init_std: float, initialize the parameters with a normal distribution\n        with mean 0 and stddev init_std. Only effective when init=""normal"".\n      mem_len: int, the number of tokens to cache.\n      reuse_len: int, the number of tokens in the currect batch to be cached\n        and reused in the future.\n      bi_data: bool, whether to use bidirectional input pipeline.\n        Usually set to True during pretraining and False during finetuning.\n      clamp_len: int, clamp all relative distances larger than clamp_len.\n        -1 means no clamping.\n      same_length: bool, whether to use the same attention length for each token.\n    """"""\n\n    self.init = init\n    self.init_range = init_range\n    self.init_std = init_std\n    self.is_training = is_training\n    self.dropout = dropout\n    self.dropatt = dropatt\n    self.use_tpu = use_tpu\n    self.use_bfloat16 = use_bfloat16\n    self.mem_len = mem_len\n    self.reuse_len = reuse_len\n    self.bi_data = bi_data\n    self.clamp_len = clamp_len\n    self.same_length = same_length\n\n\nclass XLNetModel(object):\n  """"""A wrapper of the XLNet model used during both pretraining and finetuning.""""""\n\n  def __init__(self, xlnet_config, run_config, input_ids, seg_ids, input_mask,\n               mems=None, perm_mask=None, target_mapping=None, inp_q=None,\n               **kwargs):\n    """"""\n    Args:\n      xlnet_config: XLNetConfig,\n      run_config: RunConfig,\n      input_ids: int32 Tensor in shape [len, bsz], the input token IDs.\n      seg_ids: int32 Tensor in shape [len, bsz], the input segment IDs.\n      input_mask: float32 Tensor in shape [len, bsz], the input mask.\n        0 for real tokens and 1 for padding.\n      mems: a list of float32 Tensors in shape [mem_len, bsz, d_model], memory\n        from previous batches. The length of the list equals n_layer.\n        If None, no memory is used.\n      perm_mask: float32 Tensor in shape [len, len, bsz].\n        If perm_mask[i, j, k] = 0, i attend to j in batch k;\n        if perm_mask[i, j, k] = 1, i does not attend to j in batch k.\n        If None, each position attends to all the others.\n      target_mapping: float32 Tensor in shape [num_predict, len, bsz].\n        If target_mapping[i, j, k] = 1, the i-th predict in batch k is\n        on the j-th token.\n        Only used during pretraining for partial prediction.\n        Set to None during finetuning.\n      inp_q: float32 Tensor in shape [len, bsz].\n        1 for tokens with losses and 0 for tokens without losses.\n        Only used during pretraining for two-stream attention.\n        Set to None during finetuning.\n    """"""\n\n    initializer = _get_initializer(run_config)\n\n    tfm_args = dict(\n        n_token=xlnet_config.n_token,\n        initializer=initializer,\n        attn_type=""bi"",\n        n_layer=xlnet_config.n_layer,\n        d_model=xlnet_config.d_model,\n        n_head=xlnet_config.n_head,\n        d_head=xlnet_config.d_head,\n        d_inner=xlnet_config.d_inner,\n        ff_activation=xlnet_config.ff_activation,\n        untie_r=xlnet_config.untie_r,\n\n        is_training=run_config.is_training,\n        use_bfloat16=run_config.use_bfloat16,\n        use_tpu=run_config.use_tpu,\n        dropout=run_config.dropout,\n        dropatt=run_config.dropatt,\n\n        mem_len=run_config.mem_len,\n        reuse_len=run_config.reuse_len,\n        bi_data=run_config.bi_data,\n        clamp_len=run_config.clamp_len,\n        same_length=run_config.same_length\n    )\n\n    input_args = dict(\n        inp_k=input_ids,\n        seg_id=seg_ids,\n        input_mask=input_mask,\n        mems=mems,\n        perm_mask=perm_mask,\n        target_mapping=target_mapping,\n        inp_q=inp_q)\n    tfm_args.update(input_args)\n\n    with tf.variable_scope(""model"", reuse=tf.AUTO_REUSE):\n      (self.output, self.new_mems, self.lookup_table\n          ) = modeling.transformer_xl(**tfm_args)\n\n    self.input_mask = input_mask\n    self.initializer = initializer\n    self.xlnet_config = xlnet_config\n    self.run_config = run_config\n\n  def get_pooled_out(self, summary_type, use_summ_proj=True):\n    """"""\n    Args:\n      summary_type: str, ""last"", ""first"", ""mean"", or ""attn"". The method\n        to pool the input to get a vector representation.\n      use_summ_proj: bool, whether to use a linear projection during pooling.\n\n    Returns:\n      float32 Tensor in shape [bsz, d_model], the pooled representation.\n    """"""\n\n    xlnet_config = self.xlnet_config\n    run_config = self.run_config\n\n    with tf.variable_scope(""model"", reuse=tf.AUTO_REUSE):\n      summary = modeling.summarize_sequence(\n          summary_type=summary_type,\n          hidden=self.output,\n          d_model=xlnet_config.d_model,\n          n_head=xlnet_config.n_head,\n          d_head=xlnet_config.d_head,\n          dropout=run_config.dropout,\n          dropatt=run_config.dropatt,\n          is_training=run_config.is_training,\n          input_mask=self.input_mask,\n          initializer=self.initializer,\n          use_proj=use_summ_proj)\n\n    return summary\n\n  def get_sequence_output(self):\n    """"""\n    Returns:\n      float32 Tensor in shape [len, bsz, d_model]. The last layer hidden\n      representation of XLNet.\n    """"""\n\n    return self.output\n\n  def get_new_memory(self):\n    """"""\n    Returns:\n      list of float32 Tensors in shape [mem_len, bsz, d_model], the new\n      memory that concatenates the previous memory with the current input\n      representations.\n      The length of the list equals n_layer.\n    """"""\n    return self.new_mems\n\n  def get_embedding_table(self):\n    """"""\n    Returns:\n      float32 Tensor in shape [n_token, d_model]. The embedding lookup table.\n      Used for tying embeddings between input and output layers.\n    """"""\n    return self.lookup_table\n\n  def get_initializer(self):\n    """"""\n    Returns:\n      A tf initializer. Used to initialize variables in layers on top of XLNet.\n    """"""\n    return self.initializer\n\n'"
