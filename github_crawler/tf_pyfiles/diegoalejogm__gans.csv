file_path,api_count,code
utils.py,0,"b""import os\nimport numpy as np\nimport errno\nimport torchvision.utils as vutils\nfrom tensorboardX import SummaryWriter\nfrom IPython import display\nfrom matplotlib import pyplot as plt\nimport torch\n\n'''\n    TensorBoard Data will be stored in './runs' path\n'''\n\n\nclass Logger:\n\n    def __init__(self, model_name, data_name):\n        self.model_name = model_name\n        self.data_name = data_name\n\n        self.comment = '{}_{}'.format(model_name, data_name)\n        self.data_subdir = '{}/{}'.format(model_name, data_name)\n\n        # TensorBoard\n        self.writer = SummaryWriter(comment=self.comment)\n\n    def log(self, d_error, g_error, epoch, n_batch, num_batches):\n\n        # var_class = torch.autograd.variable.Variable\n        if isinstance(d_error, torch.autograd.Variable):\n            d_error = d_error.data.cpu().numpy()\n        if isinstance(g_error, torch.autograd.Variable):\n            g_error = g_error.data.cpu().numpy()\n\n        step = Logger._step(epoch, n_batch, num_batches)\n        self.writer.add_scalar(\n            '{}/D_error'.format(self.comment), d_error, step)\n        self.writer.add_scalar(\n            '{}/G_error'.format(self.comment), g_error, step)\n\n    def log_images(self, images, num_images, epoch, n_batch, num_batches, format='NCHW', normalize=True):\n        '''\n        input images are expected in format (NCHW)\n        '''\n        if type(images) == np.ndarray:\n            images = torch.from_numpy(images)\n        \n        if format=='NHWC':\n            images = images.transpose(1,3)\n        \n\n        step = Logger._step(epoch, n_batch, num_batches)\n        img_name = '{}/images{}'.format(self.comment, '')\n\n        # Make horizontal grid from image tensor\n        horizontal_grid = vutils.make_grid(\n            images, normalize=normalize, scale_each=True)\n        # Make vertical grid from image tensor\n        nrows = int(np.sqrt(num_images))\n        grid = vutils.make_grid(\n            images, nrow=nrows, normalize=True, scale_each=True)\n\n        # Add horizontal images to tensorboard\n        self.writer.add_image(img_name, horizontal_grid, step)\n\n        # Save plots\n        self.save_torch_images(horizontal_grid, grid, epoch, n_batch)\n\n    def save_torch_images(self, horizontal_grid, grid, epoch, n_batch, plot_horizontal=True):\n        out_dir = './data/images/{}'.format(self.data_subdir)\n        Logger._make_dir(out_dir)\n\n        # Plot and save horizontal\n        fig = plt.figure(figsize=(16, 16))\n        plt.imshow(np.moveaxis(horizontal_grid.numpy(), 0, -1))\n        plt.axis('off')\n        if plot_horizontal:\n            display.display(plt.gcf())\n        self._save_images(fig, epoch, n_batch, 'hori')\n        plt.close()\n\n        # Save squared\n        fig = plt.figure()\n        plt.imshow(np.moveaxis(grid.numpy(), 0, -1))\n        plt.axis('off')\n        self._save_images(fig, epoch, n_batch)\n        plt.close()\n\n    def _save_images(self, fig, epoch, n_batch, comment=''):\n        out_dir = './data/images/{}'.format(self.data_subdir)\n        Logger._make_dir(out_dir)\n        fig.savefig('{}/{}_epoch_{}_batch_{}.png'.format(out_dir,\n                                                         comment, epoch, n_batch))\n\n    def display_status(self, epoch, num_epochs, n_batch, num_batches, d_error, g_error, d_pred_real, d_pred_fake):\n        \n        # var_class = torch.autograd.variable.Variable\n        if isinstance(d_error, torch.autograd.Variable):\n            d_error = d_error.data.cpu().numpy()\n        if isinstance(g_error, torch.autograd.Variable):\n            g_error = g_error.data.cpu().numpy()\n        if isinstance(d_pred_real, torch.autograd.Variable):\n            d_pred_real = d_pred_real.data\n        if isinstance(d_pred_fake, torch.autograd.Variable):\n            d_pred_fake = d_pred_fake.data\n        \n        \n        print('Epoch: [{}/{}], Batch Num: [{}/{}]'.format(\n            epoch,num_epochs, n_batch, num_batches)\n             )\n        print('Discriminator Loss: {:.4f}, Generator Loss: {:.4f}'.format(d_error, g_error))\n        print('D(x): {:.4f}, D(G(z)): {:.4f}'.format(d_pred_real.mean(), d_pred_fake.mean()))\n\n    def save_models(self, generator, discriminator, epoch):\n        out_dir = './data/models/{}'.format(self.data_subdir)\n        Logger._make_dir(out_dir)\n        torch.save(generator.state_dict(),\n                   '{}/G_epoch_{}'.format(out_dir, epoch))\n        torch.save(discriminator.state_dict(),\n                   '{}/D_epoch_{}'.format(out_dir, epoch))\n\n    def close(self):\n        self.writer.close()\n\n    # Private Functionality\n\n    @staticmethod\n    def _step(epoch, n_batch, num_batches):\n        return epoch * num_batches + n_batch\n\n    @staticmethod\n    def _make_dir(directory):\n        try:\n            os.makedirs(directory)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n"""
